Index: .idea/NeoCom.iml
===================================================================
diff --git a/.idea/NeoCom.iml b/.idea/NeoCom.iml
deleted file mode 100644
--- a/.idea/NeoCom.iml	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ /dev/null	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="PYTHON_MODULE" version="4">
-  <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.7" jdkType="Python SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: .idea/modules.xml
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
--- a/.idea/modules.xml	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ /dev/null	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/NeoCom.iml" filepath="$PROJECT_DIR$/.idea/NeoCom.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
Index: .idea/inspectionProfiles/profiles_settings.xml
===================================================================
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
deleted file mode 100644
--- a/.idea/inspectionProfiles/profiles_settings.xml	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ /dev/null	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
@@ -1,6 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <settings>
-    <option name="USE_PROJECT_PROFILE" value="false" />
-    <version value="1.0" />
-  </settings>
-</component>
\ No newline at end of file
Index: .idea/misc.xml
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
deleted file mode 100644
--- a/.idea/misc.xml	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ /dev/null	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7" project-jdk-type="Python SDK" />
-</project>
\ No newline at end of file
Index: .idea/vcs.xml
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
deleted file mode 100644
--- a/.idea/vcs.xml	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ /dev/null	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-  </component>
-</project>
\ No newline at end of file
Index: .idea/.gitignore
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
deleted file mode 100644
--- a/.idea/.gitignore	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ /dev/null	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
@@ -1,3 +0,0 @@
-# Default ignored files
-/shelf/
-/workspace.xml
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"231dd863-8fdb-4c84-9cf6-56fbca50fca0\" name=\"Default Changelist\" comment=\"\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FavoritesManager\">\r\n    <favorites_list name=\"NeoCom\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n    <option name=\"UPDATE_TYPE\" value=\"MERGE\" />\r\n  </component>\r\n  <component name=\"IgnoredFileRootStore\">\r\n    <option name=\"generatedRoots\">\r\n      <set>\r\n        <option value=\"$PROJECT_DIR$/.idea\" />\r\n      </set>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"28xpqjmxktDs0QOssh4ZHndXAjE\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showExcludedFiles\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"$PROJECT_DIR$\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.GUI\">\r\n    <configuration name=\"GUI\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\">\r\n      <module name=\"Neocom\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"/usr/local/bin/python3.7\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/GUI.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Model_Micro_GUI11_EField\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\">\r\n      <module name=\"NeoCom\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Model_Micro_GUI11_EField.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.GUI\" />\r\n        <item itemvalue=\"Python.Model_Micro_GUI11_EField\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"ServiceViewManager\">\r\n    <option name=\"viewStates\">\r\n      <list>\r\n        <serviceView>\r\n          <treeState>\r\n            <expand />\r\n            <select />\r\n          </treeState>\r\n        </serviceView>\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"SvnConfiguration\">\r\n    <configuration />\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"231dd863-8fdb-4c84-9cf6-56fbca50fca0\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1652168283248</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1652168283248</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"LFP2 update\">\r\n      <created>1652946721960</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652946721960</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"LFP2 update\">\r\n      <created>1652946770922</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652946770922</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"LFP2 update\">\r\n      <created>1652949349912</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652949349912</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"4\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"LFP2 update\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"LFP2 update\" />\r\n  </component>\r\n  <component name=\"WindowStateProjectService\">\r\n    <state x=\"448\" y=\"48\" key=\"#GUI\" timestamp=\"1652174189183\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"783\" />\r\n    </state>\r\n    <state x=\"448\" y=\"48\" key=\"#GUI/0.23.1440.783@0.23.1440.783\" timestamp=\"1652174189183\" />\r\n    <state x=\"365\" y=\"23\" width=\"709\" height=\"792\" key=\"CommitChangelistDialog2\" timestamp=\"1652949349519\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"795\" />\r\n    </state>\r\n    <state x=\"365\" y=\"23\" width=\"709\" height=\"792\" key=\"CommitChangelistDialog2/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946770567\" />\r\n    <state x=\"365\" y=\"23\" key=\"CommitChangelistDialog2/0.23.1440.795@0.23.1440.795\" timestamp=\"1652949349519\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.bottom\" timestamp=\"1652946680641\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.bottom/0.23.1440.781@0.23.1440.781\" timestamp=\"1652362174944\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.bottom/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094334\" />\r\n    <state width=\"1419\" height=\"199\" key=\"GridCell.Tab.0.bottom/0.23.1440.788@0.23.1440.788\" timestamp=\"1652174762604\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.bottom/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680641\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.bottom/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292911\" />\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.bottom/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881081135\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.bottom/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135089\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.center\" timestamp=\"1652946680640\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.center/0.23.1440.781@0.23.1440.781\" timestamp=\"1652362174932\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.center/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094331\" />\r\n    <state width=\"1419\" height=\"199\" key=\"GridCell.Tab.0.center/0.23.1440.788@0.23.1440.788\" timestamp=\"1652174762598\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.center/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680640\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.center/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292909\" />\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.center/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881081134\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.center/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135088\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.left\" timestamp=\"1652946680638\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.left/0.23.1440.781@0.23.1440.781\" timestamp=\"1652362174932\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.left/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094330\" />\r\n    <state width=\"1419\" height=\"199\" key=\"GridCell.Tab.0.left/0.23.1440.788@0.23.1440.788\" timestamp=\"1652174762597\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.left/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680638\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.left/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292909\" />\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.left/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881081133\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.left/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135087\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.right\" timestamp=\"1652946680640\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.right/0.23.1440.781@0.23.1440.781\" timestamp=\"1652362174933\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.right/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094332\" />\r\n    <state width=\"1419\" height=\"199\" key=\"GridCell.Tab.0.right/0.23.1440.788@0.23.1440.788\" timestamp=\"1652174762602\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.right/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680640\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.right/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292910\" />\r\n    <state width=\"1419\" height=\"216\" key=\"GridCell.Tab.0.right/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881081135\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.0.right/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135088\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom\" timestamp=\"1652946680644\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom/0.23.1440.781@0.23.1440.781\" timestamp=\"1652358748397\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094163\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680644\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292343\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881078891\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.bottom/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135091\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center\" timestamp=\"1652946680643\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center/0.23.1440.781@0.23.1440.781\" timestamp=\"1652358748396\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094163\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680643\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292342\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881078889\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.center/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135090\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left\" timestamp=\"1652946680642\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left/0.23.1440.781@0.23.1440.781\" timestamp=\"1652358748396\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094162\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680642\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292339\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881078889\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.left/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135090\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right\" timestamp=\"1652946680643\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"792\" />\r\n    </state>\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right/0.23.1440.781@0.23.1440.781\" timestamp=\"1652358748397\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right/0.23.1440.783@0.23.1440.783\" timestamp=\"1652364094163\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946680643\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right/0.23.1440.795@0.23.1440.795\" timestamp=\"1652946292343\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right/0.23.1440.798@0.23.1440.798\" timestamp=\"1652881078890\" />\r\n    <state width=\"1419\" height=\"247\" key=\"GridCell.Tab.1.right/0.23.1440.801@0.23.1440.801\" timestamp=\"1652715135091\" />\r\n    <state x=\"320\" y=\"144\" key=\"Vcs.Push.Dialog.v2\" timestamp=\"1652949351877\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"795\" />\r\n    </state>\r\n    <state x=\"320\" y=\"144\" key=\"Vcs.Push.Dialog.v2/0.23.1440.792@0.23.1440.792\" timestamp=\"1652946775398\" />\r\n    <state x=\"320\" y=\"144\" key=\"Vcs.Push.Dialog.v2/0.23.1440.795@0.23.1440.795\" timestamp=\"1652949351877\" />\r\n    <state x=\"413\" y=\"248\" key=\"com.intellij.ide.util.TipDialog\" timestamp=\"1652174168044\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"783\" />\r\n    </state>\r\n    <state x=\"413\" y=\"248\" key=\"com.intellij.ide.util.TipDialog/0.23.1440.783@0.23.1440.783\" timestamp=\"1652174168044\" />\r\n    <state x=\"525\" y=\"338\" key=\"com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2\" timestamp=\"1652339434424\">\r\n      <screen x=\"0\" y=\"23\" width=\"1440\" height=\"781\" />\r\n    </state>\r\n    <state x=\"525\" y=\"338\" key=\"com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.1440.781@0.23.1440.781\" timestamp=\"1652339434424\" />\r\n    <state x=\"525\" y=\"339\" key=\"com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.1440.783@0.23.1440.783\" timestamp=\"1652174210607\" />\r\n    <state x=\"525\" y=\"341\" key=\"com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.1440.788@0.23.1440.788\" timestamp=\"1652174946076\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/CorticalColumn.py</url>\r\n          <line>2568</line>\r\n          <option name=\"timeStamp\" value=\"6\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/CorticalColumn.py</url>\r\n          <line>1460</line>\r\n          <option name=\"timeStamp\" value=\"7\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/CorticalColumn.py</url>\r\n          <line>2191</line>\r\n          <option name=\"timeStamp\" value=\"8\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ b/.idea/workspace.xml	(date 1653052642009)
@@ -1,7 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="231dd863-8fdb-4c84-9cf6-56fbca50fca0" name="Default Changelist" comment="" />
+    <list default="true" id="231dd863-8fdb-4c84-9cf6-56fbca50fca0" name="Default Changelist" comment="">
+      <change beforePath="$PROJECT_DIR$/.idea/.gitignore" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/NeoCom.iml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/inspectionProfiles/profiles_settings.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/modules.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/CorticalColumn.py" beforeDir="false" afterPath="$PROJECT_DIR$/CorticalColumn.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/GUI.py" beforeDir="false" afterPath="$PROJECT_DIR$/GUI.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/logdata.log" beforeDir="false" afterPath="$PROJECT_DIR$/logdata.log" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -25,12 +36,12 @@
   <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
-    <option name="showExcludedFiles" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
   <component name="PropertiesComponent">
     <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
     <property name="last_opened_file_path" value="$PROJECT_DIR$" />
+    <property name="settings.editor.selected.configurable" value="com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable" />
   </component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
@@ -38,14 +49,35 @@
     </key>
   </component>
   <component name="RunManager" selected="Python.GUI">
+    <configuration name="CorticalColumn" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="NeoCom" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/CorticalColumn.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
     <configuration name="GUI" type="PythonConfigurationType" factoryName="Python" temporary="true">
-      <module name="Neocom" />
+      <module name="NeoCom" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
-      <option name="SDK_HOME" value="/usr/local/bin/python3.7" />
+      <option name="SDK_HOME" value="C:\Users\Mariam\AppData\Local\Programs\Python\Python37\python.exe" />
       <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
       <option name="IS_MODULE_SDK" value="false" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
@@ -80,9 +112,15 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
+    <list>
+      <item itemvalue="Python.GUI" />
+      <item itemvalue="Python.Model_Micro_GUI11_EField" />
+      <item itemvalue="Python.CorticalColumn" />
+    </list>
     <recent_temporary>
       <list>
         <item itemvalue="Python.GUI" />
+        <item itemvalue="Python.CorticalColumn" />
         <item itemvalue="Python.Model_Micro_GUI11_EField" />
       </list>
     </recent_temporary>
@@ -99,6 +137,7 @@
       </list>
     </option>
   </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="SvnConfiguration">
     <configuration />
   </component>
@@ -144,129 +183,23 @@
         </entry>
       </map>
     </option>
+    <option name="oldMeFiltersMigrated" value="true" />
   </component>
   <component name="VcsManagerConfiguration">
     <MESSAGE value="LFP2 update" />
     <option name="LAST_COMMIT_MESSAGE" value="LFP2 update" />
   </component>
-  <component name="WindowStateProjectService">
-    <state x="448" y="48" key="#GUI" timestamp="1652174189183">
-      <screen x="0" y="23" width="1440" height="783" />
-    </state>
-    <state x="448" y="48" key="#GUI/0.23.1440.783@0.23.1440.783" timestamp="1652174189183" />
-    <state x="365" y="23" width="709" height="792" key="CommitChangelistDialog2" timestamp="1652949349519">
-      <screen x="0" y="23" width="1440" height="795" />
-    </state>
-    <state x="365" y="23" width="709" height="792" key="CommitChangelistDialog2/0.23.1440.792@0.23.1440.792" timestamp="1652946770567" />
-    <state x="365" y="23" key="CommitChangelistDialog2/0.23.1440.795@0.23.1440.795" timestamp="1652949349519" />
-    <state width="1419" height="247" key="GridCell.Tab.0.bottom" timestamp="1652946680641">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="216" key="GridCell.Tab.0.bottom/0.23.1440.781@0.23.1440.781" timestamp="1652362174944" />
-    <state width="1419" height="247" key="GridCell.Tab.0.bottom/0.23.1440.783@0.23.1440.783" timestamp="1652364094334" />
-    <state width="1419" height="199" key="GridCell.Tab.0.bottom/0.23.1440.788@0.23.1440.788" timestamp="1652174762604" />
-    <state width="1419" height="247" key="GridCell.Tab.0.bottom/0.23.1440.792@0.23.1440.792" timestamp="1652946680641" />
-    <state width="1419" height="247" key="GridCell.Tab.0.bottom/0.23.1440.795@0.23.1440.795" timestamp="1652946292911" />
-    <state width="1419" height="216" key="GridCell.Tab.0.bottom/0.23.1440.798@0.23.1440.798" timestamp="1652881081135" />
-    <state width="1419" height="247" key="GridCell.Tab.0.bottom/0.23.1440.801@0.23.1440.801" timestamp="1652715135089" />
-    <state width="1419" height="247" key="GridCell.Tab.0.center" timestamp="1652946680640">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="216" key="GridCell.Tab.0.center/0.23.1440.781@0.23.1440.781" timestamp="1652362174932" />
-    <state width="1419" height="247" key="GridCell.Tab.0.center/0.23.1440.783@0.23.1440.783" timestamp="1652364094331" />
-    <state width="1419" height="199" key="GridCell.Tab.0.center/0.23.1440.788@0.23.1440.788" timestamp="1652174762598" />
-    <state width="1419" height="247" key="GridCell.Tab.0.center/0.23.1440.792@0.23.1440.792" timestamp="1652946680640" />
-    <state width="1419" height="247" key="GridCell.Tab.0.center/0.23.1440.795@0.23.1440.795" timestamp="1652946292909" />
-    <state width="1419" height="216" key="GridCell.Tab.0.center/0.23.1440.798@0.23.1440.798" timestamp="1652881081134" />
-    <state width="1419" height="247" key="GridCell.Tab.0.center/0.23.1440.801@0.23.1440.801" timestamp="1652715135088" />
-    <state width="1419" height="247" key="GridCell.Tab.0.left" timestamp="1652946680638">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="216" key="GridCell.Tab.0.left/0.23.1440.781@0.23.1440.781" timestamp="1652362174932" />
-    <state width="1419" height="247" key="GridCell.Tab.0.left/0.23.1440.783@0.23.1440.783" timestamp="1652364094330" />
-    <state width="1419" height="199" key="GridCell.Tab.0.left/0.23.1440.788@0.23.1440.788" timestamp="1652174762597" />
-    <state width="1419" height="247" key="GridCell.Tab.0.left/0.23.1440.792@0.23.1440.792" timestamp="1652946680638" />
-    <state width="1419" height="247" key="GridCell.Tab.0.left/0.23.1440.795@0.23.1440.795" timestamp="1652946292909" />
-    <state width="1419" height="216" key="GridCell.Tab.0.left/0.23.1440.798@0.23.1440.798" timestamp="1652881081133" />
-    <state width="1419" height="247" key="GridCell.Tab.0.left/0.23.1440.801@0.23.1440.801" timestamp="1652715135087" />
-    <state width="1419" height="247" key="GridCell.Tab.0.right" timestamp="1652946680640">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="216" key="GridCell.Tab.0.right/0.23.1440.781@0.23.1440.781" timestamp="1652362174933" />
-    <state width="1419" height="247" key="GridCell.Tab.0.right/0.23.1440.783@0.23.1440.783" timestamp="1652364094332" />
-    <state width="1419" height="199" key="GridCell.Tab.0.right/0.23.1440.788@0.23.1440.788" timestamp="1652174762602" />
-    <state width="1419" height="247" key="GridCell.Tab.0.right/0.23.1440.792@0.23.1440.792" timestamp="1652946680640" />
-    <state width="1419" height="247" key="GridCell.Tab.0.right/0.23.1440.795@0.23.1440.795" timestamp="1652946292910" />
-    <state width="1419" height="216" key="GridCell.Tab.0.right/0.23.1440.798@0.23.1440.798" timestamp="1652881081135" />
-    <state width="1419" height="247" key="GridCell.Tab.0.right/0.23.1440.801@0.23.1440.801" timestamp="1652715135088" />
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom" timestamp="1652946680644">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom/0.23.1440.781@0.23.1440.781" timestamp="1652358748397" />
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom/0.23.1440.783@0.23.1440.783" timestamp="1652364094163" />
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom/0.23.1440.792@0.23.1440.792" timestamp="1652946680644" />
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom/0.23.1440.795@0.23.1440.795" timestamp="1652946292343" />
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom/0.23.1440.798@0.23.1440.798" timestamp="1652881078891" />
-    <state width="1419" height="247" key="GridCell.Tab.1.bottom/0.23.1440.801@0.23.1440.801" timestamp="1652715135091" />
-    <state width="1419" height="247" key="GridCell.Tab.1.center" timestamp="1652946680643">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="247" key="GridCell.Tab.1.center/0.23.1440.781@0.23.1440.781" timestamp="1652358748396" />
-    <state width="1419" height="247" key="GridCell.Tab.1.center/0.23.1440.783@0.23.1440.783" timestamp="1652364094163" />
-    <state width="1419" height="247" key="GridCell.Tab.1.center/0.23.1440.792@0.23.1440.792" timestamp="1652946680643" />
-    <state width="1419" height="247" key="GridCell.Tab.1.center/0.23.1440.795@0.23.1440.795" timestamp="1652946292342" />
-    <state width="1419" height="247" key="GridCell.Tab.1.center/0.23.1440.798@0.23.1440.798" timestamp="1652881078889" />
-    <state width="1419" height="247" key="GridCell.Tab.1.center/0.23.1440.801@0.23.1440.801" timestamp="1652715135090" />
-    <state width="1419" height="247" key="GridCell.Tab.1.left" timestamp="1652946680642">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="247" key="GridCell.Tab.1.left/0.23.1440.781@0.23.1440.781" timestamp="1652358748396" />
-    <state width="1419" height="247" key="GridCell.Tab.1.left/0.23.1440.783@0.23.1440.783" timestamp="1652364094162" />
-    <state width="1419" height="247" key="GridCell.Tab.1.left/0.23.1440.792@0.23.1440.792" timestamp="1652946680642" />
-    <state width="1419" height="247" key="GridCell.Tab.1.left/0.23.1440.795@0.23.1440.795" timestamp="1652946292339" />
-    <state width="1419" height="247" key="GridCell.Tab.1.left/0.23.1440.798@0.23.1440.798" timestamp="1652881078889" />
-    <state width="1419" height="247" key="GridCell.Tab.1.left/0.23.1440.801@0.23.1440.801" timestamp="1652715135090" />
-    <state width="1419" height="247" key="GridCell.Tab.1.right" timestamp="1652946680643">
-      <screen x="0" y="23" width="1440" height="792" />
-    </state>
-    <state width="1419" height="247" key="GridCell.Tab.1.right/0.23.1440.781@0.23.1440.781" timestamp="1652358748397" />
-    <state width="1419" height="247" key="GridCell.Tab.1.right/0.23.1440.783@0.23.1440.783" timestamp="1652364094163" />
-    <state width="1419" height="247" key="GridCell.Tab.1.right/0.23.1440.792@0.23.1440.792" timestamp="1652946680643" />
-    <state width="1419" height="247" key="GridCell.Tab.1.right/0.23.1440.795@0.23.1440.795" timestamp="1652946292343" />
-    <state width="1419" height="247" key="GridCell.Tab.1.right/0.23.1440.798@0.23.1440.798" timestamp="1652881078890" />
-    <state width="1419" height="247" key="GridCell.Tab.1.right/0.23.1440.801@0.23.1440.801" timestamp="1652715135091" />
-    <state x="320" y="144" key="Vcs.Push.Dialog.v2" timestamp="1652949351877">
-      <screen x="0" y="23" width="1440" height="795" />
-    </state>
-    <state x="320" y="144" key="Vcs.Push.Dialog.v2/0.23.1440.792@0.23.1440.792" timestamp="1652946775398" />
-    <state x="320" y="144" key="Vcs.Push.Dialog.v2/0.23.1440.795@0.23.1440.795" timestamp="1652949351877" />
-    <state x="413" y="248" key="com.intellij.ide.util.TipDialog" timestamp="1652174168044">
-      <screen x="0" y="23" width="1440" height="783" />
-    </state>
-    <state x="413" y="248" key="com.intellij.ide.util.TipDialog/0.23.1440.783@0.23.1440.783" timestamp="1652174168044" />
-    <state x="525" y="338" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2" timestamp="1652339434424">
-      <screen x="0" y="23" width="1440" height="781" />
-    </state>
-    <state x="525" y="338" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.1440.781@0.23.1440.781" timestamp="1652339434424" />
-    <state x="525" y="339" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.1440.783@0.23.1440.783" timestamp="1652174210607" />
-    <state x="525" y="341" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.1440.788@0.23.1440.788" timestamp="1652174946076" />
-  </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
       <breakpoints>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
           <url>file://$PROJECT_DIR$/CorticalColumn.py</url>
-          <line>2568</line>
+          <line>2534</line>
           <option name="timeStamp" value="6" />
         </line-breakpoint>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
           <url>file://$PROJECT_DIR$/CorticalColumn.py</url>
-          <line>1460</line>
-          <option name="timeStamp" value="7" />
-        </line-breakpoint>
-        <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
-          <url>file://$PROJECT_DIR$/CorticalColumn.py</url>
-          <line>2191</line>
+          <line>2166</line>
           <option name="timeStamp" value="8" />
         </line-breakpoint>
       </breakpoints>
Index: logdata.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>ERROR:root:main crashed. Error: <class 'ValueError'>\r\ncannot compute fingerprint of empty list\r\n<traceback object at 0x156c70a00>\r\nERROR:root:Tracing exception: ValueError \"cannot compute fingerprint of empty list\" \r\non line 1803 of file /Users/mariamalharrach/Documents/NeoCom/GUI.py function PlaceCell_func\r\nERROR:root:  File \"/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py\", line 2127, in <module>\r\n    main()\r\n\r\n\r\nERROR:root:  File \"/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py\", line 2118, in main\r\n    globals = debugger.run(setup['file'], None, None, is_module)\r\n\r\n\r\nERROR:root:  File \"/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py\", line 1427, in run\r\n    return self._exec(is_module, entry_point_fn, module_name, file, globals, locals)\r\n\r\n\r\nERROR:root:  File \"/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py\", line 1434, in _exec\r\n    pydev_imports.execfile(file, globals, locals)  # execute the script\r\n\r\n\r\nERROR:root:  File \"/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/_pydev_imps/_pydev_execfile.py\", line 18, in execfile\r\n    exec(compile(contents+\"\\n\", file, 'exec'), glob, loc)\r\n\r\n\r\nERROR:root:  File \"/Users/mariamalharrach/Documents/NeoCom/GUI.py\", line 4634, in <module>\r\n    main()\r\n\r\n\r\nERROR:root:  File \"/Users/mariamalharrach/Documents/NeoCom/GUI.py\", line 4630, in main\r\n    sys.exit(app.exec())\r\n\r\n\r\nERROR:root:  File \"/Users/mariamalharrach/Documents/NeoCom/GUI.py\", line 1803, in PlaceCell_func\r\n    self.update_Model()\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logdata.log b/logdata.log
--- a/logdata.log	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ b/logdata.log	(date 1653057242657)
@@ -1,37 +1,0 @@
-ERROR:root:main crashed. Error: <class 'ValueError'>
-cannot compute fingerprint of empty list
-<traceback object at 0x156c70a00>
-ERROR:root:Tracing exception: ValueError "cannot compute fingerprint of empty list" 
-on line 1803 of file /Users/mariamalharrach/Documents/NeoCom/GUI.py function PlaceCell_func
-ERROR:root:  File "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py", line 2127, in <module>
-    main()
-
-
-ERROR:root:  File "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py", line 2118, in main
-    globals = debugger.run(setup['file'], None, None, is_module)
-
-
-ERROR:root:  File "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py", line 1427, in run
-    return self._exec(is_module, entry_point_fn, module_name, file, globals, locals)
-
-
-ERROR:root:  File "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevd.py", line 1434, in _exec
-    pydev_imports.execfile(file, globals, locals)  # execute the script
-
-
-ERROR:root:  File "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/_pydev_imps/_pydev_execfile.py", line 18, in execfile
-    exec(compile(contents+"\n", file, 'exec'), glob, loc)
-
-
-ERROR:root:  File "/Users/mariamalharrach/Documents/NeoCom/GUI.py", line 4634, in <module>
-    main()
-
-
-ERROR:root:  File "/Users/mariamalharrach/Documents/NeoCom/GUI.py", line 4630, in main
-    sys.exit(app.exec())
-
-
-ERROR:root:  File "/Users/mariamalharrach/Documents/NeoCom/GUI.py", line 1803, in PlaceCell_func
-    self.update_Model()
-
-
Index: CorticalColumn.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>__author__ = 'Mariam, Maxime'\r\n\r\nimport cProfile\r\nimport pstats\r\nimport os\r\nimport sys\r\nimport numpy as np\r\nimport math\r\nimport scipy\r\nimport scipy.io as sio\r\nfrom scipy.spatial import distance\r\nfrom scipy import sparse\r\nfrom scipy import signal\r\nimport pickle\r\nimport pandas as pd\r\nimport time\r\nfrom mpl_toolkits.mplot3d import axes3d, Axes3D\r\nimport inspect\r\nimport copy\r\nimport subprocess\r\nimport struct\r\nimport random\r\nimport CC_vtk\r\nimport SST_neo\r\nimport PV_neo\r\nimport VIP_neo\r\nimport RLN_neo\r\nimport PC_neo3\r\n#import pyscenarios\r\nimport csv\r\n#import pyedflib\r\nimport datetime\r\nfrom numba import guvectorize,vectorize, float64, int64\r\nfrom numba.experimental import jitclass\r\nfrom numba import jit, njit, types, typeof\r\nimport Cell_morphology\r\n# import circos\r\n#import bigfloat\r\n#bigfloat.exp(5000,bigfloat.precision(100))\r\nfrom PyQt5.QtCore import *\r\nimport matplotlib as plt\r\n\r\n\r\n@njit\r\ndef find_intersection(r1, r2, d):\r\n    rad1sqr = r1 ** 2\r\n    rad2sqr = r2 ** 2\r\n\r\n    if d == 0:\r\n        return math.pi * min(r1, r2) ** 2\r\n\r\n    angle1 = (rad1sqr + d ** 2 - rad2sqr) / (2 * r1 * d)\r\n    angle2 = (rad2sqr + d ** 2 - rad1sqr) / (2 * r2 * d)\r\n\r\n    if (-1 <= angle1 < 1) or (-1 <= angle2 < 1):\r\n        theta1 = math.acos(angle1) * 2\r\n        theta2 = math.acos(angle2) * 2\r\n        area1 = (0.5 * theta2 * rad2sqr) - (0.5 * rad2sqr * math.sin(theta2))\r\n        area2 = (0.5 * theta1 * rad1sqr) - (0.5 * rad1sqr * math.sin(theta1))\r\n\r\n        return area1 + area2\r\n    elif angle1 < -1 or angle2 < -1:\r\n        return math.pi * min(r1, r2) ** 2\r\n    return 0\r\n\r\nclass SenderObject(QObject):\r\n    something_happened = pyqtSignal(np.float)\r\n\r\nclass SenderObjectInt(QObject):\r\n    something_happened = pyqtSignal(np.int)\r\n\r\nspec1 = [\r\n    ('PreSynaptic_Cell_AMPA'    , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynaptic_Cell_GABA'    , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynaptic_Soma_AMPA'    , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynaptic_Soma_GABA_d'    , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynaptic_Soma_GABA_s', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynaptic_Soma_GABA_a', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('ExternalPreSynaptic_Cell_AMPA_DPYR'   , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('ExternalPreSynaptic_Cell_AMPA_Th'     , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticWeight_AMPA'               , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_AMPA1', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_AMPA2', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_AMPA3', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_AMPA4', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_AMPA5', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticWeight_GABA'               , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_GABA1'               , types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_GABA2', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_GABA3', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_GABA4', types.List(typeof(np.array([], dtype=np.int32)))),\r\n    ('PreSynapticPos_GABA5', types.List(typeof(np.array([], dtype=np.int32)))),\r\n\r\n]\r\n\r\n\r\n@jitclass(spec1)\r\nclass presynaptic_class():\r\n    def __init__(self, PreSynaptic_Cell_AMPA,\r\n                 PreSynaptic_Cell_GABA,\r\n                 PreSynaptic_Soma_AMPA,\r\n                 PreSynaptic_Soma_GABA_d,\r\n                 PreSynaptic_Soma_GABA_s,\r\n                 PreSynaptic_Soma_GABA_a,\r\n                 ExternalPreSynaptic_Cell_AMPA_DPYR,\r\n                 ExternalPreSynaptic_Cell_AMPA_Th,\r\n                 PreSynapticWeight_AMPA,\r\n                 PreSynapticPos_AMPA1,\r\n                 PreSynapticPos_AMPA2,\r\n                 PreSynapticPos_AMPA3,\r\n                 PreSynapticPos_AMPA4,\r\n                 PreSynapticPos_AMPA5,\r\n                 PreSynapticWeight_GABA,\r\n                 PreSynapticPos_GABA1,\r\n                 PreSynapticPos_GABA2,\r\n                 PreSynapticPos_GABA3,\r\n                 PreSynapticPos_GABA4,\r\n                 PreSynapticPos_GABA5):\r\n        self.PreSynaptic_Cell_AMPA = PreSynaptic_Cell_AMPA\r\n        self.PreSynaptic_Cell_GABA = PreSynaptic_Cell_GABA\r\n        self.PreSynaptic_Soma_AMPA = PreSynaptic_Soma_AMPA\r\n        self.PreSynaptic_Soma_GABA_d = PreSynaptic_Soma_GABA_d\r\n        self.PreSynaptic_Soma_GABA_s = PreSynaptic_Soma_GABA_s\r\n        self.PreSynaptic_Soma_GABA_a = PreSynaptic_Soma_GABA_a\r\n        self.ExternalPreSynaptic_Cell_AMPA_DPYR =ExternalPreSynaptic_Cell_AMPA_DPYR\r\n        self.ExternalPreSynaptic_Cell_AMPA_Th = ExternalPreSynaptic_Cell_AMPA_Th\r\n        self.PreSynapticWeight_AMPA = PreSynapticWeight_AMPA\r\n        self.PreSynapticPos_AMPA1 = PreSynapticPos_AMPA1\r\n        self.PreSynapticPos_AMPA2 = PreSynapticPos_AMPA2\r\n        self.PreSynapticPos_AMPA3 = PreSynapticPos_AMPA3\r\n        self.PreSynapticPos_AMPA4 = PreSynapticPos_AMPA4\r\n        self.PreSynapticPos_AMPA5 = PreSynapticPos_AMPA5\r\n        self.PreSynapticWeight_GABA = PreSynapticWeight_GABA\r\n        self.PreSynapticPos_GABA1 = PreSynapticPos_GABA1\r\n        self.PreSynapticPos_GABA2 = PreSynapticPos_GABA2\r\n        self.PreSynapticPos_GABA3 = PreSynapticPos_GABA3\r\n        self.PreSynapticPos_GABA4 = PreSynapticPos_GABA4\r\n        self.PreSynapticPos_GABA5 = PreSynapticPos_GABA5\r\n\r\n\r\n@njit\r\ndef Model_compute(nbEch,\r\n                 dt,\r\n                 tps_start,\r\n                 Layer_nbCells,\r\n                 NB_PYR,\r\n                 NB_PV,\r\n                 NB_SST,\r\n                 NB_VIP,\r\n                 NB_RLN,\r\n                 NB_DPYR,\r\n                 NB_Th,\r\n                 inputNB,\r\n                 List_PYR,\r\n                 List_PV,\r\n                 List_SST,\r\n                 List_VIP,\r\n                 List_RLN,\r\n                 List_DPYR,\r\n                 List_Th,\r\n                 Stim_Signals,\r\n                 Stim_InputSignals,\r\n                 Stim_EField,\r\n                 PS,\r\n                 pyrVs,\r\n                 pyrVd,\r\n                 pyrVa,\r\n                 pyrPPSE_d1,\r\n                 pyrPPSE_d23,\r\n                 pyrPPSE_d4,\r\n                 pyrPPSE_d5,\r\n                 pyrPPSE_d6,\r\n                 pyrPPSI_d1,\r\n                 pyrPPSI_d23,\r\n                 pyrPPSI_d4,\r\n                 pyrPPSI_d5,\r\n                 pyrPPSI_d6,\r\n                 pyrPPSI_s,\r\n                 pyrPPSI_a,\r\n                 PV_Vs,\r\n                 SST_Vs,\r\n                 VIP_Vs,\r\n                 RLN_Vs,\r\n                 DPYR_Vs,\r\n                 Th_Vs,\r\n                 layerS,\r\n                 typeS,\r\n                 indexS,\r\n                 t,\r\n                 seed):\r\n\r\n    if not seed == 0:\r\n        np.random.seed(seed)\r\n    # else:\r\n    #     np.random.seed()\r\n    #print(PS.PreSynaptic_Cell_AMPA)\r\n    for i in range(NB_DPYR):  # Distant Pyramidal cells\r\n        List_DPYR[i].dt = dt\r\n    for i in range(NB_Th):  # Thalamus\r\n        List_Th[i].dt = dt\r\n\r\n    # initialize PYR cells:\r\n    for i in range(np.sum(NB_PYR)):  # All PYR cells\r\n        List_PYR[i].dt = dt\r\n    for i in range(np.sum(NB_PV)):\r\n        List_PV[i].dt = dt\r\n    for i in range(np.sum(NB_SST)):\r\n        List_SST[i].dt = dt\r\n    for i in range(np.sum(NB_VIP)):\r\n        List_VIP[i].dt = dt\r\n    for i in range(np.sum(NB_RLN)):\r\n        List_RLN[i].dt = dt\r\n\r\n    for tt, tp in enumerate(t):\r\n        # if np.mod(tp[tt]*1.,1.01)<dt:\r\n        #     print(tps_start)\r\n        tps_start += dt\r\n        for i in range(NB_DPYR):  ###distant cortex\r\n            List_DPYR[i].init_I_syn()\r\n            List_DPYR[i].updateParameters()\r\n        for i in range(NB_Th):  ###thalamus\r\n            List_Th[i].init_I_syn()\r\n            List_Th[i].updateParameters()\r\n\r\n        for i in range(np.sum(NB_PYR)):\r\n            List_PYR[i].init_I_syn()\r\n            List_PYR[i].updateParameters()\r\n        for i in range(np.sum(NB_PV)):\r\n            List_PV[i].init_I_syn()\r\n            List_PV[i].updateParameters()\r\n        for i in range(np.sum(NB_SST)):\r\n            List_SST[i].init_I_syn()\r\n            List_SST[i].updateParameters()\r\n        for i in range(np.sum(NB_VIP)):\r\n            List_VIP[i].init_I_syn()\r\n            List_VIP[i].updateParameters()\r\n        for i in range(np.sum(NB_RLN)):\r\n            List_RLN[i].init_I_syn()\r\n            List_RLN[i].updateParameters()\r\n\r\n        ####################### Add stim to external cells #######################\r\n        for i in range(NB_DPYR):\r\n            List_DPYR[i].I_soma_stim = Stim_Signals[i, tt]\r\n        for i in range(NB_Th):\r\n            List_Th[i].I_soma_stim = Stim_InputSignals[i, tt]\r\n        for i in range(np.sum(NB_PYR)):# for EField\r\n            List_PYR[i].update_EField_Stim(Stim_EField[tt])\r\n\r\n        ########################################\r\n        curr_pyr = 0\r\n        for i in range(np.sum(Layer_nbCells)):\r\n            nbstim = 0\r\n            nbth = 0\r\n            # print(i)\r\n            #get cell type/layer/index per type\r\n            # layerS, typeS, indexS = self.All2layer(i, Layer_nbCells,NB_PYR, NB_PV, NB_SST, NB_VIP, NB_RLN, List_celltypes)\r\n            neurone = indexS[i]\r\n\r\n            ###Get  Cell's Synaptic input\r\n            #print(typeS[i])\r\n\r\n            if len(PS.PreSynaptic_Cell_AMPA[i]) > 0 or len(PS.ExternalPreSynaptic_Cell_AMPA_DPYR[i]) > 0 or len(PS.ExternalPreSynaptic_Cell_AMPA_Th[i]) > 0:\r\n\r\n                Cell_AMPA = PS.PreSynaptic_Cell_AMPA[i]\r\n                Weight= PS.PreSynapticWeight_AMPA[i]\r\n                if not len(Weight) == 0:\r\n                    # nWeight = (Weight - np.min(Weight)) / (np.max(Weight) - np.min(Weight))\r\n                    nWeight =  Weight / np.max(Weight)\r\n                External_cell_Dpyr = PS.ExternalPreSynaptic_Cell_AMPA_DPYR[i]\r\n                External_cell_Th = PS.ExternalPreSynaptic_Cell_AMPA_Th[i]\r\n\r\n\r\n                W = np.ones(len(Cell_AMPA) + len(External_cell_Dpyr) + len(External_cell_Th))\r\n                Vpre_AMPA = np.zeros(len(Cell_AMPA) + len(External_cell_Dpyr) + len(External_cell_Th))  # nb of external +internal AMPA inputs\r\n                if not len(Weight)==0:\r\n                    W[0:len(Weight)] = nWeight\r\n\r\n                for k, c in enumerate(Cell_AMPA):  # switch case afferences AMPA ---> PC\r\n                    #Get type/layer/ index per type of AMPA inputs == PCs\r\n                    # layer, type, index = All2layer(c,  Layer_nbCells, NB_PYR, NB_PV, NB_SST, NB_VIP, NB_RLN, List_celltypes)\r\n                    Vpre_AMPA[k] = List_PYR[indexS[c]].VAis()\r\n\r\n                #add external input\r\n                if not len(External_cell_Dpyr)==0:\r\n                    for k, c in enumerate(External_cell_Dpyr):  # External afferences from DPYR\r\n                        Vpre_AMPA[k+len(Cell_AMPA)] = List_DPYR[c].VAis()\r\n                if not len(External_cell_Th)==0:\r\n                    for k, c in enumerate(External_cell_Th):  # External afferences from DPYR\r\n                        Vpre_AMPA[k+len(Cell_AMPA)+len(External_cell_Dpyr)] = List_Th[c].VAis()\r\n\r\n\r\n                #switch cell's type to add AMPA input\r\n\r\n                if typeS[i] == 0:  # PC\r\n                    # add stim\r\n                    I_AMPA = List_PYR[neurone].I_AMPA2(Vpre_AMPA)*W\r\n                    I_NMDA = List_PYR[neurone].I_NMDA2(Vpre_AMPA, tps_start)*W\r\n\r\n                    List_PYR[neurone].add_I_synDend_Bis(I_NMDA)\r\n\r\n#                    pyrPPSE_d[curr_pyr, tt] = (np.sum(I_AMPA) + np.sum(I_NMDA)) / List_PYR[neurone].Cm_d\r\n                    x=I_AMPA + I_NMDA\r\n                    print(PS.PreSynapticPos_AMPA)\r\n                    #print(np.argwhere(PS.PreSynapticPos_AMPA == 5))\r\n\r\n                    if len(PS.PreSynapticPos_AMPA5)==0:\r\n                        pyrPPSE_d1[curr_pyr, tt] =0\r\n                    else:\r\n                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA5]) / List_PYR[neurone].Cm_d\r\n\r\n                    if len(PS.PreSynapticPos_AMPA4)==0:\r\n                        pyrPPSE_d23[curr_pyr, tt] =0\r\n                    else:\r\n                        pyrPPSE_d23[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA4]) / List_PYR[neurone].Cm_d\r\n\r\n                    if len(PS.PreSynapticPos_AMPA3)==0:\r\n                        pyrPPSE_d1[curr_pyr, tt] =0\r\n                    else:\r\n                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA3]) / List_PYR[neurone].Cm_d\r\n\r\n                    if len(PS.PreSynapticPos_AMPA2)==0:\r\n                        pyrPPSE_d1[curr_pyr, tt] =0\r\n                    else:\r\n                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA2]) / List_PYR[neurone].Cm_d\r\n\r\n                    if len(PS.PreSynapticPos_AMPA1)==0:\r\n                        pyrPPSE_d1[curr_pyr, tt] =0\r\n                    else:\r\n                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA1]) / List_PYR[neurone].Cm_d\r\n\r\n\r\n                elif typeS[i] == 1:  # PV\r\n\r\n                        #print(List_PYR[neurone].I_AMPA2(Vpre_AMPA)*W)\r\n                    I_AMPA = List_PV[neurone].I_AMPA2(Vpre_AMPA)*W\r\n                    I_NMDA = List_PV[neurone].I_NMDA2(Vpre_AMPA, tps_start)*W\r\n\r\n                    List_PV[neurone].add_I_synSoma(I_AMPA)\r\n                    List_PV[neurone].add_I_synSoma(I_NMDA)\r\n\r\n                elif typeS[i] == 2:  # SST\r\n\r\n                    I_AMPA = List_SST[neurone].I_AMPA2(Vpre_AMPA)*W\r\n                    I_NMDA = List_SST[neurone].I_NMDA2(Vpre_AMPA, tps_start)*W\r\n\r\n                    List_SST[neurone].add_I_synSoma(I_AMPA)\r\n                    List_SST[neurone].add_I_synSoma(I_NMDA)\r\n\r\n                elif typeS[i] == 3:  # VIP\r\n\r\n                    I_AMPA = List_VIP[neurone].I_AMPA2(Vpre_AMPA)*W\r\n                    I_NMDA = List_VIP[neurone].I_NMDA2(Vpre_AMPA, tps_start)*W\r\n\r\n                    List_VIP[neurone].add_I_synSoma(I_AMPA)\r\n                    List_VIP[neurone].add_I_synSoma(I_NMDA)\r\n\r\n                elif typeS[i] == 4:  # RLN\r\n                    I_AMPA = List_RLN[neurone].I_AMPA2(Vpre_AMPA)*W\r\n                    I_NMDA = List_RLN[neurone].I_NMDA2(Vpre_AMPA, tps_start)*W\r\n\r\n                    List_RLN[neurone].add_I_synSoma(I_AMPA)\r\n                    List_RLN[neurone].add_I_synSoma(I_NMDA)\r\n\r\n\r\n\r\n            ########################################################################\r\n            ##GABA\r\n            if len(PS.PreSynaptic_Cell_GABA[i]) > 0:\r\n                Cell_GABA = PS.PreSynaptic_Cell_GABA[i]\r\n                Vpre_GABA = np.zeros(len(Cell_GABA))\r\n                for k, c in enumerate(Cell_GABA):  # switch afferences\r\n                    # layer, type, index = All2layer(c,  Layer_nbCells,NB_PYR, NB_PV, NB_SST, NB_VIP, NB_RLN, List_celltypes)\r\n\r\n                    if typeS[c] == 1:  # PV\r\n                        Vpre_GABA[k] = List_PV[indexS[c]].VsOutput()\r\n                    elif typeS[c] == 2:  # SST\r\n                        Vpre_GABA[k] = List_SST[indexS[c]].VsOutput()\r\n                    elif typeS[c] == 3:  # VIP\r\n                        Vpre_GABA[k] = List_VIP[indexS[c]].VsOutput()\r\n                    elif typeS[c] == 4:  # RLN\r\n                        Vpre_GABA[k] = List_RLN[indexS[c]].VsOutput()\r\n                    else:\r\n                        print('error')\r\n\r\n                if typeS[i] == 0:  # neurone is a PC\r\n                    I_GABA = List_PYR[neurone].I_GABA2(Vpre_GABA, PS.PreSynaptic_Soma_GABA_d[i], PS.PreSynaptic_Soma_GABA_s[i], PS.PreSynaptic_Soma_GABA_a[i])\r\n                    List_PYR[neurone].add_I_synDend(I_GABA, PS.PreSynaptic_Soma_GABA_d[i])\r\n                    List_PYR[neurone].add_I_synSoma(I_GABA, PS.PreSynaptic_Soma_GABA_s[i])\r\n                    List_PYR[neurone].add_I_synAis(I_GABA, PS.PreSynaptic_Soma_GABA_a[i])\r\n###################################Add presynaptic currents per layer for dendrites#################\r\n                    x=I_GABA * PS.PreSynaptic_Soma_GABA_d[i]\r\n\r\n\r\n                    pyrPPSI_d1[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==5)]) / List_PYR[neurone].Cm_d\r\n                    pyrPPSI_d23[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==4)]) / List_PYR[neurone].Cm_d\r\n                    pyrPPSI_d4[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==3)]) / List_PYR[neurone].Cm_d\r\n                    pyrPPSI_d5[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==2)]) / List_PYR[neurone].Cm_d\r\n                    pyrPPSI_d6[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==1)]) / List_PYR[neurone].Cm_d\r\n\r\n\r\n\r\n                    pyrPPSI_s[curr_pyr, tt] = np.sum(I_GABA*PS.PreSynaptic_Soma_GABA_s[i]) / List_PYR[neurone].Cm\r\n                    pyrPPSI_a[curr_pyr, tt] = np.sum(I_GABA*PS.PreSynaptic_Soma_GABA_a[i]) / List_PYR[neurone].Cm\r\n\r\n                elif typeS[i] == 1:  # interneuron PV\r\n                    I_GABA = List_PV[neurone].I_GABA2(Vpre_GABA)\r\n                    #print(neurone)\r\n                    #print(Vpre_GABA)\r\n                    #print(I_GABA)\r\n                    List_PV[neurone].add_I_synSoma(I_GABA)\r\n\r\n                elif typeS[i] == 2:  # interneuron SST\r\n                    I_GABA = List_SST[neurone].I_GABA2(Vpre_GABA)\r\n                    #print(I_GABA)\r\n\r\n                    List_SST[neurone].add_I_synSoma(I_GABA)\r\n\r\n                elif typeS[i] == 3:  # interneuron VIP\r\n                    I_GABA = List_VIP[neurone].I_GABA2(Vpre_GABA)\r\n                    List_VIP[neurone].add_I_synSoma(I_GABA)\r\n\r\n                elif typeS[i] == 4:  # RLN\r\n                    I_GABA = List_RLN[neurone].I_GABA2(Vpre_GABA)\r\n                    List_RLN[neurone].add_I_synSoma(I_GABA)\r\n            if typeS[i] == 0:\r\n                curr_pyr += 1\r\n        #############################################\r\n        ########Range Kutta#########################\r\n        for i in range(NB_DPYR):\r\n            List_DPYR[i].rk4()\r\n\r\n            # print(List_DPYR[i].y[0])\r\n\r\n        for i in range(NB_Th):\r\n            List_Th[i].rk4()\r\n        for i in range(np.sum(NB_PYR)):\r\n            List_PYR[i].rk4()\r\n        for i in range(np.sum(NB_PV)):\r\n            #(List_PV[i].I_synSoma)\r\n            List_PV[i].rk4()\r\n        for i in range(np.sum(NB_SST)):\r\n            List_SST[i].rk4()\r\n        for i in range(np.sum(NB_VIP)):\r\n            List_VIP[i].rk4()\r\n        for i in range(np.sum(NB_RLN)):\r\n            List_RLN[i].rk4()\r\n\r\n        #######Get membrane potential variation#######\r\n\r\n        for i in range(np.sum(NB_PYR)):\r\n            pyrVs[i, tt] = List_PYR[i].y[0]\r\n            pyrVd[i, tt] = List_PYR[i].y[1]\r\n            pyrVa[i, tt] = List_PYR[i].y[28]\r\n        for i in range(np.sum(NB_PV)):\r\n            PV_Vs[i, tt] = List_PV[i].y[0]\r\n        for i in range(np.sum(NB_SST)):\r\n            SST_Vs[i, tt] = List_SST[i].y[0]\r\n        for i in range(np.sum(NB_VIP)):\r\n            VIP_Vs[i, tt] = List_VIP[i].y[0]\r\n        for i in range(np.sum(NB_RLN)):\r\n            RLN_Vs[i, tt] = List_RLN[i].y[0]\r\n\r\n\r\n        for i in range(NB_DPYR):\r\n            DPYR_Vs[i, tt] = List_DPYR[i].y[0]\r\n        for i in range(NB_Th):\r\n            Th_Vs[i, tt] = List_Th[i].y[0]\r\n\r\n\r\n\r\n    tps_start += (t[-1] + dt)\r\n    return t,pyrVs, pyrVd, pyrVa,pyrPPSE_d1,pyrPPSE_d23,pyrPPSE_d4,pyrPPSE_d5,pyrPPSE_d6,  pyrPPSI_d1,  pyrPPSI_d23,  pyrPPSI_d4,  pyrPPSI_d5,  pyrPPSI_d6,  pyrPPSI_s,  pyrPPSI_a, PV_Vs, SST_Vs, VIP_Vs, RLN_Vs, DPYR_Vs, Th_Vs\r\n\r\nclass CorticalColumn:\r\n    updateTime = SenderObject()\r\n    updateCell = SenderObjectInt()\r\n    def __init__(self,d=30):\r\n        self.D = 210 * 2  # neocortical column diameter in micrometers\r\n        self.L = 2082  # neocortical column length in micrometers #Markram et al. 2015\r\n        self.C = 2000\r\n        # self.d = 23  # minicolumn Diameter\r\n        # Layer_d=np.array([165,353+149,190,525,700]) #layers' thicknesses (L1-L2/3-L4-L5-L6)\r\n        self.Layer_d = np.array([165, 353 + 149, 190, 525, 700])  # layers' thicknesses (L1-L2/3-L4-L5-L6)\r\n        self.Layertop_pos=np.cumsum(np.array([700, 525 , 190, 353+149, 165]))\r\n        # Layer_nbCells=np.array([338/3,7524/3,4656/3,6114/3,12651/3])  #total number of cells/neocortical column for each layer (L1-L2/3-L4-L5-L6)\r\n        self.Layer_nbCells = np.array([322,7524, 4656, 6114,\r\n                                  12651]) / d  # total number of cells/neocortical column for each layer (L1-L2/3-L4-L5-L6)\r\n\r\n        self.Nbcells = int(np.sum(self.Layer_nbCells))\r\n        self.PYRpercent = np.array([0,0.7, 0.9, 0.8, 0.9])\r\n        self.INpercent = 1 - self.PYRpercent\r\n        self.PVpercent= np.array([0,0.3, 0.55, 0.45, 0.45])\r\n        self.SSTpercent= np.array([0,0.2, 0.25, 0.40, 0.35])\r\n        self.VIPpercent= np.array([0,0.40, 0.20, 0.15, 0.20])\r\n        self.RLNpercent= np.array([1,0.1, 0, 0, 0])\r\n\r\n\r\n        NBPYR = self.PYRpercent * self.Layer_nbCells\r\n        self.NB_PYR = NBPYR.astype(int)\r\n        print('PYR',self.NB_PYR)\r\n        #subtypes of PYR cells\r\n        self.PCsubtypes_Per=np.array([[0,0,0,0,0],[0.9*self.NB_PYR[1],0,0.1*self.NB_PYR[1],0,0],[0.5*self.NB_PYR[2],0.36*self.NB_PYR[2],0,0,0.14*self.NB_PYR[2]],[self.NB_PYR[3]*0.81,self.NB_PYR[3]*0.19,0,0,0],[self.NB_PYR[4]*0.39,self.NB_PYR[4]*0.17,self.NB_PYR[4]*0.20,self.NB_PYR[4]*0.24,0]]) #TPC,UPC,IPC,BPC,SSC\r\n        print(self.PCsubtypes_Per)\r\n\r\n\r\n        NB_IN = self.INpercent * self.Layer_nbCells\r\n        self.NB_IN = NB_IN.astype(int)\r\n        print('IN',self.NB_IN)\r\n        NB_PV = self.PVpercent * self.NB_IN\r\n        self.NB_PV = NB_PV.astype(int)\r\n        print('PV',self.NB_PV)\r\n        NB_PV_BC = 0.7 * self.NB_PV\r\n        self.NB_PV_BC = NB_PV_BC.astype(int)\r\n        self.NB_PV_ChC = (NB_PV - NB_PV_BC).astype(int)\r\n        NB_SST =self.SSTpercent * self.NB_IN\r\n        self.NB_SST = NB_SST.astype(int)\r\n        print('SST',self.NB_SST)\r\n        NB_VIP = self.VIPpercent * self.NB_IN\r\n        self.NB_VIP = NB_VIP.astype(int)\r\n        print('VIP',self.NB_VIP)\r\n        NB_RLN = self.RLNpercent * self.NB_IN\r\n        self.NB_RLN = NB_RLN.astype(int)\r\n        print('RLN',self.NB_RLN)\r\n        #mini_Layer_nbcells = Layer_nbCells / 310\r\n        self.Layer_nbCells = self.NB_PYR+self.NB_SST+self.NB_PV+self.NB_VIP+self.NB_RLN  # total number of cells/neocortical column for each layer (L1-L2/3-L4-L5-L6)\r\n        print(self.Layer_nbCells)\r\n        #####External afferences\r\n        self.NB_DPYR=int(np.sum(self.NB_PYR)*0.07)\r\n        self.NB_Th=int(np.sum(self.NB_PYR)*0.07)\r\n        self.List_celltypes = np.array([np.array([0]*self.NB_PYR[l] + [1]*self.NB_PV[l] + [2]*self.NB_SST[l] + [3]*self.NB_VIP[l] + [4]*self.NB_RLN[l]).astype(int) for l in range(len(self.Layer_nbCells))])\r\n        self.List_C = np.array(\r\n            [[1, 1, 1, 1, 0],  # PC -> PC,PV,SST,VIP ,RLN  affinits de connexion entre cellules\r\n             [1, 1, 0, 0, 0],  # PV -> PC,PV,SST,VIP ,RLN\r\n             [1, 1, 0, 1, 1],  # SST -> PC,PV,SST,VIP ,RLN\r\n             [0, 0, 1, 0, 0],   #VIP --> PC,PV,SST,VIP ,RLN\r\n             [1, 1, 1, 1, 1]    #RLN --> PC,PV,SST,VIP ,RLN\r\n             ], dtype=np.float)\r\n        # self.inputNB=int(np.sum(self.Layer_nbCells)/20) ## /2 fro realistic purpose and /10 for repetitive connections see Denoyer et al. 2020\r\n        self.update_inputNB()\r\n        df = pd.read_excel('afferences.xlsx',engine='openpyxl')\r\n        self.Afferences = df.to_numpy()\r\n        self.update_connections(self.Afferences)\r\n        # self.inputpercent=df.to_numpy()*self.inputNB/100\r\n        #print(self.inputpercent)\r\n        self.Allconnexions=[]\r\n\r\n        # Sim param\r\n        self.Fs = 50\r\n        self.tps_start = 0\r\n        self.T = 200 #simduration\r\n        self.dt = 1 / self.Fs\r\n        self.nbEch = int(self.T / self.dt)\r\n        self.Stim_InputSignals  = []\r\n        self.Stim_Signals  = []\r\n\r\n        self.ImReady = False\r\n        self.seed = 0\r\n\r\n        self.tanpix40p180 = math.tan(40 * math.pi / 180)\r\n        self.tanpix50p180 = math.tan(50 * math.pi / 180)\r\n\r\n        self.List_Lambda_s= np.array(\r\n            [[0.032, 0, 0, -0.032, 0],  # layer II/III-> TPC,UPC,IPC,BPC,SSC\r\n             [0.048, 0.048, 0, 0, -0.012],  # layer IV-> TPC,UPC,IPC,BPC,SSC\r\n             [0.137, 0.048, 0, 0, 0],  # layer V-> TPC,UPC,IPC,BPC,SSC\r\n             [0.117, 0, -0.104,0.024, 0]  # layer VI-> TPC,UPC,IPC,BPC,SSC\r\n             ], dtype=np.float)\r\n\r\n        self.List_Lambda_d= np.array(\r\n            [[-0.120, 0, 0,0.120, 0],  # layer II/III-> TPC,UPC,IPC,BPC,SSC\r\n             [-0.095, -0.095, 0, 0, 0],  # layer IV-> TPC,UPC,IPC,BPC,SSC\r\n             [-0.071, -0.076, 0, 0, 0],  # layer V-> TPC,UPC,IPC,BPC,SSC\r\n             [-0.046, 0, 0.047,0.019, 0]  # layer VI-> TPC,UPC,IPC,BPC,SSC\r\n             ], dtype=np.float)\r\n\r\n\r\n    def update_samples(self,Fs,T):\r\n        self.Fs = Fs\r\n        self.T = T\r\n        self.dt = 1 / self.Fs\r\n        self.nbEch = int(self.T / self.dt)\r\n\r\n    def updateTissue(self, D, L , C, Layer_d):\r\n        self.D = D\r\n        self.L = L\r\n        self.C = C\r\n        self.Layer_d = Layer_d\r\n\r\n    def update_cellNumber(self,Layer_nbCells,\r\n                             PYRpercent,\r\n                             PVpercent,\r\n                             SSTpercent,\r\n                             VIPpercent,\r\n                             RLNpercent,\r\n\r\n                            PCsubtypes_Per = None,\r\n                            NB_PYR=None,\r\n                            NB_PV_BC=None,\r\n                            NB_PV_ChC=None,\r\n                            NB_IN = None,\r\n                            NB_PV = None,\r\n                            NB_SST = None,\r\n                            NB_VIP = None,\r\n                            NB_RLN = None  ):\r\n\r\n        self.Layer_nbCells = Layer_nbCells  # total number of cells/neocortical column for each layer (L1-L2/3-L4-L5-L6)\r\n\r\n        self.Nbcells = int(np.sum(self.Layer_nbCells))\r\n        self.PYRpercent = PYRpercent\r\n        self.INpercent = 1 - self.PYRpercent\r\n        self.PVpercent = PVpercent\r\n        self.SSTpercent = SSTpercent\r\n        self.VIPpercent = VIPpercent\r\n        self.RLNpercent = RLNpercent\r\n\r\n        if NB_PYR is None:\r\n            NB_PYR = self.PYRpercent * self.Layer_nbCells\r\n            self.NB_PYR = NB_PYR.astype(int)\r\n            print('PYR', self.NB_PYR)\r\n        else:\r\n            self.NB_PYR = NB_PYR\r\n        # subtypes of PYR cells\r\n        if PCsubtypes_Per is None:\r\n            self.PCsubtypes_Per = np.array([[0, 0, 0, 0, 0],\r\n                                            [0.9 * self.NB_PYR[1], 0, 0.1 * self.NB_PYR[1], 0, 0],\r\n                                            [0.5 * self.NB_PYR[2], 0.36 * self.NB_PYR[2], 0, 0, 0.14 * self.NB_PYR[2]],\r\n                                            [self.NB_PYR[3] * 0.81, self.NB_PYR[3] * 0.19, 0, 0, 0],\r\n                                            [self.NB_PYR[4] * 0.39, self.NB_PYR[4] * 0.17, self.NB_PYR[4] * 0.20,self.NB_PYR[4] * 0.24, 0]])  # TPC,UPC,IPC,BPC,SSC\r\n            print(self.PCsubtypes_Per)\r\n        else:\r\n            self.PCsubtypes_Per = PCsubtypes_Per\r\n\r\n        if NB_IN is None:\r\n            NB_IN = self.INpercent * self.Layer_nbCells\r\n            self.NB_IN = NB_IN.astype(int)\r\n            print('IN', self.NB_IN)\r\n        else:\r\n            self.NB_IN = NB_IN\r\n        if NB_PV is None:\r\n            NB_PV = self.PVpercent * self.NB_IN\r\n            self.NB_PV = NB_PV.astype(int)\r\n            print('PV', self.NB_PV)\r\n        else:\r\n            self.NB_PV = NB_PV\r\n        if NB_PV_BC is None:\r\n            NB_PV_BC = 0.7 * self.NB_PV\r\n            self.NB_PV_BC = NB_PV_BC.astype(int)\r\n        else:\r\n            self.NB_PV_BC = NB_PV_BC\r\n        if NB_PV_ChC is None:\r\n            NB_PV_BC = 0.7 * self.NB_PV\r\n            self.NB_PV_ChC = self.NB_PV - NB_PV_BC\r\n        else:\r\n            self.NB_PV_BC = NB_PV_BC\r\n\r\n        if NB_SST is None:\r\n            NB_SST = self.SSTpercent * self.NB_IN\r\n            self.NB_SST = NB_SST.astype(int)\r\n            print('SST', self.NB_SST)\r\n        else:\r\n            self.NB_SST = NB_SST\r\n        if NB_VIP is None:\r\n            NB_VIP = self.VIPpercent * self.NB_IN\r\n            self.NB_VIP = NB_VIP.astype(int)\r\n            print('VIP', self.NB_VIP)\r\n        else:\r\n            self.NB_VIP = NB_VIP\r\n        if NB_RLN is None:\r\n            NB_RLN = self.RLNpercent * self.NB_IN\r\n            self.NB_RLN = NB_RLN.astype(int)\r\n            print('RLN', self.NB_RLN)\r\n        else:\r\n            self.NB_RLN = NB_RLN\r\n        # mini_Layer_nbcells = Layer_nbCells / 310\r\n        self.Layer_nbCells = self.NB_PYR + self.NB_SST + self.NB_PV + self.NB_VIP + self.NB_RLN  # total number of cells/neocortical column for each layer (L1-L2/3-L4-L5-L6)\r\n        print(self.Layer_nbCells)\r\n        #####External afferences\r\n        self.NB_DPYR = int(np.sum(self.NB_PYR) * 0.07)\r\n        self.NB_Th = int(np.sum(self.NB_PYR) * 0.07)\r\n        self.List_celltypes = np.array([np.array([0]*self.NB_PYR[l] + [1]*self.NB_PV[l] + [2]*self.NB_SST[l] + [3]*self.NB_VIP[l] + [4]*self.NB_RLN[l]).astype(int) for l in range(len(self.Layer_nbCells))])\r\n        self.List_C = np.array(\r\n            [[1, 1, 1, 1, 0],  # PC -> PC,PV,SST,VIP ,RLN  affinits de connexion entre cellules\r\n             [1, 1, 0, 0, 0],  # PV -> PC,PV,SST,VIP ,RLN\r\n             [1, 1, 0, 1, 1],  # SST -> PC,PV,SST,VIP ,RLN\r\n             [0, 0, 1, 0, 0],  # VIP --> PC,PV,SST,VIP ,RLN\r\n             [1, 1, 1, 1, 1]  # RLN --> PC,PV,SST,VIP ,RLN\r\n             ], dtype=np.float)\r\n        # self.inputNB = int(np.sum(\r\n        #     self.Layer_nbCells) / 20)  ## /2 fro realistic purpose and /10 for repetitive connections see Denoyer et al. 2020\r\n        self.update_inputNB()\r\n        self.ImReady = False\r\n        self.List_Lambda_s = np.array(\r\n            [[0.032, 0, 0, -0.032, 0],  # layer II/III-> TPC,UPC,IPC,BPC,SSC\r\n             [0.048, 0.048, 0, 0, -0.012],  # layer IV-> TPC,UPC,IPC,BPC,SSC\r\n             [0.137, 0.048, 0, 0, 0],  # layer V-> TPC,UPC,IPC,BPC,SSC\r\n             [0.117, 0, -0.104, 0.024, 0]  # layer VI-> TPC,UPC,IPC,BPC,SSC\r\n             ], dtype=np.float)\r\n\r\n        self.List_Lambda_d = np.array(\r\n            [[-0.120, 0, 0, 0.120, 0],  # layer II/III-> TPC,UPC,IPC,BPC,SSC\r\n             [-0.095, -0.095, 0, 0, 0],  # layer IV-> TPC,UPC,IPC,BPC,SSC\r\n             [-0.071, -0.076, 0, 0, 0],  # layer V-> TPC,UPC,IPC,BPC,SSC\r\n             [-0.046, 0, 0.047, 0.019, 0]  # layer VI-> TPC,UPC,IPC,BPC,SSC\r\n             ], dtype=np.float)\r\n\r\n    def update_inputNB(self):\r\n            self.inputNB = int(np.sum(self.Layer_nbCells) / 20)\r\n    def update_connections(self,matrice, fixed = False):\r\n        self.Afferences = matrice\r\n        if fixed:\r\n            self.inputpercent = matrice.astype(int)\r\n        else:\r\n            self.inputpercent=(matrice*self.inputNB/100).astype(int)\r\n        self.Allconnexions=[]\r\n\r\n\r\n\r\n    def PlaceCell_func(self, type='Cylinder', seed = 0):\r\n        if not seed == 0:\r\n            np.random.seed(seed)\r\n        def pol2cart(rho, phi):\r\n            x = rho * np.cos(phi)\r\n            y = rho * np.sin(phi)\r\n            return (x, y)\r\n\r\n        def polar2cart3D(r, theta, phi):\r\n            return [\r\n                r * math.sin(theta) * math.cos(phi),\r\n                r * math.sin(theta) * math.sin(phi),\r\n                r * math.cos(theta)\r\n            ]\r\n\r\n        def asCartesian(r, theta, phi):\r\n            x = r * np.sin(theta) * np.cos(phi)\r\n            y = r * np.sin(theta) * np.sin(phi)\r\n            z = r * np.cos(theta)\r\n            return [x, y, z]\r\n        # self.updateCell.something_happened.emit(-2)\r\n        Cellpositionall=[]\r\n        L=self.L\r\n        Layer_d_cumsum = np.cumsum(self.Layer_d)\r\n        Layer_d_cumsum = np.hstack((0,Layer_d_cumsum))\r\n        print('Place cells....')\r\n        if type == 'Cylinder':\r\n            for l in range(len(self.Layer_nbCells)):\r\n                CellPosition=[]\r\n                PYRCellPosition=[]\r\n                IntCellPosition=[]\r\n                # x0 =float(np.random.uniform(low=-210, high=210, size=1))\r\n                # # y=np.sqrt(np.abs(210**2-x**2))*(-1)**random.randint(1, 2)\r\n                # CellPosition.append(np.array([val for val in [x0,float(np.random.uniform(low=-np.sqrt(np.abs(210**2-x0**2)), high=np.sqrt(np.abs(210**2-x0**2)), size=1)),float(np.random.uniform(low=L-np.sum(self.Layer_d[0:l+1]), high=L-np.sum(self.Layer_d[0:l]), size=1))]]))\r\n                module = float(np.random.uniform(low=0, high=1, size=1))\r\n                phi = float(np.random.uniform(low=0, high=2*np.pi, size=1))\r\n                x0, y0 = pol2cart(module*self.D/2, phi)\r\n                z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l+1], size=1))\r\n                CellPosition.append(np.array([x0,y0,z0]))\r\n                # print(CellPosition)\r\n                for nb in range(int(self.Layer_nbCells[l])-1):\r\n                    # x = np.array([np.random.uniform(low=-210, high=210, size=1) for fd in range(20)])\r\n                    # # print(x)\r\n                    #\r\n                    # candidate=np.array([np.array([val for val in [xx[0],float(np.random.uniform(low=-np.sqrt(np.abs(210**2-xx**2)), high=np.sqrt(np.abs(210**2-xx**2)), size=1)),\r\n                    #                            float(np.random.uniform(low=L-np.sum(self.Layer_d[0:l+1]), high=L-np.sum(self.Layer_d[0:l]), size=1))]]) for xx in x])\r\n                    candidate=[]\r\n                    for k_i in range(20):\r\n                        module = float(np.random.uniform(low=0, high=1, size=1))\r\n                        phi = float(np.random.uniform(low=0, high=2 * np.pi, size=1))\r\n                        x0, y0 = pol2cart(module*self.D/2, phi)\r\n                        z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l + 1], size=1))\r\n                        candidate.append(np.array([x0, y0, z0]))\r\n                    candidate = np.array(candidate)\r\n\r\n                    # print(candidate)\r\n                    CellDistances = distance.cdist(CellPosition, candidate, 'euclidean')\r\n                    # print(CellDistances)\r\n                    argmin = np.argmin(CellDistances, axis=0)\r\n                    valmin = [CellDistances[k, j] for j, k in enumerate(argmin)]\r\n                    argmax = np.argmax(valmin)\r\n                    CellPosition.append(candidate[argmax, :])\r\n                    if nb<self.NB_PYR[l]-1:\r\n                        PYRCellPosition.append(candidate[argmax, :])\r\n                    else:\r\n                        IntCellPosition.append(candidate[argmax, :])\r\n                CellPosition=np.array(CellPosition)\r\n                marange = np.arange(CellPosition.shape[0])\r\n                np.random.shuffle(marange)\r\n                CellPosition2 = CellPosition[marange]\r\n                # fig = plt.figure()\r\n                # ax = fig.add_subplot(111, projection='3d')\r\n                # plt.plot(CellPosition[:,0],CellPosition[:,1],CellPosition[:,2],'X')\r\n                # plt.show()\r\n                Cellpositionall.append(CellPosition2)\r\n        elif type == 'Cylinder with curvature':\r\n            CurvatureD = self.C\r\n            for l in range(len(self.Layer_nbCells)):\r\n                CellPosition=[]\r\n                PYRCellPosition=[]\r\n                IntCellPosition=[]\r\n                # x0 =float(np.random.uniform(low=-210, high=210, size=1))\r\n                # # y=np.sqrt(np.abs(210**2-x**2))*(-1)**random.randint(1, 2)\r\n                # CellPosition.append(np.array([val for val in [x0,float(np.random.uniform(low=-np.sqrt(np.abs(210**2-x0**2)), high=np.sqrt(np.abs(210**2-x0**2)), size=1)),float(np.random.uniform(low=L-np.sum(self.Layer_d[0:l+1]), high=L-np.sum(self.Layer_d[0:l]), size=1))]]))\r\n                module = float(np.random.uniform(low=0, high=1, size=1))\r\n                phi = float(np.random.uniform(low=0, high=2*np.pi, size=1))\r\n                x0, y0 = pol2cart(module*self.D/2, phi)\r\n\r\n                zL = CurvatureD + L\r\n                c = np.sqrt(x0 * x0 + y0 * y0)\r\n                thetaX= np.arctan(x0/zL)\r\n                thetaY= np.arctan(y0/zL)\r\n\r\n                zmin = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l+1]\r\n                zmax = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]\r\n                module = float(np.random.uniform(low=zmin, high=zmax, size=1))\r\n                # phi1 = float(np.random.uniform(low=-thetamin, high=thetamin, size=1))\r\n                # phi2 = float(np.random.uniform(low=-thetamin, high=thetamin, size=1))\r\n\r\n                x0, y0, z0 = asCartesian(module, thetaX, float(np.random.uniform(low=0, high=2*np.pi, size=1)))\r\n                z0 = z0 - CurvatureD\r\n                # z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l+1], size=1))\r\n\r\n\r\n\r\n                # thetamax = np.arctan(c/zmax)\r\n                #\r\n                # Zmin = (CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l+1]) * np.cos(thetamin)\r\n                # Zmax = (CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]) * np.cos(thetamax)\r\n                #\r\n                # z0 = float(np.random.uniform(low=Zmin-CurvatureD, high=Zmax-CurvatureD, size=1))\r\n\r\n\r\n                # good = True\r\n                # while good:\r\n                #     z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l+1], size=1))\r\n                #     d = np.linalg.norm(np.array([x0,y0,z0])-np.array([0,0,-CurvatureD]))\r\n                #     print(d, CurvatureD + L - Layer_d_cumsum[l], L - Layer_d_cumsum[l + 1])\r\n                #     if d <= CurvatureD + L - Layer_d_cumsum[l] and d >= L - Layer_d_cumsum[l + 1]:\r\n                #         good = False\r\n                CellPosition.append(np.array([x0,y0,z0]))\r\n                # print(CellPosition)\r\n                for nb in range(int(self.Layer_nbCells[l])-1):\r\n                    # x = np.array([np.random.uniform(low=-210, high=210, size=1) for fd in range(20)])\r\n                    # # print(x)\r\n                    #\r\n                    # candidate=np.array([np.array([val for val in [xx[0],float(np.random.uniform(low=-np.sqrt(np.abs(210**2-xx**2)), high=np.sqrt(np.abs(210**2-xx**2)), size=1)),\r\n                    #                            float(np.random.uniform(low=L-np.sum(self.Layer_d[0:l+1]), high=L-np.sum(self.Layer_d[0:l]), size=1))]]) for xx in x])\r\n                    candidate=[]\r\n                    for k_i in range(20):\r\n                        module = float(np.random.uniform(low=0, high=1, size=1))\r\n                        phi = float(np.random.uniform(low=0, high=2 * np.pi, size=1))\r\n                        x0, y0 = pol2cart(module * self.D / 2, phi)\r\n\r\n                        zL = CurvatureD + L\r\n                        c = np.sqrt(x0 * x0 + y0 * y0)\r\n                        thetaX = np.arctan(x0 / zL)\r\n                        thetaY = np.arctan(y0 / zL)\r\n\r\n                        zmin = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l + 1]\r\n                        zmax = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]\r\n                        module = float(np.random.uniform(low=zmin, high=zmax, size=1))\r\n                        # phi1 = float(np.random.uniform(low=-thetamin, high=thetamin, size=1))\r\n                        # phi2 = float(np.random.uniform(low=-thetamin, high=thetamin, size=1))\r\n\r\n                        x0, y0, z0 = asCartesian(module, thetaX, float(np.random.uniform(low=0, high=2*np.pi, size=1)))\r\n                        z0 = z0 - CurvatureD\r\n\r\n                        # good = True\r\n                        #\r\n                        # while good:\r\n                        #     z0 = float(\r\n                        #         np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l + 1], size=1))\r\n                        #     d = np.linalg.norm(\r\n                        #         np.array([x0, y0, z0]) - np.array([0, 0, -CurvatureD ]))\r\n                        #     # print(d,CurvatureD + L - Layer_d_cumsum[l],L - Layer_d_cumsum[l + 1])\r\n                        #     if d <= CurvatureD + L - Layer_d_cumsum[l]  and d >= L - Layer_d_cumsum[l + 1]:\r\n                        #         good = False\r\n                        # z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l + 1], size=1))\r\n                        candidate.append(np.array([x0, y0, z0]))\r\n                    candidate = np.array(candidate)\r\n\r\n                    # print(candidate)\r\n                    CellDistances = distance.cdist(CellPosition, candidate, 'euclidean')\r\n                    # print(CellDistances)\r\n                    argmin = np.argmin(CellDistances, axis=0)\r\n                    valmin = [CellDistances[k, j] for j, k in enumerate(argmin)]\r\n                    argmax = np.argmax(valmin)\r\n                    CellPosition.append(candidate[argmax, :])\r\n                    if nb<self.NB_PYR[l]-1:\r\n                        PYRCellPosition.append(candidate[argmax, :])\r\n                    else:\r\n                        IntCellPosition.append(candidate[argmax, :])\r\n                CellPosition=np.array(CellPosition)\r\n                marange = np.arange(CellPosition.shape[0])\r\n                np.random.shuffle(marange)\r\n                CellPosition2 = CellPosition[marange]\r\n                # fig = plt.figure()\r\n                # ax = fig.add_subplot(111, projection='3d')\r\n                # plt.plot(CellPosition[:,0],CellPosition[:,1],CellPosition[:,2],'X')\r\n                # plt.show()\r\n                Cellpositionall.append(CellPosition2)\r\n        elif type == 'Square':\r\n            for l in range(len(self.Layer_nbCells)):\r\n                CellPosition=[]\r\n                PYRCellPosition=[]\r\n                IntCellPosition=[]\r\n\r\n                # phi = float(np.random.uniform(low=0, high=2*np.pi, size=1))\r\n                x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                y0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l+1], size=1))\r\n                CellPosition.append(np.array([x0,y0,z0]))\r\n                for nb in range(int(self.Layer_nbCells[l])-1):\r\n                    candidate=[]\r\n                    for k_i in range(20):\r\n                        module = float(np.random.uniform(low=0, high=1, size=1))\r\n                        phi = float(np.random.uniform(low=0, high=2 * np.pi, size=1))\r\n\r\n                        x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                        y0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                        z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l + 1], size=1))\r\n                        candidate.append(np.array([x0, y0, z0]))\r\n                    candidate = np.array(candidate)\r\n\r\n                    # print(candidate)\r\n                    CellDistances = distance.cdist(CellPosition, candidate, 'euclidean')\r\n                    # print(CellDistances)\r\n                    argmin = np.argmin(CellDistances, axis=0)\r\n                    valmin = [CellDistances[k, j] for j, k in enumerate(argmin)]\r\n                    argmax = np.argmax(valmin)\r\n                    CellPosition.append(candidate[argmax, :])\r\n                    if nb<self.NB_PYR[l]-1:\r\n                        PYRCellPosition.append(candidate[argmax, :])\r\n                    else:\r\n                        IntCellPosition.append(candidate[argmax, :])\r\n                CellPosition=np.array(CellPosition)\r\n                marange = np.arange(CellPosition.shape[0])\r\n                np.random.shuffle(marange)\r\n                CellPosition2 = CellPosition[marange]\r\n                # fig = plt.figure()\r\n                # ax = fig.add_subplot(111, projection='3d')\r\n                # plt.plot(CellPosition[:,0],CellPosition[:,1],CellPosition[:,2],'X')\r\n                # plt.show()\r\n                Cellpositionall.append(CellPosition2)\r\n        elif type == 'Square with curvature':\r\n\r\n            CurvatureD = self.C\r\n            for l in range(len(self.Layer_nbCells)):\r\n                CellPosition=[]\r\n                PYRCellPosition=[]\r\n                IntCellPosition=[]\r\n\r\n                # phi = float(np.random.uniform(low=0, high=2*np.pi, size=1))\r\n                x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                y0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n\r\n                # zL = CurvatureD + L\r\n                zmin = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l+1]\r\n                zmax = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]\r\n                c = np.sqrt(x0 * x0 + y0 * y0)\r\n                thetamin = np.arctan(c/zmin)\r\n                thetamax = np.arctan(c/zmax)\r\n\r\n                Zmin = (CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l+1]) * np.cos(thetamin)\r\n                Zmax = (CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]) * np.cos(thetamax)\r\n\r\n                z0 = float(np.random.uniform(low=Zmin-CurvatureD, high=Zmax-CurvatureD, size=1))\r\n                CellPosition.append(np.array([x0,y0,z0]))\r\n                for nb in range(int(self.Layer_nbCells[l])-1):\r\n                    candidate=[]\r\n                    for k_i in range(20):\r\n                        module = float(np.random.uniform(low=0, high=1, size=1))\r\n                        phi = float(np.random.uniform(low=0, high=2 * np.pi, size=1))\r\n\r\n                        x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                        y0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                        # zL = CurvatureD + L\r\n                        zmin = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l + 1]\r\n                        zmax = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]\r\n                        c = np.sqrt(x0 * x0 + y0 * y0)\r\n                        thetamin = np.arctan(c / zmin)\r\n                        thetamax = np.arctan(c / zmax)\r\n\r\n                        Zmin = (CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l + 1]) * np.cos(thetamin)\r\n                        Zmax = (CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]) * np.cos(thetamax)\r\n\r\n                        z0 = float(np.random.uniform(low=Zmin - CurvatureD, high=Zmax - CurvatureD, size=1))\r\n                        candidate.append(np.array([x0, y0, z0]))\r\n                    candidate = np.array(candidate)\r\n\r\n                    # print(candidate)\r\n                    CellDistances = distance.cdist(CellPosition, candidate, 'euclidean')\r\n                    # print(CellDistances)\r\n                    argmin = np.argmin(CellDistances, axis=0)\r\n                    valmin = [CellDistances[k, j] for j, k in enumerate(argmin)]\r\n                    argmax = np.argmax(valmin)\r\n                    CellPosition.append(candidate[argmax, :])\r\n                    if nb<self.NB_PYR[l]-1:\r\n                        PYRCellPosition.append(candidate[argmax, :])\r\n                    else:\r\n                        IntCellPosition.append(candidate[argmax, :])\r\n                CellPosition=np.array(CellPosition)\r\n                marange = np.arange(CellPosition.shape[0])\r\n                np.random.shuffle(marange)\r\n                CellPosition2 = CellPosition[marange]\r\n                # fig = plt.figure()\r\n                # ax = fig.add_subplot(111, projection='3d')\r\n                # plt.plot(CellPosition[:,0],CellPosition[:,1],CellPosition[:,2],'X')\r\n                # plt.show()\r\n                Cellpositionall.append(CellPosition2)\r\n\r\n        elif type == 'Rectange':\r\n            for l in range(len(self.Layer_nbCells)):\r\n                CellPosition=[]\r\n                PYRCellPosition=[]\r\n                IntCellPosition=[]\r\n\r\n                # phi = float(np.random.uniform(low=0, high=2*np.pi, size=1))\r\n                x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                y0 = float(np.random.uniform(low=-self.L/2, high=self.L/2, size=1))\r\n                z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l+1], size=1))\r\n                CellPosition.append(np.array([x0,y0,z0]))\r\n                for nb in range(int(self.Layer_nbCells[l])-1):\r\n                    candidate=[]\r\n                    for k_i in range(20):\r\n                        module = float(np.random.uniform(low=0, high=1, size=1))\r\n                        phi = float(np.random.uniform(low=0, high=2 * np.pi, size=1))\r\n\r\n                        x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                        y0 = float(np.random.uniform(low=-self.L/2, high=self.L/2, size=1))\r\n                        z0 = float(np.random.uniform(low=L - Layer_d_cumsum[l], high=L - Layer_d_cumsum[l + 1], size=1))\r\n                        candidate.append(np.array([x0, y0, z0]))\r\n                    candidate = np.array(candidate)\r\n\r\n                    # print(candidate)\r\n                    CellDistances = distance.cdist(CellPosition, candidate, 'euclidean')\r\n                    # print(CellDistances)\r\n                    argmin = np.argmin(CellDistances, axis=0)\r\n                    valmin = [CellDistances[k, j] for j, k in enumerate(argmin)]\r\n                    argmax = np.argmax(valmin)\r\n                    CellPosition.append(candidate[argmax, :])\r\n                    if nb<self.NB_PYR[l]-1:\r\n                        PYRCellPosition.append(candidate[argmax, :])\r\n                    else:\r\n                        IntCellPosition.append(candidate[argmax, :])\r\n                CellPosition=np.array(CellPosition)\r\n                marange = np.arange(CellPosition.shape[0])\r\n                np.random.shuffle(marange)\r\n                CellPosition2 = CellPosition[marange]\r\n                # fig = plt.figure()\r\n                # ax = fig.add_subplot(111, projection='3d')\r\n                # plt.plot(CellPosition[:,0],CellPosition[:,1],CellPosition[:,2],'X')\r\n                # plt.show()\r\n                Cellpositionall.append(CellPosition2)\r\n        elif type == 'Rectange with curvature':\r\n\r\n            CurvatureD = self.C\r\n            for l in range(len(self.Layer_nbCells)):\r\n                CellPosition=[]\r\n                PYRCellPosition=[]\r\n                IntCellPosition=[]\r\n\r\n                # phi = float(np.random.uniform(low=0, high=2*np.pi, size=1))\r\n                x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                y0 = float(np.random.uniform(low=-self.L/2, high=self.L/2, size=1))\r\n                # zL = CurvatureD + L\r\n                zmin = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l+1]\r\n                zmax = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]\r\n                c = np.sqrt(x0 * x0 + y0 * y0)\r\n                thetamin = np.arctan(c/zmin)\r\n                thetamax = np.arctan(c/zmax)\r\n\r\n                Zmin = (zmin) * np.cos(thetamin)\r\n                Zmax = (zmax) * np.cos(thetamax)\r\n\r\n                z0 = float(np.random.uniform(low=Zmin-CurvatureD, high=Zmax-CurvatureD, size=1))\r\n\r\n                CellPosition.append(np.array([x0,y0,z0]))\r\n                for nb in range(int(self.Layer_nbCells[l])-1):\r\n                    candidate=[]\r\n                    for k_i in range(20):\r\n                        module = float(np.random.uniform(low=0, high=1, size=1))\r\n                        phi = float(np.random.uniform(low=0, high=2 * np.pi, size=1))\r\n\r\n                        x0 = float(np.random.uniform(low=-self.D/2, high=self.D/2, size=1))\r\n                        y0 = float(np.random.uniform(low=-self.L/2, high=self.L/2, size=1))\r\n\r\n                        # zL = CurvatureD + L\r\n                        zmin = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l + 1]\r\n                        zmax = CurvatureD + Layer_d_cumsum[-1] - Layer_d_cumsum[l]\r\n                        c = np.sqrt(x0 * x0 + y0 * y0)\r\n                        thetamin = np.arctan(c / zmin)\r\n                        thetamax = np.arctan(c / zmax)\r\n\r\n                        Zmin = (zmin) * np.cos(thetamin)\r\n                        Zmax = (zmax) * np.cos(thetamax)\r\n\r\n                        z0 = float(np.random.uniform(low=Zmin - CurvatureD, high=Zmax - CurvatureD, size=1))\r\n                        candidate.append(np.array([x0, y0, z0]))\r\n                    candidate = np.array(candidate)\r\n\r\n                    # print(candidate)\r\n                    CellDistances = distance.cdist(CellPosition, candidate, 'euclidean')\r\n                    # print(CellDistances)\r\n                    argmin = np.argmin(CellDistances, axis=0)\r\n                    valmin = [CellDistances[k, j] for j, k in enumerate(argmin)]\r\n                    argmax = np.argmax(valmin)\r\n                    CellPosition.append(candidate[argmax, :])\r\n                    if nb<self.NB_PYR[l]-1:\r\n                        PYRCellPosition.append(candidate[argmax, :])\r\n                    else:\r\n                        IntCellPosition.append(candidate[argmax, :])\r\n                CellPosition=np.array(CellPosition)\r\n                marange = np.arange(CellPosition.shape[0])\r\n                np.random.shuffle(marange)\r\n                CellPosition2 = CellPosition[marange]\r\n                # fig = plt.figure()\r\n                # ax = fig.add_subplot(111, projection='3d')\r\n                # plt.plot(CellPosition[:,0],CellPosition[:,1],CellPosition[:,2],'X')\r\n                # plt.show()\r\n                Cellpositionall.append(CellPosition2)\r\n        self.Cellpos=np.array(Cellpositionall)\r\n        self.Cellposflat=np.vstack((self.Cellpos[0], self.Cellpos[1], self.Cellpos[2], self.Cellpos[3], self.Cellpos[4]))\r\n        return self.Cellpos\r\n\r\n    def createFlatCEllpos(self):\r\n        self.Cellposflat=np.vstack((self.Cellpos[0], self.Cellpos[1], self.Cellpos[2], self.Cellpos[3], self.Cellpos[4]))\r\n\r\n\r\n    def Create_Connectivity_Matrix(self,seed = 0):\r\n        if not seed == 0:\r\n            np.random.seed(seed)\r\n        self.createFlatCEllpos()\r\n        print('Create_Connectivity_Matrices........')\r\n        connectivitymatrix = []\r\n        connectivityweight = []\r\n        connectivityZpos = []\r\n        self.PreSynaptic_Cell_AMPA = []\r\n        self.PreSynaptic_Cell_GABA = []\r\n        self.PreSynaptic_Soma_AMPA = []\r\n        self.PreSynaptic_Soma_GABA_d = []\r\n        self.PreSynaptic_Soma_GABA_s = []\r\n        self.PreSynaptic_Soma_GABA_a = []\r\n        self.ExternalPreSynaptic_Cell_AMPA_DPYR = []\r\n        self.ExternalPreSynaptic_Cell_AMPA_Th= []\r\n        self.PreSynapticWeight_AMPA=[]\r\n        self.PreSynapticWeight_GABA=[]\r\n        self.PreSynapticPos_AMPA=[]\r\n        self.PreSynapticPos_GABA=[]\r\n\r\n\r\n        target = Cell_morphology.Neuron(0,1,0)\r\n        Neighbor = Cell_morphology.Neuron(0,1,0)\r\n        nbcells = np.sum(self.Layer_nbCells)\r\n        nbcellscum = np.cumsum(self.Layer_nbCells)\r\n        nbcellscum = np.append(0,nbcellscum)\r\n\r\n        PCsubtypes_Per = np.cumsum(self.PCsubtypes_Per,axis=1)\r\n        indexval = -1\r\n\r\n        cm = np.zeros(nbcells, dtype=int)  # []\r\n        dist = np.zeros(nbcells, dtype=float)  # []\r\n        Weight = np.zeros(nbcells, dtype=float)  # []\r\n        Zpos = np.zeros(nbcells, dtype=float)  # []\r\n\r\n        AMPAcells = np.zeros(nbcells, dtype=int) - 1  # []\r\n        GABAcells = np.zeros(nbcells, dtype=int) - 1  # []\r\n\r\n        Layer_nbCells = np.cumsum(np.hstack((0,self.Layer_nbCells)))\r\n        self.List_cellsubtypes = copy.deepcopy(self.List_celltypes)\r\n        for l in range(len(self.Layer_nbCells)):\r\n            for cell in range(int(self.Layer_nbCells[l])):\r\n                if np.mod(cell,20) == 0:\r\n                    print('cell', cell)\r\n                # if indexval ==80:\r\n                #     a=1\r\n                # self.updateCell.something_happened.emit(indexval)\r\n                indexval +=1\r\n                cm = cm*0\r\n                dist = dist *0\r\n                Weight = Weight*0\r\n                Zpos=Zpos*0 # The Z position of the synaptic connexion (Zpos=0 no connection, Zpos=-1 ==> not enough cells connected)\r\n\r\n                AMPAcells = AMPAcells*0-1\r\n                AMPAcells_sparse = []\r\n                Weight_AMPA=[]\r\n                Pos_AMPA=[]\r\n                GABAcells=GABAcells*0-1#[]\r\n                GABAcells_sparse = []\r\n                GABASoma=np.zeros(nbcells,dtype=str)#[]\r\n                GABASoma_d_sparse=[]\r\n                GABASoma_s_sparse=[]\r\n                GABASoma_a_sparse=[]\r\n                Weight_GABA = []\r\n                Pos_GABA=[]\r\n\r\n                subtype = []\r\n\r\n                #if Principal cell check subtypes\r\n                if (self.List_celltypes[l][cell] == 0):  # getsubtype\r\n                    if cell < PCsubtypes_Per[l][0]:\r\n                        subtype = 0  # TPC\r\n                    elif (cell >= PCsubtypes_Per[l][0]) and (cell < PCsubtypes_Per[l][1]):\r\n                        subtype = 1  # UPC\r\n                    elif (cell >= PCsubtypes_Per[l][1]) and (cell < PCsubtypes_Per[l][2]):\r\n                        subtype = 2  # IPC\r\n                    elif (cell >= PCsubtypes_Per[l][2]) and (cell < PCsubtypes_Per[l][3]):\r\n                        subtype = 3  # BPC\r\n                    elif (cell >= PCsubtypes_Per[l][3]) and (cell < PCsubtypes_Per[l][4]):\r\n                        subtype = 4  # SSC\r\n                    self.List_cellsubtypes[l][cell] = subtype\r\n\r\n                #if PV check is chandeliers or Basket\r\n                elif (self.List_celltypes[l][cell] == 1):  # PV get subtype\r\n                    if (cell - self.NB_PYR[l]) < self.NB_PV_BC[l]:\r\n                        subtype = 0  # BC\r\n                    else:\r\n                        subtype = 1  # Chandelier\r\n                    self.List_cellsubtypes[l][cell] = subtype\r\n                else:\r\n                    self.List_cellsubtypes[l][cell] = -1\r\n\r\n                target.update_type(type=self.List_celltypes[l][cell], layer=l, subtype=subtype)\r\n                index = 0\r\n\r\n                d = np.linalg.norm(self.Cellposflat[:,:2]  - self.Cellpos[l][cell][:2], axis=1)\r\n                indflat = -1\r\n                for subl in range(len(self.Layer_nbCells)):\r\n                    for v in range(0, int(self.Layer_nbCells[subl])):\r\n                        indflat += 1\r\n                        subtype = None\r\n\r\n                        if self.inputpercent[int(self.List_celltypes[subl][v] + 5 * subl), int(target.type + 5 * l)] == 0:\r\n                            cm[index] = 0\r\n                            Weight[index] = -1\r\n                            AMPAcells[index] = -1\r\n                            GABAcells[index] = -1\r\n                            GABASoma[index] = '0'\r\n                            Zpos[index] = 0\r\n\r\n\r\n                        else:\r\n                            #remove auto connections except for PV [Deleuze et al. 2019,plos Bio]\r\n                            if ((v == cell) and (subl == l) and (self.List_celltypes[l][cell] != 1)):\r\n                                    cm[index] = 0\r\n                                    Weight[index] = -1\r\n                                    AMPAcells[index] = -1\r\n                                    GABAcells[index] = -1\r\n                                    GABASoma[index] = '0'\r\n                                    Zpos[index] =0\r\n\r\n                            else:\r\n                                if (self.List_celltypes[subl][v] == 0):  # getsubtype\r\n                                    if v < PCsubtypes_Per[subl][0]:\r\n                                        subtype = 0  # TPC\r\n                                    elif (v >= PCsubtypes_Per[subl][0]) and (v < PCsubtypes_Per[subl][1]):\r\n                                        subtype = 1  # UPC\r\n                                    elif (v >= PCsubtypes_Per[subl][1]) and (v < PCsubtypes_Per[subl][2]):\r\n                                        subtype = 2  # IPC\r\n                                    elif (v >= PCsubtypes_Per[subl][2]) and (v < PCsubtypes_Per[subl][3]):\r\n                                        subtype = 3  # BPC\r\n                                    elif (v >= PCsubtypes_Per[subl][3]) and (v < PCsubtypes_Per[subl][4]):\r\n                                        subtype = 4  # SSC\r\n\r\n                                if (self.List_celltypes[subl][v] == 1):  # PV get subtype\r\n                                    if (v - self.NB_PYR[subl]) < self.NB_PV_BC[subl]:\r\n                                        subtype = 0  # BC\r\n                                    else:\r\n                                        subtype = 1  # Chandelier\r\n                                Neighbor.update_type(type=self.List_celltypes[subl][v], layer=subl,subtype=subtype)\r\n\r\n                                isconnected, overlap, ConnPos = self.IsConnected(Neighbor, self.Cellpos[subl][v], target,\r\n                                                                        self.Cellpos[l][cell],d[indflat]) #Neighbor to target)\r\n                                #find at which layer the dendritic connection is\r\n                                if ConnPos==0: #not connected\r\n                                    Layerconn=0\r\n                                else:\r\n                                    Layerconn=np.argwhere(np.sort(np.concatenate((self.Layertop_pos,np.array([ConnPos])),axis=0))==ConnPos) #1--> layer 6,5 layer I\r\n                                    Layerconn =Layerconn[0][0] + 1\r\n                                    if ConnPos < self.Cellpos[l][cell][2]: #if connection below soma center\r\n                                        Layerconn=-1*Layerconn\r\n\r\n\r\n\r\n\r\n                                if isconnected == 1:\r\n                                    cm[index] = 1\r\n                                    Weight[index] = overlap\r\n                                    Zpos[index] = Layerconn\r\n\r\n                                    ####Fill presynatptic cell\r\n                                    if Neighbor.type==0: #excitatory Input\r\n                                        AMPAcells[index] = v+np.sum(Layer_nbCells[subl])\r\n                                        GABAcells[index] = -1\r\n                                        GABASoma[index] = '0'\r\n                                    else:\r\n                                        #inhibitory input\r\n                                        GABAcells[index] = v+np.sum(Layer_nbCells[subl])\r\n                                        AMPAcells[index] = -1\r\n\r\n                                        if target.type in [0]:\r\n                                            if Neighbor.type == 1: #from, PV\r\n                                                if target.subtype == 0: #if from Basket cell\r\n                                                    GABASoma[index] = 's'\r\n                                                else: #if from chandelier cell\r\n                                                    GABASoma[index] = 'a'\r\n                                            else:\r\n                                                GABASoma[index] = 'd'\r\n                                        elif target.type in [1,2,3,4]:\r\n                                            GABASoma[index] = 's'\r\n                                else:\r\n                                    cm[index] = 0\r\n                                    Weight[index] = -1\r\n                                    AMPAcells[index] = -1\r\n                                    GABAcells[index] = -1\r\n                                    GABASoma[index] = '0'\r\n                                    Zpos[index] = 0\r\n\r\n\r\n                        index += 1\r\n                #####Check afferences:##############\r\n                Afferences=self.inputpercent[:,int(target.type+5*l)]\r\n\r\n                #getminweight\r\n                Weight2 = Weight[Weight > 0]\r\n                if Weight2.size == 0:\r\n                    weigthmini = 1\r\n                    print(weigthmini)\r\n                else:\r\n                    weigthmini = np.min(Weight2)\r\n\r\n\r\n                if np.sum(cm[0:self.NB_RLN[0]]) > Afferences[4]:\r\n                    NBrange = np.array(range(0, self.NB_RLN[0]))\r\n                    th = np.argsort([Weight[j] for j in np.array(NBrange)])[::-1]\r\n                    Weight[NBrange[th[int(Afferences[4]):]]]=0\r\n                    Zpos[NBrange[th[int(Afferences[4]):]]]=0\r\n                    cm[NBrange[th[int(Afferences[4]):]]]=0\r\n                    AMPAcells[NBrange[th[int(Afferences[4]):]]]=-1\r\n                    GABAcells[NBrange[th[int(Afferences[4]):]]]=-1\r\n                    GABASoma[NBrange[th[int(Afferences[4]):]]]='0'\r\n\r\n                elif np.sum(cm[0:self.NB_RLN[0]]) < Afferences[4]:\r\n                    nb = Afferences[4] - np.sum(cm[0:self.NB_RLN[0]])\r\n                    indice_ = np.random.randint(0, self.NB_RLN[0], size=nb)\r\n                    for ind in range(nb):\r\n                        pos = indice_[ind]\r\n                        if not pos ==indexval:\r\n                            Weight[pos]=weigthmini\r\n                            cm[pos]=1\r\n                            AMPAcells[pos]=-1\r\n                            GABAcells[pos]=pos\r\n                            GABASoma[pos]='s'\r\n                            Zpos[pos]= 5 #from layer 1\r\n\r\n\r\n                for ll in range(1,5):\r\n                    for type in range(5):\r\n                        if not int(Afferences[type+5*ll]) == 0:\r\n                            NBrange = []\r\n                            if type == 0:  # PC\r\n                                NBrange = np.array(range(nbcellscum[ll],nbcellscum[ll] + self.NB_PYR[ll]))\r\n                            elif type == 1:  # PV\r\n                                NBrange = np.array(range(nbcellscum[ll] + self.NB_PYR[ll],nbcellscum[ll] + self.NB_PYR[ll] +self.NB_PV[ll]))\r\n                            elif type == 2:  # SST\r\n                                NBrange = np.array(range(nbcellscum[ll] + self.NB_PYR[ll] + self.NB_PV[ll],nbcellscum[ll] + self.NB_PYR[ll] + self.NB_PV[ll] +self.NB_SST[ll]))\r\n                            elif type == 3:  # VIP\r\n                                NBrange = np.array(\r\n                                    range(nbcellscum[ll] + self.NB_PYR[ll] + self.NB_PV[ll] +self.NB_SST[ll],nbcellscum[ll] + self.NB_PYR[ll] + self.NB_PV[ll] +self.NB_SST[ll] +self.NB_VIP[ll]))\r\n                            elif type == 4:  # RLN\r\n                                NBrange = np.array(range(\r\n                                    nbcellscum[ll] + self.NB_PYR[ll] + self.NB_PV[ll] + self.NB_SST[ll] +self.NB_VIP[ll],nbcellscum[ll] + self.NB_PYR[ll] + self.NB_PV[ll] + self.NB_SST[ll] +\r\n                                    self.NB_VIP[ll] + self.NB_RLN[ll]))\r\n\r\n                            if len(NBrange)>0:\r\n                                somme_cm = np.sum(cm[NBrange])\r\n                                if somme_cm > int(Afferences[type+5*ll]): #np.sum([cm[j] for j in NBrange]) > int(Afferences[type+5*ll]):\r\n                                    th=np.argsort( Weight[NBrange])[::-1]\r\n                                    ind_th = NBrange[th[int(Afferences[type+5*ll]):]]\r\n                                    Weight[ind_th]=0\r\n                                    Zpos[ind_th]=0\r\n                                    cm[ind_th]=0\r\n                                    AMPAcells[ind_th]=-1\r\n                                    GABAcells[ind_th]=-1\r\n                                    GABASoma[ind_th]='0'\r\n\r\n                                elif somme_cm < int(Afferences[type+5*ll]):\r\n                                    # print('not enough)')\r\n                                    nb = int(Afferences[type+5*ll]) - somme_cm\r\n                                    indice_ = np.random.randint(0, len(NBrange), size=nb)\r\n                                    for ind in range(nb):\r\n                                        pos = NBrange[indice_[ind]]\r\n                                        if not pos == indexval:\r\n                                            cm[pos] = 1\r\n                                            Weight[pos]=weigthmini\r\n                                            Zpos[pos] =5-ll #add the layer of presynaptic cell\r\n                                            if type == 0:\r\n                                                AMPAcells[pos] = pos\r\n                                                GABAcells[pos] = -1\r\n                                                GABASoma[pos] = '0'\r\n                                            else:\r\n                                                GABAcells[pos] = pos\r\n                                                AMPAcells[pos] = -1\r\n                                                if target.type in [0]:\r\n                                                    if type == 1:\r\n                                                        if target.subtype == 0:\r\n                                                            GABASoma[pos] = 's'\r\n                                                        else:\r\n                                                            GABASoma[pos] = 'a'\r\n                                                    else:\r\n                                                        GABASoma[pos] = 'd'\r\n                                                elif target.type in [1, 2, 3, 4]:\r\n                                                    GABASoma[pos] = 's'\r\n\r\n\r\n                #create sparse arrays\r\n                for i in range(len(AMPAcells)):\r\n                    if AMPAcells[i]!=-1:\r\n                        AMPAcells_sparse.append(AMPAcells[i])\r\n                        Weight_AMPA.append(Weight[i])\r\n                        Pos_AMPA.append(Zpos[i])\r\n\r\n\r\n                        # AMPA_ProjVect.append(dist[i,:])\r\n                for i in range(len(GABAcells)):\r\n                    if GABAcells[i]!=-1:\r\n                        GABAcells_sparse.append(GABAcells[i])\r\n                        Weight_GABA.append(Weight[i])\r\n                        Pos_GABA.append(Zpos[i])\r\n\r\n                        # GABA_ProjVect.append(dist[i,:])\r\n                        if GABASoma[i]=='d':\r\n                            GABASoma_d_sparse.append(1) #1   for dent\r\n                            GABASoma_s_sparse.append(0) #1   for soma\r\n                            GABASoma_a_sparse.append(0) #1   for ais\r\n                        elif GABASoma[i]=='s':\r\n                            GABASoma_d_sparse.append(0) #1   for dent\r\n                            GABASoma_s_sparse.append(1) #1   for soma\r\n                            GABASoma_a_sparse.append(0) #1   for ais\r\n                        elif GABASoma[i]=='a':\r\n                            GABASoma_d_sparse.append(0) #1   for dent\r\n                            GABASoma_s_sparse.append(0) #1   for soma\r\n                            GABASoma_a_sparse.append(1) #1   for ais\r\n\r\n\r\n                self.PreSynaptic_Cell_AMPA.append(np.asarray(AMPAcells_sparse))\r\n                self.PreSynaptic_Cell_GABA.append(np.asarray(GABAcells_sparse))\r\n                self.PreSynaptic_Soma_AMPA.append(np.ones(len(AMPAcells_sparse),dtype=int))\r\n                self.PreSynaptic_Soma_GABA_d.append(np.asarray(GABASoma_d_sparse))\r\n                self.PreSynaptic_Soma_GABA_s.append(np.asarray(GABASoma_s_sparse))\r\n                self.PreSynaptic_Soma_GABA_a.append(np.asarray(GABASoma_a_sparse))\r\n                self.PreSynapticWeight_AMPA.append(np.asarray(Weight_AMPA))\r\n                self.PreSynapticWeight_GABA.append(np.asarray(Weight_GABA))\r\n                self.PreSynapticPos_AMPA.append(np.asarray(Pos_AMPA))\r\n                self.PreSynapticPos_GABA.append(np.asarray(Pos_GABA))\r\n\r\n                #connectivitymatrix.append(np.asarray(cm))\r\n                #connectivityweight.append(np.asarray(Weight))\r\n\r\n\r\n                connectivitymatrix.append(np.where(cm==1)[0])\r\n                connectivityweight.append(Weight[np.where(cm==1)])\r\n                connectivityZpos.append(Zpos[np.where(cm==1)])\r\n                #create external synaptic input\r\n                nbstim=int(Afferences[26])\r\n                nbth=int(Afferences[25])\r\n\r\n                if (nbstim != 0):\r\n                    x0 = [np.random.randint(self.NB_DPYR ) for i in range(np.min((int(nbstim),self.NB_DPYR)))]\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR.append(np.asarray(x0))\r\n                    # connectivitymatrix[-1] = np.hstack((connectivitymatrix[-1], -np.asarray(x0) - 1))\r\n                else:\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR.append(np.asarray([]))\r\n\r\n                if (nbth!=0):\r\n                    x1 = [np.random.randint(self.NB_Th) for i in range(np.min((int(nbth),self.NB_Th)))]\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th.append(np.asarray(x1))\r\n                    # connectivitymatrix[-1] = np.hstack((connectivitymatrix[-1], -np.asarray(x1) - 1))\r\n                else:\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th.append(np.asarray([]))\r\n\r\n        # self.updateCell.something_happened.emit(-1)\r\n        return connectivitymatrix, connectivityweight\r\n\r\n    @staticmethod\r\n    @njit\r\n    def find_intersection(r1, r2, d):\r\n        rad1sqr = r1 * r1\r\n        rad2sqr = r2 * r1\r\n\r\n        if d == 0:\r\n            r3 = min(r1, r2)\r\n            return math.pi * r3 * r3\r\n\r\n        angle1 = (rad1sqr + d * d - rad2sqr) / (2 * r1 * d)\r\n        angle2 = (rad2sqr + d * d - rad1sqr) / (2 * r2 * d)\r\n\r\n        if (-1 <= angle1 < 1) or (-1 <= angle2 < 1):\r\n            theta1 = math.acos(angle1) * 2\r\n            theta2 = math.acos(angle2) * 2\r\n            area1 = (0.5 * theta2 * rad2sqr) - (0.5 * rad2sqr * math.sin(theta2))\r\n            area2 = (0.5 * theta1 * rad1sqr) - (0.5 * rad1sqr * math.sin(theta1))\r\n\r\n            return area1 + area2\r\n        elif angle1 < -1 or angle2 < -1:\r\n            r3 = min(r1, r2)\r\n            return math.pi * r3 * r3\r\n        return 0\r\n\r\n    @staticmethod\r\n    @njit\r\n    def find_intersection_high(S_z, T_z, r1, r2, d):\r\n        h = np.minimum(S_z[1], T_z[1]) - np.maximum(S_z[0], T_z[0])\r\n        if h > 0:\r\n            overlap = find_intersection(r1, r2, d) * h\r\n            return overlap, 1\r\n        else:\r\n            return 0., 0.\r\n\r\n    @staticmethod\r\n    @vectorize([float64(float64, float64, float64, float64, float64, float64, float64)])\r\n    def find_intersection_high_vectorize(S_z0,S_z1, T_z0,T_z1,r1,r2,d):\r\n        h = np.minimum(S_z1, T_z1) - np.maximum(S_z0, T_z0)\r\n        if h > 0:\r\n            if r1+r2 < d:\r\n                return 0.\r\n            if d == 0:\r\n                r3 = min(r1, r2)\r\n                return math.pi * r3 * r3\r\n            rad1sqr = r1 * r1\r\n            rad2sqr = r2 * r2\r\n            d2 = d * d\r\n            angle1 = (rad1sqr + d2 - rad2sqr) / (2 * r1 * d)\r\n            angle2 = (rad2sqr + d2 - rad1sqr) / (2 * r2 * d)\r\n            if (-1 <= angle1 < 1) or (-1 <= angle2 < 1):\r\n                theta1 = math.acos(angle1) * 2\r\n                theta2 = math.acos(angle2) * 2\r\n                area1 = (0.5 * theta2 * rad2sqr) - (0.5 * rad2sqr * math.sin(theta2))\r\n                area2 = (0.5 * theta1 * rad1sqr) - (0.5 * rad1sqr * math.sin(theta1))\r\n                return area1 + area2\r\n            elif angle1 < -1 or angle2 < -1:\r\n                r3 = min(r1, r2)\r\n                return math.pi * r3 * r3\r\n            return 0.\r\n        else:\r\n            return 0.\r\n\r\n    @staticmethod\r\n    @vectorize([float64(float64, float64, float64, float64, float64, float64, float64, float64, float64)])\r\n    def find_conic_intersection_high_vectorize(S_z0,S_z1, T_z0,T_z1,r1,r2,d, step, cone_sens):\r\n        h = np.minimum(S_z1, T_z1) - np.maximum(S_z0, T_z0)\r\n        if h > 0:\r\n            heith = T_z1 - T_z0\r\n            r = np.arange(step, heith, step) / heith * r2\r\n            h2 = np.arange(step, heith, step)\r\n            if cone_sens == 0:\r\n                d2 = T_z0 + h2\r\n                r = r[np.bitwise_and(d2 >= S_z0, d2 <= S_z1)]\r\n            elif cone_sens ==1:\r\n                d2 = T_z1 - h2\r\n                r = r[np.bitwise_and(d2 >= S_z0, d2 <= S_z1)]\r\n            o = 0.\r\n            for ids in range(len(r)):\r\n                r3 = r[ids]\r\n                if r1 + r3 < d:\r\n                    continue\r\n                if d == 0:\r\n                    r4 = min(r1, r3)\r\n                    o += math.pi * r4 * r4\r\n                    continue\r\n                rad1sqr = r1 * r1\r\n                rad2sqr = r3 * r3\r\n                d2 = d * d\r\n                angle1 = (rad1sqr + d2 - rad2sqr) / (2 * r1 * d)\r\n                angle2 = (rad2sqr + d2 - rad1sqr) / (2 * r3 * d)\r\n                if (-1 <= angle1 < 1) or (-1 <= angle2 < 1):\r\n                    theta1 = math.acos(angle1) * 2\r\n                    theta2 = math.acos(angle2) * 2\r\n                    area1 = (0.5 * theta2 * rad2sqr) - (0.5 * rad2sqr * math.sin(theta2))\r\n                    area2 = (0.5 * theta1 * rad1sqr) - (0.5 * rad1sqr * math.sin(theta1))\r\n                    o +=  area1 + area2\r\n                    continue\r\n                elif angle1 < -1 or angle2 < -1:\r\n                    r4 = min(r1, r3)\r\n                    o += math.pi * r4 * r4\r\n                    continue\r\n            return o\r\n        else:\r\n            return 0.\r\n\r\n\r\n    def IsConnected(self,Source,Sourcepos,Target,Targetpos,d):\r\n        step = 10.  # micrometeres\r\n        connected = 0\r\n        MeanPos =0\r\n        overlap = 0.0\r\n        DendConn = 0\r\n        ConnPos = []\r\n        if Source.type in [0, 3, 4]:  # PC/ VIP or RLN\r\n            S_Z0 = Sourcepos[2] + Source.AX_down # lower threshold\r\n            S_Z1 = Sourcepos[2] + Source.AX_up  # upper threshold\r\n\r\n            if S_Z0 < 0:#kepp axon in the cortical columnlength\r\n                S_Z0 = 0.\r\n            if S_Z1 > self.L:\r\n                S_Z1 = self.L+0.\r\n\r\n            # if PC ---> PC ----> #dendrite targeting\r\n            if Target.type == 0:  # PC\r\n                DendConn = 1\r\n                if Target.subtype in [1,2]:  # IPC or UPC\r\n                    # first cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r1, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n\r\n\r\n\r\n                    #  second cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c2_down\r\n                    T_Z1_n = Targetpos[2] + Target.c2_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r2, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n\r\n\r\n\r\n\r\n\r\n                elif Target.subtype == 3:  # BPC\r\n                    # cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    o=self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Adend_w, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n                    # cylinder haut\r\n                    T_Z0_n = Targetpos[2] + Target.c2_down\r\n                    T_Z1_n = Targetpos[2] + Target.c2_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, 10, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n                    # cylinder bas\r\n                    T_Z0_n = Targetpos[2] + Target.c3_down\r\n                    T_Z1_n = Targetpos[2] + Target.c3_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, 10, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n                elif Target.subtype == 4:  # SSC\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Bdend_w, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n\r\n                elif Target.subtype == 0: # TPC\r\n                    # first cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r1, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n                    #  second cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c2_down\r\n                    T_Z1_n = Targetpos[2] + Target.c2_up\r\n                    o= self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r2, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n                    #  cone\r\n                    T_Z0_n = Targetpos[2] + Target.c3_down\r\n                    T_Z1_n = Targetpos[2] + Target.c3_up\r\n                    o= self.find_conic_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w / 2, Target.r3, d, step, 0)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([S_Z0,T_Z0_n]),np.min([S_Z1,T_Z1_n])]))\r\n\r\n\r\n            elif Target.type in [1, 2, 3, 4]:  # PV, SST, VIP or RLN\r\n                T_Z0_n = Targetpos[2] + Target.c1_down\r\n                T_Z1_n = Targetpos[2] + Target.c1_up\r\n                overlap += self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Bdend_w, d)\r\n\r\n\r\n\r\n        ###interneurons\r\n        ###PV\r\n        elif Source.type == 1:  # PV\r\n\r\n            if Source.subtype == 0:  # BC  only inside the layer\r\n                S_Z0 = Sourcepos[2] + Source.AX_down\r\n                S_Z1 = Sourcepos[2] + Source.AX_up\r\n                if S_Z0 < 0:  # kepp axon in the cortical columnlength\r\n                    S_Z0 = 0.\r\n                if S_Z1 > self.L:\r\n                    S_Z1 = self.L + 0.\r\n\r\n                if Target.type == 0:  # PV basket -->PC targetssoma\r\n                    if  Target.layer == 2  and  Target.subtype == 4 : #Si layeur IV et stellate\r\n                        T_Z0_n = Targetpos[2] - Target.Bdend_l / 4\r\n                        T_Z1_n = Targetpos[2] + Target.Bdend_l / 4\r\n                        overlap += self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w / 2, Target.Bdend_w / 4, d)\r\n\r\n\r\n                    else:  #\r\n                        T_Z0_n = Targetpos[2] - Target.Bdend_l / 2\r\n                        T_Z1_n = Targetpos[2] + Target.hsoma\r\n                        overlap += self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.dsoma, d)\r\n\r\n\r\n                elif Target.type in [1, 2, 3, 4]:  # PV-->PV/SST/VIP/RLN\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    overlap += self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Bdend_w, d)\r\n\r\n\r\n\r\n            elif Source.subtype == 1:  # PV Chandelier -> PC\r\n                S_Z0 = Sourcepos[2] + Source.AX_down\r\n                S_Z1 = Sourcepos[2] + Source.AX_up\r\n\r\n                if Target.type == 0:  # PV Chandelier -->PC targetssoma\r\n                    T_Z0_n = Targetpos[2] - Target.hsoma\r\n                    T_Z1_n = Targetpos[2]\r\n                    overlap += self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w / 2, Target.dsoma / 2, d)\r\n\r\n\r\n                elif Target.type == 1 in [1, 2, 3, 4]:  # PV-->PV/SST/VIP/RLN\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    overlap += self.find_intersection_high_vectorize(S_Z0, S_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Bdend_w, d)\r\n\r\n\r\n\r\n        ####\r\n        # SST\r\n        elif Source.type == 2:  # SST\r\n            Sbot_Z0 = Sourcepos[2] + Source.c1_down\r\n            Sbot_Z1 = self.L - self.Layer_d[0]\r\n            if Sbot_Z0 < 0:#kepp axon in the cortical columnlength\r\n                Sbot_Z0 = 0.\r\n            if Sbot_Z1 > self.L:\r\n                Sbot_Z1 = self.L+0.\r\n            Stop_Z0 = Sbot_Z1\r\n            Stop_Z1 = self.L\r\n            if Sbot_Z0 < 0:#kepp axon in the cortical columnlength\r\n                Sbot_Z0 = 0.\r\n            if Sbot_Z1 > self.L:\r\n                Sbot_Z1 = self.L+0.\r\n\r\n            if Target.type == 0:  # SST -> PC\r\n                DendConn = 1\r\n\r\n                if Target.subtype in [1, 2]:  # IPC or UPC\r\n                    # first cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n\r\n                    o = self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r1, d)\r\n                    overlap +=o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0,T_Z0_n]),np.min([Sbot_Z1,T_Z1_n])]))\r\n                    o= self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.r1, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n\r\n                    # cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c2_down\r\n                    T_Z1_n = Targetpos[2] + Target.c2_up\r\n                    #first axon\r\n                    o = self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r2, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    #second axon\r\n                    o = self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.r2, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n\r\n\r\n                elif Target.subtype == 3:  # BPC\r\n                    # cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    #first axon\r\n                    o= self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Adend_w, d)\r\n                    overlap += o\r\n                    if o>0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0,T_Z0_n]),np.min([Sbot_Z1,T_Z1_n])]))\r\n\r\n                    #second axon\r\n                    o= self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2 , Target.Adend_w, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n                    # cylinder bas\r\n                    T_Z0_n = Targetpos[2] + Target.c2_down\r\n                    T_Z1_n = Targetpos[2] + Target.c2_up\r\n                    o= self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r2, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    o= self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2 , Target.r2, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n                    # cylinder haut\r\n                    T_Z0_n = Targetpos[2] + Target.c3_down\r\n                    T_Z1_n = Targetpos[2] + Target.c3_up\r\n\r\n                    o= self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r2,d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    o= self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.r2,d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n\r\n\r\n                elif Target.subtype == 4:  # SSC\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n\r\n                    o= self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Bdend_w,d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    o= self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.Bdend_w, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n\r\n\r\n                elif Target.subtype == 0:  # TPC\r\n                    # first cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c1_down\r\n                    T_Z1_n = Targetpos[2] + Target.c1_up\r\n                    o = self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r1, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    o = self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.r1, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n\r\n\r\n                    # cylinder\r\n                    T_Z0_n = Targetpos[2] + Target.c2_down\r\n                    T_Z1_n = Targetpos[2] + Target.c2_up\r\n                    o= self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r2, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    o= self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.r2, d)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n                    # cone\r\n                    T_Z0_n = Targetpos[2]  + Target.c3_down\r\n                    T_Z1_n = Targetpos[2] + Target.c3_up\r\n                    o = self.find_conic_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.r3, d, step, 0)\r\n                    overlap += o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Sbot_Z0, T_Z0_n]), np.min([Sbot_Z1, T_Z1_n])]))\r\n\r\n                    o = self.find_conic_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.r3, d, step, 0)\r\n                    overlap +=o\r\n                    if o > 0:\r\n                        ConnPos.append(np.mean([np.max([Stop_Z0, T_Z0_n]), np.min([Stop_Z1, T_Z1_n])]))\r\n\r\n\r\n            #     # if SST--->PV\r\n            elif Target.type in [1, 2, 3, 4]:  # PV insidelayer\r\n                T_Z0_n = Targetpos[2] +Target.c1_down\r\n                T_Z1_n = Targetpos[2] +Target.c1_up\r\n                overlap += self.find_intersection_high_vectorize(Sbot_Z0, Sbot_Z1, T_Z0_n, T_Z1_n, Source.AX_w, Target.Bdend_w, d)\r\n                overlap += self.find_intersection_high_vectorize(Stop_Z0, Stop_Z1, T_Z0_n, T_Z1_n, Source.AX_w2, Target.Bdend_w,d)\r\n\r\n        if overlap > 0:\r\n            connected = 1\r\n            if DendConn==1:\r\n                MeanPos=np.mean(ConnPos)\r\n            else:\r\n                MeanPos=0\r\n\r\n        ################\r\n        #        print(connected)\r\n        #        print(overlap)\r\n        return connected, overlap,MeanPos\r\n\r\n\r\n    def Get_max_width_vect(self, Cell, z, Z0):\r\n        d = z - Z0\r\n\r\n        if Cell.subtype == 0:  # tufted\r\n            r = np.zeros(d.shape)\r\n            r[d<Cell.d1] = (Cell.d1-d[d<Cell.d1])*self.tanpix40p180\r\n            r[(d>Cell.d1)&(d<(Cell.d1+Cell.d2))] = 10\r\n            r[(d>(Cell.d1+Cell.d2))&(d<(Cell.Adend_l))] = (d[(d>(Cell.d1+Cell.d2))&(d<(Cell.Adend_l))]-Cell.d1-Cell.d2)*self.tanpix50p180\r\n        elif Cell.subtype == 1: #untufted\r\n            r = np.zeros(d.shape)\r\n            r[d<Cell.d1] = (Cell.d1-d[d<Cell.d1])*self.tanpix40p180\r\n            r[(d>Cell.d1)&(d<Cell.Adend_l)] = 10\r\n        elif Cell.subtype == 2: #Inversed\r\n            r = np.ones(d.shape) * 10\r\n            r[(d>Cell.d3+Cell.d2)] = (d[(d>Cell.d3+Cell.d2)]-(Cell.d3+Cell.d2))*self.tanpix40p180\r\n        elif Cell.subtype == 3: #Bipolar\r\n            r = np.ones(d.shape) * 10\r\n            r[(d < Cell.Adend_l/6)&(d > (-Cell.Adend_l/6))] = Cell.Adend_w\r\n        elif Cell.subtype == 4:  #SSC\r\n            r = np.ones(d.shape) * Cell.Adend_w\r\n        return r\r\n\r\n    def Get_max_width_vect2(self, Cell, z, Z0):\r\n        d = z - Z0\r\n\r\n        if Cell.subtype == 0:  # tufted\r\n            r = np.zeros(d.shape)\r\n            self.Get_max_width_vect_subtype0(d,Cell.d1,Cell.d2,Cell.Adend_l,self.tanpix40p180,self.tanpix50p180, r)\r\n\r\n        elif Cell.subtype == 1: #untufted\r\n            r = np.zeros(d.shape)\r\n            self.Get_max_width_vect_subtype1(d, Cell.d1, Cell.Adend_l, self.tanpix40p180, r)\r\n        elif Cell.subtype == 2: #Inversed\r\n            r = np.ones(d.shape) * 10\r\n            self.Get_max_width_vect_subtype2(d, Cell.d2, Cell.d3, self.tanpix40p180, r)\r\n        elif Cell.subtype == 3: #Bipolar\r\n            r = np.ones(d.shape) * 10\r\n            self.Get_max_width_vect_subtype3(d, Cell.Adend_l, Cell.Adend_w, r)\r\n        elif Cell.subtype == 4:  #SSC\r\n            r = np.ones(d.shape) * Cell.Adend_w\r\n        return r\r\n\r\n\r\n    @staticmethod\r\n    @guvectorize([\"float64[:], float64, float64, float64, float64, float64, float64[:]\"], '(n),(),(),(),(),()->(n)')\r\n    def Get_max_width_vect_subtype0(d,d1,d2,Adend_l,tanpix40p180,tanpix50p180, r):\r\n        r[d < d1] = (d1 - d[d < d1]) * tanpix40p180\r\n        r[(d > d1) & (d < (d1 + d2))] = 10\r\n        r[(d > (d1 + d2)) & (d < (Adend_l))] = (d[(d > (d1 + d2)) & (d < (Adend_l))] - d1 - d2) * tanpix50p180\r\n\r\n    @staticmethod\r\n    @guvectorize([\"float64[:], float64, float64, float64, float64[:]\"], '(n),(),(),()->(n)')\r\n    def Get_max_width_vect_subtype1(d,d1,Adend_l,tanpix40p180, r):\r\n        r[d < d1] = (d1 - d[d < d1]) * tanpix40p180\r\n        r[(d > d1) & (d < Adend_l)] = 10\r\n\r\n    @staticmethod\r\n    @guvectorize([\"float64[:], float64, float64, float64, float64[:]\"], '(n),(),(),()->(n)')\r\n    def Get_max_width_vect_subtype2(d, d2,d3, tanpix40p180, r):\r\n        r[(d > d3 + d2)] = (d[(d > d3 + d2)] - (d3 + d2)) * tanpix40p180\r\n\r\n    @staticmethod\r\n    @guvectorize([\"float64[:], float64, float64, float64[:]\"], '(n),(),()->(n)')\r\n    def Get_max_width_vect_subtype3(d, Adend_l, Adend_w, r):\r\n        r[(d < Adend_l / 6) & (d > (-Adend_l / 6))] = Adend_w\r\n\r\n    def Get_max_width(self,Cell,z,Z0):\r\n        d = z - Z0\r\n        if Cell.subtype==0: #tufted\r\n            if d<Cell.d1:\r\n                return (Cell.d1-d)*math.tan(40*math.pi/180)\r\n\r\n            elif (d>Cell.d1)&(d<(Cell.d1+Cell.d2)):\r\n                return 10\r\n\r\n            elif (d>(Cell.d1+Cell.d2))&(d<(Cell.Adend_l)):\r\n                return (d-Cell.d1-Cell.d2)*math.tan(50*math.pi/180)\r\n\r\n            else:\r\n                return 0\r\n\r\n\r\n        elif Cell.subtype == 1: #untufted\r\n            if d<Cell.d1:\r\n                return (Cell.d1-d)*math.tan(40*math.pi/180)\r\n\r\n            if (d>Cell.d1)&(d<Cell.Adend_l):\r\n                return 10\r\n\r\n        elif Cell.subtype == 2: #Inversed\r\n            if (d>Cell.d3+Cell.d2):\r\n                return (d-(Cell.d3+Cell.d2))*math.tan(40*math.pi/180)\r\n            else:\r\n                return 10\r\n\r\n        elif Cell.subtype == 3: #Bipolar\r\n            if (d < Cell.Adend_l/6)&(d > (-Cell.Adend_l/6)):\r\n                return Cell.Adend_w\r\n            else:\r\n                return 10\r\n\r\n        elif Cell.subtype == 4: #SSC\r\n            return Cell.Adend_w\r\n\r\n    def Get_cell_layer(self,CellNb):\r\n        if CellNb<self.Nbcells[0]:\r\n            return 0\r\n        else:\r\n            if CellNb<self.Nbcells[1]:\r\n                return 1\r\n            else:\r\n                if CellNb<self.Nbcells[2]:\r\n                    return 2\r\n                else:\r\n                    if CellNb<self.Nbcells[3]:\r\n                        return 3\r\n                    else:\r\n                        return 4\r\n\r\n\r\n\r\n    def All2layer(self, indexall, NB_Cells, NB_pyr, NB_PV, NB_SST, NB_VIP, NB_RLN,celltype):  # tranform index of a cell in the network into layer and index in the layer\r\n        layer = []\r\n        new_i = []  # index in the layer\r\n        i = []  # index per type\r\n        if indexall < NB_Cells[0]:  # layer 1\r\n            layer = 0\r\n            new_i=indexall\r\n        elif indexall >= NB_Cells[0:1] and indexall < np.sum(NB_Cells[0:2]):  # layer 2/3\r\n            layer = 1\r\n            new_i = indexall - NB_Cells[0]\r\n        elif indexall >= np.sum(NB_Cells[0:2]) and indexall < np.sum(NB_Cells[0:3]):  # Layer 4\r\n            layer = 2\r\n            new_i = indexall - np.sum(NB_Cells[0:2])\r\n        elif indexall >= np.sum(NB_Cells[0:3]) and indexall < np.sum(NB_Cells[0:4]):  # Layer 5\r\n            layer = 3\r\n            new_i = indexall - np.sum(NB_Cells[0:3])\r\n        elif indexall >= np.sum(NB_Cells[0:4]) and indexall < np.sum(NB_Cells[0:5]):  # Layer 6\r\n            layer = 4\r\n            new_i = indexall - np.sum(NB_Cells[0:4])\r\n\r\n\r\n        type = int(celltype[layer][new_i])\r\n\r\n\r\n        if type == 0:  # PC\r\n            i = new_i + np.sum(NB_pyr[0:layer])\r\n        if type == 1:  # PV\r\n            i = new_i + np.sum(NB_PV[0:layer]) - np.sum(NB_pyr[layer])\r\n        if type == 2:  # SST\r\n            i = new_i + np.sum(NB_SST[0:layer]) - np.sum(NB_pyr[layer]) - np.sum(NB_PV[layer])\r\n        if type == 3:  # VIP\r\n            i = new_i + np.sum(NB_VIP[0:layer]) - np.sum(NB_pyr[layer]) - np.sum(NB_PV[layer]) - np.sum(NB_SST[layer])\r\n        if type == 4:  # RLN\r\n            i = new_i + np.sum(NB_RLN[0:layer]) - np.sum(NB_pyr[layer]) - np.sum(NB_PV[layer]) - np.sum(NB_SST[layer]) - np.sum(NB_VIP[layer])\r\n\r\n\r\n        return layer, type, i\r\n\r\n\r\n\r\n    def Generate_Stims(self, I_inj=60, tau=4, stimDur=3, nbstim=5, varstim=12, freq=1.5,StimStart = 0):\r\n        print('computing stim signals')\r\n        # nb = int(1e-3 * self.T*freq) #frequency of fast ripples\r\n        if not self.seed == 0:\r\n            np.random.seed(self.seed)\r\n        # else:\r\n        #     np.random.seed()\r\n        nb = 1\r\n        nb_Stim_Signals = self.NB_DPYR\r\n        nbOfSamplesStim = int(stimDur / self.dt)\r\n        npos = np.round(np.random.beta(2, 2, nb) * self.nbEch / nb) + np.linspace(0, self.nbEch, nb)  # position of HFOs\r\n        # npos=self.nbEch/2\r\n        Stim_Signals_out = np.zeros((nb_Stim_Signals, self.nbEch))\r\n        varianceStim = varstim / self.dt\r\n        t = np.arange(self.nbEch) * self.dt\r\n        y = np.zeros(t.shape)\r\n        for tt, tp in enumerate(t):\r\n            if tt <= nbOfSamplesStim:\r\n                y[tt] = (1. - np.exp(-tp / tau)) * I_inj\r\n            if tt > nbOfSamplesStim:\r\n                y[tt] = (np.exp(-(tp - nbOfSamplesStim * self.dt) / tau)) * y[nbOfSamplesStim - 1]\r\n        # print(n)\r\n        # print(n*self.dt)\r\n        if StimStart == 0:\r\n            N0 = int(self.nbEch / 2)\r\n        else:\r\n            N0 = int(StimStart / self.dt)\r\n        for St in range(nb_Stim_Signals):\r\n            yt = np.zeros(self.nbEch)\r\n            for j in range(nb):\r\n                y2 = np.zeros(self.nbEch)\r\n                for i in range(nbstim):\r\n                    # N0=int(npos[j])\r\n                    # N0 = int(self.nbEch / 2)\r\n                    inst = int(np.round((np.random.normal(0, varianceStim))))\r\n                    t0 = N0 + inst\r\n                    # print(inst)\r\n                    if t0 == 0:\r\n                        t0 = 0\r\n                    elif t0 < 0:\r\n                        t0 = N0 + int(varianceStim * inst / abs(2 * inst))\r\n                    elif t0 > self.nbEch - 1:\r\n                        if inst > 0:\r\n                            t0 = N0 + int(varianceStim * inst / abs(2 * inst))\r\n                        else:\r\n                            t0 = N0\r\n                    try:\r\n                        y2[range(t0, len(y2))] = y2[range(t0, len(y2))] + y[range(len(y2) - t0)]\r\n                    except:\r\n                        pass\r\n                yt += y2\r\n            Stim_Signals_out[St, :] = yt\r\n\r\n        # for j in range(nb):\r\n        #     N0 = int(npos[j])\r\n        #     self.Stim_Signals[:, int(N0-2*varianceStim):int(N0+2*varianceStim)]=Stim_Signals_out[:, int(N0-2*varianceStim):int(N0+2*varianceStim)]\r\n        #self.Stim_Signals = Stim_Signals_out + self.Stim_InputSignals\r\n        self.Stim_Signals = Stim_Signals_out\r\n\r\n        return self.Stim_Signals\r\n\r\n    def set_seed(self,seed):\r\n        self.seed=seed\r\n\r\n    def Generate_input(self, I_inj=25, tau=4, stimDur=3, nbstim=5, deltamin=14, delta=18):\r\n        if not self.seed == 0:\r\n            np.random.seed(self.seed)\r\n        # else:\r\n        #     np.random.seed()\r\n        nb_Stim_Signals = self.NB_Th\r\n        nbOfSamplesStim = int(stimDur / self.dt)  # nb of samples in one stimulation signal\r\n        Stim_Signals_out = np.zeros((nb_Stim_Signals, self.nbEch))  # all signal of stim\r\n        t = np.arange(self.nbEch) * self.dt\r\n        y = np.zeros(t.shape)\r\n        for tt, tp in enumerate(t):\r\n            if tt <= nbOfSamplesStim:\r\n                y[tt] = (1. - np.exp(-tp / tau)) * I_inj\r\n            if tt > nbOfSamplesStim:\r\n                y[tt] = (np.exp(-(tp - nbOfSamplesStim * self.dt) / tau)) * y[nbOfSamplesStim - 1]\r\n\r\n        nbsigs = int(self.T / (2 * delta))\r\n        for St in range(nb_Stim_Signals):\r\n            yt = np.zeros(self.nbEch)\r\n            n = np.round(np.random.uniform(delta / self.dt, (self.T - delta) / self.dt, nbsigs))\r\n            d = np.round(np.random.uniform(deltamin, delta, nbsigs)) / self.dt\r\n            for k in range(int(nbsigs)):\r\n                y2 = np.zeros(self.nbEch)\r\n                N = int(n[k])\r\n                D = int(d[k])\r\n                for i in range(nbstim):\r\n                    inst = int(np.round(np.random.normal(0, D)))\r\n                    if inst == 0:\r\n                        continue\r\n                    t0 = N + inst\r\n                    if t0 < 0:\r\n                        t0 = N + D * int(inst / abs(2 * inst))\r\n                    if t0 > self.nbEch - 1:\r\n                        t0 = N + D * int(inst / abs(2 * inst))\r\n                    y2[range(t0, len(y2))] = y2[range(t0, len(y2))] + y[range(len(y2) - t0)]\r\n                yt += y2\r\n            Stim_Signals_out[St, :] = yt\r\n        print('computing stim signals....finished')\r\n        self.Stim_InputSignals = Stim_Signals_out\r\n        return self.Stim_InputSignals\r\n\r\n    def create_cells(self):\r\n        self.presynaptic_instance = presynaptic_class(\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Cell_AMPA],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Cell_GABA],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Soma_AMPA],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Soma_GABA_d],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Soma_GABA_s],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Soma_GABA_a],\r\n            [np.array(l, dtype=np.int32) for l in self.ExternalPreSynaptic_Cell_AMPA_DPYR],\r\n            [np.array(l, dtype=np.int32) for l in self.ExternalPreSynaptic_Cell_AMPA_Th],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynapticWeight_AMPA],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==1)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==2)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==3)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==4)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==5)],\r\n            [np.array(l, dtype=np.int32) for l in self.PreSynapticWeight_GABA],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==1)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==2)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==3)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==4)],\r\n            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==5)],\r\n\r\n        )\r\n\r\n        self.List_DPYR = []\r\n        self.List_Th = []\r\n        self.List_PYR = []\r\n        self.List_PV = []\r\n        self.List_SST = []\r\n        self.List_VIP = []\r\n        self.List_RLN = []\r\n        self.List_Neurone_param = []\r\n\r\n        ###DPC Define the PYR cells in the distant cortex in percentage\r\n        layer_ratio = 0.4  # the ratio of PYR cells from layer 2/3 with respect to 5/6.\r\n        if self.NB_DPYR == 0:\r\n            self.List_DPYR = [PC_neo3.pyrCellneo(1)]\r\n        for i in range(int(self.NB_DPYR * layer_ratio)):  # define PYR cells sublayer types\r\n            self.List_DPYR.append(PC_neo3.pyrCellneo(1))  # from layer 2\r\n        for i in range(int(self.NB_DPYR * layer_ratio), self.NB_DPYR + 1):  # from layer 5\r\n            self.List_DPYR.append(PC_neo3.pyrCellneo(3))\r\n\r\n        ####TH Cells represent the input from thalamus with input signals\r\n\r\n        for i in range(self.NB_Th):\r\n            self.List_Th.append(PC_neo3.pyrCellneo(1))  # TO do adjust parameters\r\n\r\n        ###PC\r\n        if np.sum(self.NB_PYR) == 0:\r\n            self.List_PYR = [PC_neo3.pyrCellneo(1)]\r\n        count = 0\r\n        PCsubtypes_Per = np.cumsum(self.PCsubtypes_Per,axis=1)\r\n        for l in range(1, 5):\r\n            for i in range(self.NB_PYR[l]):  # define PYR cells sublayer types\r\n                self.List_PYR.append(PC_neo3.pyrCellneo(l))\r\n                # Check subtypes and load lambda values\r\n                if i < PCsubtypes_Per[l][0]:\r\n                    subtype = 0  # TPC\r\n                elif (i >= PCsubtypes_Per[l][0]) and (i < PCsubtypes_Per[l][1]):\r\n                    subtype = 1  # UPC\r\n                elif (i >= PCsubtypes_Per[l][1]) and (i < PCsubtypes_Per[l][2]):\r\n                    subtype = 2  # IPC\r\n                elif (i >= PCsubtypes_Per[l][2]) and (i < PCsubtypes_Per[l][3]):\r\n                    subtype = 3  # BPC\r\n                elif (i >= PCsubtypes_Per[l][3]) and (i < PCsubtypes_Per[l][4]):\r\n                    subtype = 4  # SSC\r\n                self.List_PYR[count].Lambda_s[2] = self.List_Lambda_s[l-1][subtype]\r\n                self.List_PYR[count].Lambda_a[2] = self.List_Lambda_s[l-1][subtype]\r\n                self.List_PYR[count].Lambda_d[2] = self.List_Lambda_d[l-1][subtype]\r\n        ######PV\r\n        if np.sum(self.NB_PV) == 0:\r\n            self.List_PV = [PV_neo.PVcell()]\r\n        for i in range(np.sum(self.NB_PV)):\r\n            self.List_PV.append(PV_neo.PVcell())\r\n        #######SST\r\n        if np.sum(self.NB_SST) == 0:\r\n            self.List_SST = [SST_neo.SSTcell()]\r\n        for i in range(np.sum(self.NB_SST)):\r\n            self.List_SST.append(SST_neo.SSTcell())\r\n        #######VIP\r\n        if np.sum(self.NB_VIP) == 0:\r\n            self.List_VIP = [VIP_neo.VIPcell()]\r\n        for i in range(np.sum(self.NB_VIP)):\r\n            self.List_VIP.append(VIP_neo.VIPcell())\r\n        #######RLN\r\n        if np.sum(self.NB_RLN) == 0:\r\n            self.List_RLN = [RLN_neo.RLNcell()]\r\n        for i in range(np.sum(self.NB_RLN)):\r\n            self.List_RLN.append(RLN_neo.RLNcell())\r\n\r\n        # initialize synaptic ODE\r\n        #########################################################\r\n        count = 0\r\n        for i in range(np.sum(self.NB_RLN[0])):\r\n            # print(self.PreSynaptic_Cell_AMPA)\r\n            self.List_RLN[i].NbODEs_s_AMPA = len(self.PreSynaptic_Cell_AMPA[count]) + len(\r\n                self.ExternalPreSynaptic_Cell_AMPA_DPYR[count]) + len(self.ExternalPreSynaptic_Cell_AMPA_Th[count])\r\n            self.List_RLN[i].NbODEs_s_GABA = len(self.PreSynaptic_Cell_GABA[count])\r\n            self.List_RLN[i].init_vector()\r\n            count += 1\r\n\r\n        ###external input from th ad DPYR\r\n        # nbDpyr = self.inputNB * np.array([0.25, 0.06, 0.05,0.01])\r\n        # nbTh = self.inputNB * np.array([0.15,0.11,0.11,0.04])\r\n\r\n        for l in range(1, 5):  # was 1 to 5 before to check if I corrected rigth\r\n            for i in range(np.sum(self.NB_PYR[0:l]), self.NB_PYR[l] + np.sum(self.NB_PYR[0:l])):\r\n                self.List_PYR[i].NbODEs_s_AMPA = len(self.PreSynaptic_Cell_AMPA[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th[count])\r\n                self.List_PYR[i].NbODEs_s_GABA = len(self.PreSynaptic_Cell_GABA[count])\r\n                self.List_PYR[i].init_vector()\r\n                count += 1\r\n            for i in range(np.sum(self.NB_PV[0:l]), self.NB_PV[l] + np.sum(self.NB_PV[0:l])):\r\n                self.List_PV[i].NbODEs_s_AMPA = len(self.PreSynaptic_Cell_AMPA[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th[count])\r\n                self.List_PV[i].NbODEs_s_GABA = len(self.PreSynaptic_Cell_GABA[count])\r\n                self.List_PV[i].init_vector()\r\n                count += 1\r\n            for i in range(np.sum(self.NB_SST[0:l]), self.NB_SST[l] + np.sum(self.NB_SST[0:l])):\r\n                self.List_SST[i].NbODEs_s_AMPA = len(self.PreSynaptic_Cell_AMPA[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th[count])\r\n                self.List_SST[i].NbODEs_s_GABA = len(self.PreSynaptic_Cell_GABA[count])\r\n                self.List_SST[i].init_vector()\r\n                count += 1\r\n            for i in range(np.sum(self.NB_VIP[0:l]), self.NB_VIP[l] + np.sum(self.NB_VIP[0:l])):\r\n                self.List_VIP[i].NbODEs_s_AMPA = len(self.PreSynaptic_Cell_AMPA[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th[count])\r\n                self.List_VIP[i].NbODEs_s_GABA = len(self.PreSynaptic_Cell_GABA[count])\r\n                self.List_VIP[i].init_vector()\r\n                count += 1\r\n\r\n            for i in range(np.sum(self.NB_RLN[0:l]), self.NB_RLN[l] + np.sum(self.NB_RLN[0:l])):\r\n                self.List_RLN[i].NbODEs_s_AMPA = len(self.PreSynaptic_Cell_AMPA[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_DPYR[count]) + len(\r\n                    self.ExternalPreSynaptic_Cell_AMPA_Th[count])\r\n                self.List_RLN[i].NbODEs_s_GABA = len(self.PreSynaptic_Cell_GABA[count])\r\n                self.List_RLN[i].init_vector()\r\n                count += 1\r\n\r\n        for l in range(0, 5):\r\n            Neurone_param = []\r\n            for i in range(np.sum(self.NB_PYR[0:l]), self.NB_PYR[l] + np.sum(self.NB_PYR[0:l])):\r\n                Neurone_param.append({s: getattr(self.List_PYR[i], s) for s in self.get_PYR_Variables()})\r\n            for i in range(np.sum(self.NB_PV[0:l]), self.NB_PV[l] + np.sum(self.NB_PV[0:l])):\r\n                Neurone_param.append({s: getattr(self.List_PV[i], s) for s in self.get_PV_Variables()})\r\n            for i in range(np.sum(self.NB_SST[0:l]), self.NB_SST[l] + np.sum(self.NB_SST[0:l])):\r\n                Neurone_param.append({s: getattr(self.List_SST[i], s) for s in self.get_SST_Variables()})\r\n            for i in range(np.sum(self.NB_VIP[0:l]), self.NB_VIP[l] + np.sum(self.NB_VIP[0:l])):\r\n                Neurone_param.append({s: getattr(self.List_VIP[i], s) for s in self.get_VIP_Variables()})\r\n            for i in range(np.sum(self.NB_RLN[0:l]), self.NB_RLN[l] + np.sum(self.NB_RLN[0:l])):\r\n                Neurone_param.append({s: getattr(self.List_RLN[i], s) for s in self.get_RLN_Variables()})\r\n            self.List_Neurone_param.append(Neurone_param)\r\n        self.UpdateModel()\r\n        self.ImReady = True\r\n\r\n    def Update_param_model(self):\r\n        for l in range(0, 5):\r\n            ind = 0\r\n            for i in range(np.sum(self.NB_PYR[0:l]), self.NB_PYR[l] + np.sum(self.NB_PYR[0:l])):\r\n                for key in self.List_Neurone_param[l][ind]:\r\n                    setattr(self.List_PYR[i], key, self.List_Neurone_param[l][ind][key])\r\n                ind += 1\r\n            for i in range(np.sum(self.NB_PV[0:l]), self.NB_PV[l] + np.sum(self.NB_PV[0:l])):\r\n                for key in self.List_Neurone_param[l][ind]:\r\n                    setattr(self.List_PV[i], key, self.List_Neurone_param[l][ind][key])\r\n                ind += 1\r\n            for i in range(np.sum(self.NB_SST[0:l]), self.NB_SST[l] + np.sum(self.NB_SST[0:l])):\r\n                for key in self.List_Neurone_param[l][ind]:\r\n                    setattr(self.List_SST[i], key, self.List_Neurone_param[l][ind][key])\r\n                ind += 1\r\n            for i in range(np.sum(self.NB_VIP[0:l]), self.NB_VIP[l] + np.sum(self.NB_VIP[0:l])):\r\n                for key in self.List_Neurone_param[l][ind]:\r\n                    setattr(self.List_VIP[i], key, self.List_Neurone_param[l][ind][key])\r\n                ind += 1\r\n            for i in range(np.sum(self.NB_RLN[0:l]), self.NB_RLN[l] + np.sum(self.NB_RLN[0:l])):\r\n                for key in self.List_Neurone_param[l][ind]:\r\n                    setattr(self.List_RLN[i], key, self.List_Neurone_param[l][ind][key])\r\n                ind += 1\r\n\r\n\r\n\r\n    def Reset_states(self):\r\n        self.UpdateModel()\r\n\r\n    def create_Hyper_Cluster(self, radius=10, EGaba=-50,gGaba=25,gAMPA=8,gNMDA=0.15,BASEGaba=-75,center=None):\r\n        HypPyr_Idx = []\r\n        if center is None:\r\n            center = np.array([self.dx / 2, self.dy / 2, self.dz / 2])\r\n        distances = distance.cdist(self.CellPosition[0:self.Nb_all_cells - 1, :], [center], 'euclidean')\r\n        #print(len(distances))\r\n        for i, d in enumerate(distances):\r\n            if d <= radius:\r\n                if self.List_Neurone_PYR[i].Type == 1:\r\n                    self.List_Neurone_PYR[i].E_GABA = EGaba\r\n                    self.List_Neurone_PYR[i].g_GABA = gGaba\r\n                    self.List_Neurone_PYR[i].g_AMPA = gAMPA\r\n                    self.List_Neurone_PYR[i].g_NMDA = gNMDA\r\n                    HypPyr_Idx.append(i)\r\n\r\n        distances = distance.cdist(self.CellPosition[self.Nb_all_cells:self.NbInter+self.Nb_all_cells-1, :], [center], 'euclidean')\r\n        #print(len(distances))\r\n        for i, d in enumerate(distances):\r\n            if d <= radius:\r\n                self.List_Neurone_BAS[i].E_GABA =BASEGaba\r\n\r\n        #for k in range(self.Nb_all_cells):\r\n            #print('New')\r\n            #print(self.List_Neurone_PYR[k].E_GABA)\r\n        return np.asarray(HypPyr_Idx)\r\n\r\n    def Rest_clusters(self):\r\n        for i in range(self.Nb_all_cells):\r\n            if self.List_Neurone_PYR[i].Type == 1:\r\n                self.List_Neurone_PYR[i].E_GABA = -75\r\n\r\n    def create_mutiple_Hyper_Clusters(self, nbclusters=2, radius=50,EGaba=[-50,-50],gGaba=[25, 25]):\r\n        HypPyr_Idx = []\r\n        center = np.array([self.dx / 2, self.dy / 2, self.dz / 2])\r\n        Ccenter = []\r\n        Cluster_lists = []\r\n        for i in range(nbclusters):\r\n            choose = True\r\n            while (choose):\r\n                C = np.random.choice(range(self.Nb_of_PYR_Stimulated, self.Nb_PYR_Cells))\r\n                Cpos = self.CellPosition[C, :]\r\n                if np.abs(Cpos[0] - self.dx / 2) < (self.dx / 2 - (radius + 30)):\r\n                    if np.abs(Cpos[1] - self.dy / 2) < (self.dy / 2 - (radius + 30)):\r\n                        if not Ccenter == []:\r\n                            s = np.asarray(Ccenter)\r\n                            dis = np.sort(distance.cdist(s, [Cpos, Cpos], 'euclidean')[0, :])\r\n                            #print(dis)\r\n                            if dis[0] > 2 * radius:\r\n                                choose = False\r\n                        else:\r\n                            choose = False\r\n            Ccenter.append(Cpos)\r\n            cluster = self.create_Hyper_Cluster(radius, EGaba=EGaba[i],gGaba=gGaba[i],center=Cpos)\r\n            Cluster_lists.append(cluster)\r\n        return Cluster_lists\r\n     ##################################################\r\n    def UpdateModel(self):\r\n\r\n        for i in range(self.NB_Th):\r\n            self.List_Th[i].init_I_syn()\r\n            self.List_Th[i].init_vector()\r\n            self.List_Th[i].setParameters()\r\n\r\n        for i in range(self.NB_DPYR):\r\n            self.List_DPYR[i].init_I_syn()\r\n            self.List_DPYR[i].init_vector()\r\n            self.List_DPYR[i].setParameters()\r\n\r\n        for i in range(np.sum(self.NB_PYR)):\r\n            self.List_PYR[i].init_I_syn()\r\n            self.List_PYR[i].init_vector()\r\n            self.List_PYR[i].setParameters()\r\n\r\n        for i in range(np.sum(self.NB_PV)):\r\n            self.List_PV[i].init_I_syn()\r\n            self.List_PV[i].init_vector()\r\n            self.List_PV[i].setParameters()\r\n\r\n        for i in range(np.sum(self.NB_SST)):\r\n            self.List_SST[i].init_I_syn()\r\n            self.List_SST[i].init_vector()\r\n            self.List_SST[i].setParameters()\r\n\r\n        for i in range(np.sum(self.NB_VIP)):\r\n            self.List_VIP[i].init_I_syn()\r\n            self.List_VIP[i].init_vector()\r\n            self.List_VIP[i].setParameters()\r\n\r\n        for i in range(np.sum(self.NB_RLN)):\r\n            self.List_RLN[i].init_I_syn()\r\n            self.List_RLN[i].init_vector()\r\n            self.List_RLN[i].setParameters()\r\n\r\n    def Generate_EField(self, EField, stimOnOff, Constant = False):\r\n\r\n        index = 0\r\n        for i, list_type in enumerate(self.List_celltypes):\r\n            for k, type in enumerate(list_type):\r\n                if type == 0:\r\n                    neuron = self.List_PYR[index]\r\n                    if not Constant:\r\n                        pos = self.Cellpos[i][k]\r\n                        x = np.argmin(np.abs(EField['x'] - pos[0]))\r\n                        y = np.argmin(np.abs(EField['y'] - pos[1]))\r\n                        z = np.argmin(np.abs(EField['z'] - pos[2]))\r\n                        E = EField['Er'][x,y,z,:]\r\n                    else:\r\n                        E =  EField['Er']\r\n                    neuron.projection_E(E,E,E)\r\n\r\n                    neuron.update_EField_Stim(stimOnOff)\r\n                    neuron.OnOff = int(stimOnOff)\r\n\r\n    def Generate_EField_Stim(self,type,A,F,stimOnOff,Start = None, Length = None ):\r\n        Stim_Signals_out = np.zeros(self.nbEch)\r\n        t = np.arange(self.nbEch) *(self.dt/1000)\r\n        if not stimOnOff:\r\n            pass\r\n        elif type == 'Constant':\r\n            Stim_Signals_out = Stim_Signals_out + A\r\n        elif type == 'Sinusoidal':\r\n            Stim_Signals_out = A * np.sin(2 * np.pi * F * t)\r\n        elif type == 'rectangular':\r\n            Stim_Signals_out = scipy.signal.square(2 * np.pi * F * t, 0.5)\r\n        elif type == 'triangular':\r\n            Stim_Signals_out = scipy.signal.sawtooth(2 * np.pi * F * t, 0.5)\r\n        if not Start is None and not Length is None:\r\n            start_ind = int(Start/self.dt)\r\n            if start_ind < 0:\r\n                start_ind = 0\r\n            elif start_ind > self.nbEch:\r\n                start_ind = self.nbEch-1\r\n\r\n            end_ind = int((Start+Length)/self.dt)\r\n            if end_ind > self.nbEch:\r\n                end_ind = self.nbEch-1\r\n            elif end_ind < 0:\r\n                end_ind = 0\r\n            Stim_Signals_out[:start_ind] = 0.\r\n            Stim_Signals_out[end_ind:] = 0.\r\n\r\n        self.Stim_EField = Stim_Signals_out\r\n\r\n#        plt.plot(self.Stim_EField)\r\n#        plt.show()\r\n\r\n\r\n\r\n    def runSim(self):\r\n\r\n        # self.UpdateModel()\r\n        print('computing signals...')\r\n        # self.ApplyParamDict()\r\n        t = np.arange(self.nbEch) * self.dt\r\n        self.DpyrVs = np.zeros((np.sum(self.NB_DPYR), len(t)))\r\n        self.DpyrVd = np.zeros((np.sum(self.NB_DPYR), len(t)))\r\n        self.ThpyrVs = np.zeros((np.sum(self.NB_DPYR), len(t)))\r\n        self.ThpyrVd = np.zeros((np.sum(self.NB_DPYR), len(t)))\r\n        self.pyrVd = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrVs = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrVa = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSE_d1 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSE_d23 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSE_d4 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSE_d5 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSE_d6 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_d1 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_d23 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_d4 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_d5 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_d6 = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_s = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.pyrPPSI_a = np.zeros((np.sum(self.NB_PYR), len(t)))\r\n        self.PV_Vs = np.zeros((np.sum(self.NB_PV), len(t)))\r\n        self.SST_Vs = np.zeros((np.sum(self.NB_SST), len(t)))\r\n        self.VIP_Vs = np.zeros((np.sum(self.NB_VIP), len(t)))\r\n        self.RLN_Vs = np.zeros((np.sum(self.NB_RLN), len(t)))\r\n        self.DPYR_Vs = np.zeros((np.sum(self.NB_DPYR), len(t)))\r\n        self.Th_Vs = np.zeros((np.sum(self.NB_Th), len(t)))\r\n        nbcells = np.sum(self.Layer_nbCells)\r\n        layerS = np.zeros(nbcells,dtype=int)\r\n        typeS = np.zeros(nbcells,dtype=int)\r\n        indexS = np.zeros(nbcells,dtype=int)\r\n        for ind in range(nbcells):\r\n            layerS[ind], typeS[ind], indexS[ind] = self.All2layer(ind, self.Layer_nbCells, self.NB_PYR, self.NB_PV, self.NB_SST, self.NB_VIP,\r\n                                               self.NB_RLN, self.List_celltypes)\r\n\r\n        if 1:\r\n            t0 = time.time()\r\n            self.t, self.pyrVs, self.pyrVd, self.pyrVa, self.pyrPPSE_d1, self.pyrPPSE_d23, self.pyrPPSE_d4, self.pyrPPSE_d5, self.pyrPPSE_d6, self.pyrPPSI_d1, self.pyrPPSI_d23, self.pyrPPSI_d4, self.pyrPPSI_d5, self.pyrPPSI_d6, self.pyrPPSI_s, self.pyrPPSI_a, self.PV_Vs, self.SST_Vs, self.VIP_Vs, self.RLN_Vs, self.DPYR_Vs, self.Th_Vs = Model_compute(np.int(self.nbEch),\r\n                                                                                             np.float(self.dt),\r\n                                                                                             np.float(self.tps_start),\r\n                                                                                             self.Layer_nbCells,\r\n                                                                                             self.NB_PYR,\r\n                                                                                             self.NB_PV,\r\n                                                                                             self.NB_SST,\r\n                                                                                             self.NB_VIP,\r\n                                                                                             self.NB_RLN,\r\n                                                                                             self.NB_DPYR,\r\n                                                                                             self.NB_Th,\r\n                                                                                             np.int(self.inputNB),\r\n                                                                                             self.List_PYR,\r\n                                                                                             self.List_PV,\r\n                                                                                             self.List_SST,\r\n                                                                                             self.List_VIP,\r\n                                                                                             self.List_RLN,\r\n                                                                                             self.List_DPYR,\r\n                                                                                             self.List_Th,\r\n                                                                                             self.Stim_Signals,\r\n                                                                                             self.Stim_InputSignals,\r\n                                                                                             self.Stim_EField,\r\n                                                                                             self.presynaptic_instance,\r\n                                                                                             self.pyrVs,\r\n                                                                                             self.pyrVd,\r\n                                                                                             self.pyrVa,\r\n                                                                                             self.pyrPPSE_d1,\r\n                                                                                             self.pyrPPSE_d23,\r\n                                                                                             self.pyrPPSE_d4,\r\n                                                                                             self.pyrPPSE_d5,\r\n                                                                                             self.pyrPPSE_d6,\r\n                                                                                             self.pyrPPSI_d1,\r\n                                                                                             self.pyrPPSI_d23,\r\n                                                                                             self.pyrPPSI_d4,\r\n                                                                                             self.pyrPPSI_d5,\r\n                                                                                             self.pyrPPSI_d6,\r\n                                                                                             self.pyrPPSI_s,\r\n                                                                                             self.pyrPPSI_a,\r\n                                                                                             self.PV_Vs,\r\n                                                                                             self.SST_Vs,\r\n                                                                                             self.VIP_Vs,\r\n                                                                                             self.RLN_Vs,\r\n                                                                                             self.DPYR_Vs,\r\n                                                                                             self.Th_Vs,\r\n                                                                                             layerS,\r\n                                                                                             typeS,\r\n                                                                                             indexS,\r\n                                                                                             t,\r\n                                                                                             np.int(self.seed))\r\n            print(time.time() - t0)\r\n            #run model\r\n\r\n\r\n        return (self.t, self.pyrVs, self.pyrVd,self.pyrVa, self.pyrPPSE_d1, self.pyrPPSE_d23, self.pyrPPSE_d4, self.pyrPPSE_d5, self.pyrPPSE_d6, self.pyrPPSI_d1, self.pyrPPSI_d23, self.pyrPPSI_d4, self.pyrPPSI_d5, self.pyrPPSI_d6, self.pyrPPSI_s, self.pyrPPSI_a, self.PV_Vs, self.SST_Vs, self.VIP_Vs,self.RLN_Vs, self.DPYR_Vs, self.Th_Vs)\r\n\r\n    def Compute_LFP_fonc(self):\r\n        electrode_pos = np.array([0, self.D/2+20, self.L/2])\r\n\r\n        #get principal cells positions\r\n        CellPosition=[]\r\n        for l in range(1,5):\r\n            for i in range(self.NB_PYR[l]):\r\n                CellPosition.append(self.Cellpos[l][i])\r\n        # for i, cellpos in enumerate(CellPosition):\r\n        #     cellpos[0] = cellpos[0] * self.somaSize\r\n        #     cellpos[1] = cellpos[1] * self.somaSize\r\n\r\n        Distance_from_electrode = distance.cdist([electrode_pos, electrode_pos], CellPosition, 'euclidean')[0, :]\r\n        # vect direction??\r\n        U = (CellPosition - electrode_pos) / Distance_from_electrode[:, None]\r\n\r\n        Ssoma = np.pi * (self.somaSize / 2.) * ((self.somaSize / 2.) + self.somaSize * np.sqrt(5. / 4.))\r\n        Stotal = Ssoma / self.p\r\n\r\n        # potentials\r\n        self.LFP = np.zeros(self.pyrVs.shape[1])\r\n        Vs_d = self.pyrVs - self.pyrVd\r\n\r\n        for k in range(self.Nb_PYR_Cells):\r\n            i = k + self.Nb_of_PYR_Stimulated\r\n            Vdi = np.zeros((len(Vs_d[i, :]), 3))\r\n            Vdi[:, 2] = Vs_d[i, :]\r\n            Vm = np.sum(Vdi * U[i, :], axis=1)\r\n            Vm = Vm / (4. * self.sigma * 1e-3 * np.pi * Distance_from_electrode[i] * Distance_from_electrode[i])\r\n            Vm = Vm * (self.dendriteSize + self.somaSize) / 2. * self.gc * Stotal\r\n            self.LFP += Vm * 1e3\r\n        return self.LFP\r\n\r\n\r\n    def get_PYR_Variables(self):\r\n        return PC_neo3.get_Variable_Names()\r\n\r\n    def get_PV_Variables(self):\r\n        return PV_neo.get_Variable_Names()\r\n\r\n    def get_SST_Variables(self):\r\n        return SST_neo.get_Variable_Names()\r\n\r\n    def get_VIP_Variables(self):\r\n        return VIP_neo.get_Variable_Names()\r\n\r\n    def get_RLN_Variables(self):\r\n        return RLN_neo.get_Variable_Names()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CorticalColumn.py b/CorticalColumn.py
--- a/CorticalColumn.py	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ b/CorticalColumn.py	(date 1653056469350)
@@ -78,18 +78,10 @@
     ('PreSynaptic_Soma_GABA_a', types.List(typeof(np.array([], dtype=np.int32)))),
     ('ExternalPreSynaptic_Cell_AMPA_DPYR'   , types.List(typeof(np.array([], dtype=np.int32)))),
     ('ExternalPreSynaptic_Cell_AMPA_Th'     , types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticWeight_AMPA'               , types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_AMPA1', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_AMPA2', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_AMPA3', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_AMPA4', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_AMPA5', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticWeight_GABA'               , types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_GABA1'               , types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_GABA2', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_GABA3', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_GABA4', types.List(typeof(np.array([], dtype=np.int32)))),
-    ('PreSynapticPos_GABA5', types.List(typeof(np.array([], dtype=np.int32)))),
+    ('PreSynapticWeight_AMPA'               , types.List(typeof(np.array([], dtype=np.float64)))),
+    ('PreSynapticPos_AMPA', types.List(typeof(np.array([], dtype=np.int32)))),
+    ('PreSynapticWeight_GABA'               , types.List(typeof(np.array([], dtype=np.float64)))),
+    ('PreSynapticPos_GABA'               , types.List(typeof(np.array([], dtype=np.int32)))),
 
 ]
 
@@ -105,17 +97,9 @@
                  ExternalPreSynaptic_Cell_AMPA_DPYR,
                  ExternalPreSynaptic_Cell_AMPA_Th,
                  PreSynapticWeight_AMPA,
-                 PreSynapticPos_AMPA1,
-                 PreSynapticPos_AMPA2,
-                 PreSynapticPos_AMPA3,
-                 PreSynapticPos_AMPA4,
-                 PreSynapticPos_AMPA5,
+                 PreSynapticPos_AMPA,
                  PreSynapticWeight_GABA,
-                 PreSynapticPos_GABA1,
-                 PreSynapticPos_GABA2,
-                 PreSynapticPos_GABA3,
-                 PreSynapticPos_GABA4,
-                 PreSynapticPos_GABA5):
+                 PreSynapticPos_GABA):
         self.PreSynaptic_Cell_AMPA = PreSynaptic_Cell_AMPA
         self.PreSynaptic_Cell_GABA = PreSynaptic_Cell_GABA
         self.PreSynaptic_Soma_AMPA = PreSynaptic_Soma_AMPA
@@ -125,17 +109,9 @@
         self.ExternalPreSynaptic_Cell_AMPA_DPYR =ExternalPreSynaptic_Cell_AMPA_DPYR
         self.ExternalPreSynaptic_Cell_AMPA_Th = ExternalPreSynaptic_Cell_AMPA_Th
         self.PreSynapticWeight_AMPA = PreSynapticWeight_AMPA
-        self.PreSynapticPos_AMPA1 = PreSynapticPos_AMPA1
-        self.PreSynapticPos_AMPA2 = PreSynapticPos_AMPA2
-        self.PreSynapticPos_AMPA3 = PreSynapticPos_AMPA3
-        self.PreSynapticPos_AMPA4 = PreSynapticPos_AMPA4
-        self.PreSynapticPos_AMPA5 = PreSynapticPos_AMPA5
+        self.PreSynapticPos_AMPA = PreSynapticPos_AMPA
         self.PreSynapticWeight_GABA = PreSynapticWeight_GABA
-        self.PreSynapticPos_GABA1 = PreSynapticPos_GABA1
-        self.PreSynapticPos_GABA2 = PreSynapticPos_GABA2
-        self.PreSynapticPos_GABA3 = PreSynapticPos_GABA3
-        self.PreSynapticPos_GABA4 = PreSynapticPos_GABA4
-        self.PreSynapticPos_GABA5 = PreSynapticPos_GABA5
+        self.PreSynapticPos_GABA = PreSynapticPos_GABA
 
 
 @njit
@@ -300,33 +276,21 @@
 
 #                    pyrPPSE_d[curr_pyr, tt] = (np.sum(I_AMPA) + np.sum(I_NMDA)) / List_PYR[neurone].Cm_d
                     x=I_AMPA + I_NMDA
-                    print(PS.PreSynapticPos_AMPA)
-                    #print(np.argwhere(PS.PreSynapticPos_AMPA == 5))
 
-                    if len(PS.PreSynapticPos_AMPA5)==0:
-                        pyrPPSE_d1[curr_pyr, tt] =0
-                    else:
-                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA5]) / List_PYR[neurone].Cm_d
+                    c = np.argwhere(PS.PreSynapticPos_AMPA[i]==5).flatten()
+                    pyrPPSE_d1[curr_pyr, tt] = np.sum(x[c])/ List_PYR[neurone].Cm_d
 
-                    if len(PS.PreSynapticPos_AMPA4)==0:
-                        pyrPPSE_d23[curr_pyr, tt] =0
-                    else:
-                        pyrPPSE_d23[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA4]) / List_PYR[neurone].Cm_d
+                    c = np.argwhere(PS.PreSynapticPos_AMPA[i]==4).flatten()
+                    pyrPPSE_d23[curr_pyr, tt] = np.sum(x[c])/ List_PYR[neurone].Cm_d
 
-                    if len(PS.PreSynapticPos_AMPA3)==0:
-                        pyrPPSE_d1[curr_pyr, tt] =0
-                    else:
-                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA3]) / List_PYR[neurone].Cm_d
+                    c = np.argwhere(PS.PreSynapticPos_AMPA[i]==3).flatten()
+                    pyrPPSE_d4[curr_pyr, tt] = np.sum(x[c])/ List_PYR[neurone].Cm_d
 
-                    if len(PS.PreSynapticPos_AMPA2)==0:
-                        pyrPPSE_d1[curr_pyr, tt] =0
-                    else:
-                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA2]) / List_PYR[neurone].Cm_d
+                    c = np.argwhere(PS.PreSynapticPos_AMPA[i]==2).flatten()
+                    pyrPPSE_d5[curr_pyr, tt] = np.sum(x[c])/ List_PYR[neurone].Cm_d
 
-                    if len(PS.PreSynapticPos_AMPA1)==0:
-                        pyrPPSE_d1[curr_pyr, tt] =0
-                    else:
-                        pyrPPSE_d1[curr_pyr, tt] = np.sum(x[PS.PreSynapticPos_AMPA1]) / List_PYR[neurone].Cm_d
+                    c = np.argwhere(PS.PreSynapticPos_AMPA[i]==1).flatten()
+                    pyrPPSE_d6[curr_pyr, tt] = np.sum(x[c])/ List_PYR[neurone].Cm_d
 
 
                 elif typeS[i] == 1:  # PV
@@ -390,13 +354,22 @@
 ###################################Add presynaptic currents per layer for dendrites#################
                     x=I_GABA * PS.PreSynaptic_Soma_GABA_d[i]
 
+                    x = I_AMPA + I_NMDA
+
+                    c = np.argwhere(PS.PreSynapticPos_GABA[i] == 5).flatten()
+                    pyrPPSI_d1[curr_pyr, tt] = np.sum(x[c]) / List_PYR[neurone].Cm_d
 
-                    pyrPPSI_d1[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==5)]) / List_PYR[neurone].Cm_d
-                    pyrPPSI_d23[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==4)]) / List_PYR[neurone].Cm_d
-                    pyrPPSI_d4[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==3)]) / List_PYR[neurone].Cm_d
-                    pyrPPSI_d5[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==2)]) / List_PYR[neurone].Cm_d
-                    pyrPPSI_d6[curr_pyr, tt] = np.sum(x[np.argwhere(PS.PreSynapticPos_GABA==1)]) / List_PYR[neurone].Cm_d
+                    c = np.argwhere(PS.PreSynapticPos_GABA[i] == 4).flatten()
+                    pyrPPSI_d23[curr_pyr, tt] = np.sum(x[c]) / List_PYR[neurone].Cm_d
 
+                    c = np.argwhere(PS.PreSynapticPos_GABA[i] == 3).flatten()
+                    pyrPPSI_d4[curr_pyr, tt] = np.sum(x[c]) / List_PYR[neurone].Cm_d
+
+                    c = np.argwhere(PS.PreSynapticPos_GABA[i] == 2).flatten()
+                    pyrPPSI_d5[curr_pyr, tt] = np.sum(x[c]) / List_PYR[neurone].Cm_d
+
+                    c = np.argwhere(PS.PreSynapticPos_GABA[i] == 1).flatten()
+                    pyrPPSI_d6[curr_pyr, tt] = np.sum(x[c]) / List_PYR[neurone].Cm_d
 
 
                     pyrPPSI_s[curr_pyr, tt] = np.sum(I_GABA*PS.PreSynaptic_Soma_GABA_s[i]) / List_PYR[neurone].Cm
@@ -1159,7 +1132,7 @@
         cm = np.zeros(nbcells, dtype=int)  # []
         dist = np.zeros(nbcells, dtype=float)  # []
         Weight = np.zeros(nbcells, dtype=float)  # []
-        Zpos = np.zeros(nbcells, dtype=float)  # []
+        Zpos = np.zeros(nbcells, dtype=np.int32)  # []
 
         AMPAcells = np.zeros(nbcells, dtype=int) - 1  # []
         GABAcells = np.zeros(nbcells, dtype=int) - 1  # []
@@ -1275,8 +1248,8 @@
                                 else:
                                     Layerconn=np.argwhere(np.sort(np.concatenate((self.Layertop_pos,np.array([ConnPos])),axis=0))==ConnPos) #1--> layer 6,5 layer I
                                     Layerconn =Layerconn[0][0] + 1
-                                    if ConnPos < self.Cellpos[l][cell][2]: #if connection below soma center
-                                        Layerconn=-1*Layerconn
+                                    # if ConnPos < self.Cellpos[l][cell][2]: #if connection below soma center
+                                    #     Layerconn=-1*Layerconn
 
 
 
@@ -1594,6 +1567,8 @@
         overlap = 0.0
         DendConn = 0
         ConnPos = []
+
+
         if Source.type in [0, 3, 4]:  # PC/ VIP or RLN
             S_Z0 = Sourcepos[2] + Source.AX_down # lower threshold
             S_Z1 = Sourcepos[2] + Source.AX_up  # upper threshold
@@ -2198,19 +2173,10 @@
             [np.array(l, dtype=np.int32) for l in self.PreSynaptic_Soma_GABA_a],
             [np.array(l, dtype=np.int32) for l in self.ExternalPreSynaptic_Cell_AMPA_DPYR],
             [np.array(l, dtype=np.int32) for l in self.ExternalPreSynaptic_Cell_AMPA_Th],
-            [np.array(l, dtype=np.int32) for l in self.PreSynapticWeight_AMPA],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==1)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==2)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==3)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==4)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_AMPA==5)],
-            [np.array(l, dtype=np.int32) for l in self.PreSynapticWeight_GABA],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==1)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==2)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==3)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==4)],
-            [np.array(l, dtype=np.int32) for l in np.argwhere(self.PreSynapticPos_GABA==5)],
-
+            [np.array(l, dtype=np.float64) for l in self.PreSynapticWeight_AMPA],
+            [np.array(l, dtype=np.int32) for l in self.PreSynapticPos_AMPA],
+            [np.array(l, dtype=np.float64) for l in self.PreSynapticWeight_GABA],
+            [np.array(l, dtype=np.int32) for l in self.PreSynapticPos_GABA]
         )
 
         self.List_DPYR = []
Index: GUI.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>__author__ = 'Maxime'\r\n# -*- coding: utf-8 -*-\r\n\r\nfrom PyQt5.QtGui import *\r\nfrom PyQt5.QtCore import *\r\nfrom PyQt5.QtWidgets import *\r\nimport os\r\nimport sys\r\nimport matplotlib\r\nimport numpy as np\r\nfrom scipy.spatial import distance\r\nfrom scipy import sparse\r\nfrom scipy.fft import fftshift\r\nimport pickle\r\nimport time\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.patches as patches\r\nimport inspect\r\nimport copy\r\nimport subprocess\r\nimport struct\r\nimport random\r\nimport csv\r\nmatplotlib.use('Qt5Agg')\r\nfrom matplotlib.figure import Figure\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\r\nfrom matplotlib.ticker import MultipleLocator\r\nfrom scipy import signal\r\nimport scipy.io\r\n# import pyedflib\r\nimport datetime\r\nimport scipy.io as sio\r\nfrom EEGViewer import lfpViewer_EEG\r\nfrom Modify_Each_NMM_param import Modify_1_NMM\r\n# from Modify_X_NMM_at_once import Modify_X_NMM\r\nfrom Modify_X_NMM_VTK import Modify_X_NMM\r\nfrom numba import guvectorize, float64, int64, njit\r\nfrom Graph_viewer3D_VTK5 import Graph_viewer3D_VTK\r\nfrom Graph_EField_VTK import Graph_EField_VTK\r\nfrom scipy.optimize import curve_fit\r\nimport RecordedPotential\r\nimport Electrode\r\nimport platform\r\nimport Cell_morphology\r\n\r\nif platform.system() == \"Windows\":\r\n    pass\r\nelif platform.system() == \"Darwin\":\r\n    matplotlib.rcParams.update({'font.size': 6})\r\nelif platform.system() == \"Linux\":\r\n    pass\r\n\r\n\r\ndef peakdet(v, delta, x=None):\r\n    maxtab = []\r\n    mintab = []\r\n\r\n    if x is None:\r\n        x = np.arange(len(v))\r\n\r\n    v = np.asarray(v)\r\n\r\n    if len(v) != len(x):\r\n        sys.exit('Input vectors v and x must have same length')\r\n\r\n    if not np.isscalar(delta):\r\n        sys.exit('Input argument delta must be a scalar')\r\n\r\n    if delta <= 0:\r\n        sys.exit('Input argument delta must be positive')\r\n\r\n    mn, mx = np.Inf, -np.Inf\r\n    mnpos, mxpos = np.NaN, np.NaN\r\n\r\n    lookformax = True\r\n\r\n    for i in np.arange(len(v)):\r\n        this = v[i]\r\n        if this > mx:\r\n            mx = this\r\n            mxpos = x[i]\r\n        if this < mn:\r\n            mn = this\r\n            mnpos = x[i]\r\n\r\n        if lookformax:\r\n            if this < mx - delta:\r\n                maxtab.append((mxpos, mx))\r\n                mn = this\r\n                mnpos = x[i]\r\n                lookformax = False\r\n        else:\r\n            if this > mn + delta:\r\n                mintab.append((mnpos, mn))\r\n                mx = this\r\n                mxpos = x[i]\r\n                lookformax = True\r\n\r\n    return np.array(maxtab), np.array(mintab)\r\n\r\n@guvectorize([\"float64[:,:],int64, int64, float64, float64, int64, float64, int64, int64, float64, float64[:,:]\"], '(n,m),(),(),(),(),(),(),(),(),()->(n,m)')\r\ndef Generate_Stim_Signals(Stim_Signals_in, seed, nbOfSamplesStim, i_inj, tau, nbStim, varianceStim, nb_Stim_Signals, nbEch, dt,Stim_Signals_out):\r\n    n = int(1. * nbEch / 2.)\r\n    t = np.arange(nbEch) * dt\r\n\r\n    if not seed == 0:\r\n        np.random.seed(seed)\r\n    # else:\r\n    #     np.random.seed()\r\n    for St in range(nb_Stim_Signals):\r\n        y2 = np.zeros(nbEch)\r\n        for i in range(nbStim):\r\n\r\n            y = np.zeros(t.shape)\r\n\r\n            intervalle_dt = int(np.round((np.random.normal(0, varianceStim))))\r\n\r\n            if ((n + intervalle_dt) < 0):\r\n                intervalle_dt = -n\r\n            if ((n + intervalle_dt + nbOfSamplesStim) > nbEch):\r\n                intervalle_dt = nbEch - n - nbOfSamplesStim - 1\r\n\r\n            for tt, tp in enumerate(t):\r\n                if (tt > (n + intervalle_dt)):\r\n                    y[tt] = (1. - np.exp(-(tp - (n + intervalle_dt) * dt) / tau)) * i_inj\r\n                if (tt > (n + intervalle_dt + nbOfSamplesStim)):\r\n                    y[tt] = (np.exp(-(tp - ((n + intervalle_dt) + nbOfSamplesStim) * dt) / tau)) * y[n + intervalle_dt + nbOfSamplesStim - 1]\r\n\r\n                y2[tt] += y[tt]\r\n\r\n        Stim_Signals_out[St,:]=y2\r\n    # return Stim_Signals\r\n\r\n@guvectorize([\"int64[:], int64, int64, int64, int64[:]\"], '(n),(),(),()->(n)')\r\ndef pickcell_simple_fun(size, loop,low, high,pickedcell):\r\n    while loop > 0:\r\n        # cell = np.random.randint(low, high, size=1)\r\n        cell = np.random.randint(low, high)\r\n        if cell in pickedcell:\r\n            pass\r\n        else:\r\n            pickedcell[loop-1] = cell\r\n            loop -= 1\r\n\r\n@guvectorize([\"int64[:], int64, float64, float64, float64[:], int64[:], int64[:]\"], '(n),(),(),(),(m),(k)->(n)')\r\ndef pickcell_gauss_fun(size, loop, mean, var, CellDistances, sortedIndex, pickedcell):\r\n    while loop>0:\r\n        l = abs(np.random.normal(mean, var))\r\n        cellInd = np.where(CellDistances[sortedIndex]>=l)[0]\r\n        if cellInd.size == 0:\r\n            continue\r\n        else:\r\n            cellInd = cellInd[0]\r\n        cell = sortedIndex[cellInd]\r\n        if not cell in pickedcell :\r\n            pickedcell[loop-1] = cell\r\n            sortedIndex= np.delete(sortedIndex, cellInd)\r\n            loop -= 1\r\n\r\n\r\n@guvectorize([\"float64[:], int64, int64[:]\"], '(n),()->(n)')\r\ndef argsort_list_fun(CellDistances, plus, sortedIndex):\r\n    sortedIndex = np.argsort(CellDistances) + plus\r\n\r\n\r\nclass LineEdit(QLineEdit):\r\n    KEY = Qt.Key_Return\r\n    def __init__(self, *args, **kwargs):\r\n        QLineEdit.__init__(self, *args, **kwargs)\r\n        QREV = QRegExpValidator(QRegExp(\"[+-]?\\\\d*[\\\\.]?\\\\d+\"))\r\n        QREV.setLocale(QLocale(QLocale.English))\r\n        self.setValidator(QREV)\r\n\r\n\r\nclass LineEdit_Int(QLineEdit):\r\n    KEY = Qt.Key_Return\r\n    def __init__(self, *args, **kwargs):\r\n        QLineEdit.__init__(self, *args, **kwargs)\r\n        QREV = QRegExpValidator(QRegExp(\"[+-]?\\\\d+\"))\r\n        QREV.setLocale(QLocale(QLocale.English))\r\n        self.setValidator(QREV)\r\n\r\n\r\ndef set_QPushButton_background_color(button=None, color=None):\r\n    if color==None or button==None :\r\n        return\r\n    else :\r\n        button.setAutoFillBackground(True)\r\n        values = \"{r}, {g}, {b} \".format(r = color.red(),\r\n                                     g = color.green(),\r\n                                     b = color.blue())\r\n        button.setStyleSheet(\"QPushButton { background-color: rgb(\"+values+\"); }\")\r\n\r\ndef label_color_clicked(event,button):\r\n    color = QColor(button.palette().button().color())\r\n    colordial = QColorDialog(color)\r\n    colordial.exec_()\r\n    selectedcolor = colordial.currentColor()\r\n    colordial.close()\r\n    set_QPushButton_background_color(button,selectedcolor)\r\n    pass\r\n\r\ndef Layout_grid_Label_Edit(label = ['None'],edit =['None']):\r\n    widget = QWidget()\r\n    layout_range = QVBoxLayout()\r\n    # layout_range.setContentsMargins(5,5,5,5)\r\n\r\n    grid = QGridLayout()\r\n    grid.setContentsMargins(5,5,5,5)\r\n    widget.setLayout(grid)\r\n    layout_range.addLayout(grid)\r\n    Edit_List =[]\r\n    for idx in range(len(label)):\r\n        Label = QLabel(label[idx])\r\n        Edit = LineEdit(edit[idx])\r\n        grid.addWidget(Label, idx, 0)\r\n        grid.addWidget(Edit, idx, 1)\r\n        Edit_List.append(Edit)\r\n    return widget, Edit_List\r\n\r\n\r\n\r\n\r\nclass Colonne_cortical_Thread(QThread):\r\n    finished = pyqtSignal()\r\n    updateTime = pyqtSignal(float)\r\n\r\n    def __init__(self,CortexClass):\r\n        QThread.__init__(self )\r\n        self.CC = CortexClass()\r\n\r\n        self.percent = 0.\r\n        self.T = 0\r\n        self.dt  = 0\r\n        self.Stim_Signals = []\r\n\r\n    @pyqtSlot(float)\r\n    def updatePercent(self, pourcent):\r\n        self.percent = pourcent\r\n        self.updateTime.emit(self.percent)\r\n\r\n    def __del__(self):\r\n        self.wait()\r\n\r\n    def get_percentage(self):\r\n        return self.percent\r\n\r\n    def run(self):\r\n        self.t, self.pyrVs,self.pyrVd,self.olmVs,self.basketVs,self.BisVs= self.CC.Simulate(self.T, self.dt, self.Stim_Signals)\r\n\r\n        self.finished.emit()\r\n\r\n    def arret(self):\r\n        self.C.Stop = False\r\n\r\n\r\nclass ModelMicro_GUI(QMainWindow):\r\n    def __init__(self, parent=None):\r\n        super(ModelMicro_GUI, self).__init__()\r\n        self.parent = parent\r\n\r\n        if getattr(sys, 'frozen', False):\r\n            self.application_path = os.path.dirname(sys.executable)\r\n        elif __file__:\r\n            self.application_path = os.path.dirname(__file__)\r\n        sys.path.append(self.application_path)\r\n\r\n        # (filepath, filename) = os.path.split(os.path.abspath('Modeles/Wendling/Colonne_cortical_Wendling'))\r\n        # sys.path.append(filepath)\r\n        # (shortname, extension) = os.path.splitext(filename)\r\n        # self.Colonne_class = __import__(shortname)\r\n        # self.Colonne = getattr(self.Colonne_class, 'Colonne_cortical')\r\n\r\n        from CorticalColumn import CorticalColumn\r\n        self.Colonne = CorticalColumn\r\n        self.Colonne_cortical_Thread = Colonne_cortical_Thread(self.Colonne)\r\n        self.CC = self.Colonne_cortical_Thread.CC\r\n        self.CC.updateTime.something_happened.connect(self.updateTime)\r\n\r\n\r\n        self.dt = 1/25\r\n        self.T = 200\r\n        self.nbEch = int(self.T / self.dt)\r\n\r\n        self.Nb_of_PYR = 0\r\n        self.Nb_of_BAS = 0\r\n        self.Nb_of_SOM = 0\r\n        self.Nb_of_BIS = 0\r\n        self.List_PYR_Stimulated = []\r\n\r\n        self.x = 0.\r\n        self.y = 0.\r\n        self.z = 0.\r\n\r\n        self.electrode_pos = [0.,0.,2082.]\r\n\r\n        self.createCells = True\r\n\r\n        self.list_neurone_color= [   QColor(Qt.darkRed).name(), #pyramid\r\n                                     QColor(Qt.darkGreen).name(),# BAS\r\n                                     QColor(Qt.darkBlue).name(), #OLM\r\n                                     QColor(Qt.darkYellow).name(), #BIS\r\n                                     QColor(\"#ffa500\").name(), #stim\r\n                                     QColor(Qt.white).name(), #electrode\r\n\r\n                                     ]\r\n\r\n\r\n        # some variable for widget's length\r\n        self.Qbox_H = 30\r\n        self.Qbox_W = 60\r\n        self.Qedit_H = 30\r\n        self.Qedit_W = 60\r\n\r\n        self.centralWidget = QWidget()\r\n        self.setCentralWidget(self.centralWidget)\r\n        #### global layout\r\n        self.mainHBOX = QHBoxLayout()\r\n        self.setmarginandspacing(self.mainHBOX)\r\n        ###\r\n\r\n        wid_Param_VBOX = QWidget()\r\n        self.Param_VBOX = QVBoxLayout()\r\n        self.Param_VBOX.setAlignment(Qt.AlignTop)\r\n        wid_Param_VBOX.setLayout(self.Param_VBOX)\r\n        # wid_Param_VBOX.setMaximumWidth(300)\r\n        self.setmarginandspacing(self.Param_VBOX)\r\n\r\n        # call column layout\r\n        self.set_Param_VBOX()\r\n\r\n        self.Vsplitter_middle = QSplitter(Qt.Vertical)\r\n        self.mascene_EEGViewer = lfpViewer_EEG()\r\n        self.mascene_LFPViewer = LFPViewer(self)\r\n        self.Vsplitter_middle.addWidget(self.mascene_EEGViewer)\r\n        self.Vsplitter_middle.addWidget(self.mascene_LFPViewer)\r\n        self.Vsplitter_middle.setStretchFactor(4, 0)\r\n        self.Vsplitter_middle.setStretchFactor(1, 0)\r\n        self.Vsplitter_middle.setSizes([1500,int(1500/4)])\r\n\r\n        self.Vsplitter = QSplitter(Qt.Vertical)\r\n\r\n        self.GraphWidget = QWidget()\r\n        self.GraphLayout = QVBoxLayout()\r\n        self.Graph_viewer = Graph_viewer3D_VTK(self)\r\n        self.GraphinfoLayout = QHBoxLayout()\r\n        labelr, r_e = Layout_grid_Label_Edit(label=['r'], edit=['50'])\r\n        labell, l_e = Layout_grid_Label_Edit(label=['line'], edit=['5'])\r\n        labels, s_e = Layout_grid_Label_Edit(label=['scale'], edit=['50'])\r\n        self.r_e = r_e[0]\r\n        self.l_e = l_e[0]\r\n        self.s_e = s_e[0]\r\n        self.RedrawVTK_PB = QPushButton('Redraw')\r\n        self.GraphinfoLayout.addWidget(labelr)\r\n        self.GraphinfoLayout.addWidget(self.r_e)\r\n        self.GraphinfoLayout.addWidget(labell)\r\n        self.GraphinfoLayout.addWidget(self.l_e)\r\n        self.GraphinfoLayout.addWidget(labels)\r\n        self.GraphinfoLayout.addWidget(self.s_e)\r\n        self.GraphinfoLayout.addWidget(self.RedrawVTK_PB)\r\n        self.GraphLayout.addLayout(self.GraphinfoLayout)\r\n        self.GraphLayout.addWidget(self.Graph_viewer)\r\n        self.GraphWidget.setLayout(self.GraphLayout)\r\n        self.r_e.editingFinished.connect(self.updateVTKinfo)\r\n        self.l_e.editingFinished.connect(self.updateVTKinfo)\r\n        self.s_e.editingFinished.connect(self.updateVTKinfo)\r\n        self.RedrawVTK_PB.clicked.connect(self.Graph_viewer.draw_Graph)\r\n\r\n        self.masceneCM = CMViewer(self)\r\n        self.VStimWidget = QWidget()\r\n        self.VStimLayout = QVBoxLayout()\r\n        self.masceneStim = StimViewer(self)\r\n        self.DisplayStim_PB = QPushButton('DisplayStim')\r\n        self.DisplayStim_PB.clicked.connect(self.DisplayStim_func)\r\n        self.VStimLayout.addWidget(self.DisplayStim_PB)\r\n        self.VStimLayout.addWidget(self.masceneStim)\r\n        self.VStimWidget.setLayout(self.VStimLayout)\r\n        self.Vsplitter.addWidget(self.GraphWidget)\r\n        self.Vsplitter.addWidget(self.masceneCM)\r\n        self.Vsplitter.addWidget(self.VStimWidget)\r\n        self.Vsplitter.setStretchFactor(0, 0)\r\n        self.Vsplitter.setStretchFactor(1, 0)\r\n        self.Vsplitter.setStretchFactor(2, 0)\r\n        self.Vsplitter.setStretchFactor(3, 0)\r\n        self.Vsplitter.setSizes([1500,1500,1500,1500])\r\n\r\n        ### add  vectical global splitters\r\n        self.mainsplitter = QSplitter(Qt.Horizontal)\r\n\r\n        scroll = QScrollArea()\r\n        scroll.setFrameShape(QFrame.NoFrame)\r\n        widget = QWidget()\r\n        widget.setLayout(QHBoxLayout())\r\n        widget.layout().addWidget(wid_Param_VBOX)\r\n        wid_Param_VBOX.setFixedWidth(400)\r\n        scroll.setWidget(widget)\r\n        # scroll.setWidgetResizable(True)\r\n        scroll.setFixedWidth(400 + 24)\r\n        scroll.setAlignment(Qt.AlignTop)\r\n        self.mainsplitter.addWidget(scroll)\r\n\r\n        self.mainsplitter.addWidget(self.Vsplitter_middle)\r\n        self.mainsplitter.addWidget(self.Vsplitter)\r\n        self.mainsplitter.setStretchFactor(0, 1)\r\n        self.mainsplitter.setStretchFactor(1, 3)\r\n        self.mainsplitter.setStretchFactor(2, 1)\r\n        self.mainsplitter.setSizes([400, 1500 * 3, 1500])\r\n\r\n        self.mainHBOX.addWidget(self.mainsplitter)\r\n\r\n        self.centralWidget.setLayout(self.mainHBOX)\r\n\r\n        # Menu\r\n        # set actions\r\n        extractLoad_Model = QAction(\"Load Model\", self)\r\n        extractLoad_Model.triggered.connect(self.LoadModel)\r\n\r\n        extractLoad_Simul = QAction(\"Load Simulation\", self)\r\n        extractSave_Simul = QAction(\"Save Simulation\", self)\r\n        extractLoad_Simul.triggered.connect(self.LoadSimul)\r\n        extractSave_Simul.triggered.connect(self.SaveSimul)\r\n\r\n        extractLoad_Res = QAction(\"Load Results\", self)\r\n        extractSave_Res = QAction(\"Save Results\", self)\r\n        # extractLoad_Res.triggered.connect(self.LoadRes)\r\n        extractSave_Res.triggered.connect(self.SaveRes)\r\n\r\n        menubar = self.menuBar()\r\n        menubar.setNativeMenuBar(False)\r\n        fileLoad = menubar.addMenu('&Load/Save')\r\n        fileLoad.addAction(extractLoad_Model)\r\n        fileLoad.addSeparator()\r\n        fileLoad.addAction(extractLoad_Simul)\r\n        fileLoad.addAction(extractSave_Simul)\r\n        fileLoad.addSeparator()\r\n        # fileLoad.addAction(extractLoad_Res)\r\n        fileLoad.addAction(extractSave_Res)\r\n\r\n        self.NewModify1NMM = None\r\n        self.NewModifyXNMM = None\r\n        self.selected_cells = []\r\n\r\n        # self.update_cellNnumber()\r\n\r\n    def updateVTKinfo(self):\r\n        self.Graph_viewer.LinewidthfromGUI = float(self.l_e.text())\r\n        self.Graph_viewer.radiuswidthfromGUI = float(self.r_e.text())\r\n        self.Graph_viewer.setScales(float(self.s_e.text()))\r\n\r\n    @pyqtSlot(float)\r\n    def updateTime(self, pourcent):\r\n        ts = time.time() - self.t0\r\n        tf = ts / (pourcent + 0.00000001)\r\n        tr = tf - ts\r\n        self.msg.setText(\"Computation in progress\\nPlease wait.\\nTime spend : \" + str(datetime.timedelta(seconds=int(ts))) + \"\\nTime remaining : \" + str(datetime.timedelta(seconds=int(tr))))\r\n        self.parent.processEvents()\r\n\r\n    def DisplayStim_func(self):\r\n        # self.Generate_Stim_Signals()\r\n        self.masceneStim.update(self.CC.Stim_Signals,self.CC.Stim_InputSignals)\r\n\r\n    def set_Param_VBOX(self):\r\n        #tissue size\r\n        self.tissue_size_GB = QGroupBox(r'tissue information')\r\n        labelD, D_e = Layout_grid_Label_Edit(label=['cylinder diameter / Square XY length / Rectangle X length (m)'], edit=[str(self.CC.D)])\r\n        labelL, L_e = Layout_grid_Label_Edit(label=['cylinder length / /Rectangle Y length (m)'], edit=[str(self.CC.L)])\r\n        labelCourbure, Courbure_e = Layout_grid_Label_Edit(label=['Distance for curvature'],\r\n                                             edit=[str(2000)])\r\n        self.D_e = D_e[0]\r\n        self.L_e = L_e[0]\r\n        self.C_e = Courbure_e[0]\r\n\r\n        self.Layer_d1_l = LineEdit_Int(str(self.CC.Layer_d[0]))\r\n        self.Layer_d23_l = LineEdit_Int(str(self.CC.Layer_d[1]))\r\n        self.Layer_d4_l = LineEdit_Int(str(self.CC.Layer_d[2]))\r\n        self.Layer_d5_l = LineEdit_Int(str(self.CC.Layer_d[3]))\r\n        self.Layer_d6_l = LineEdit_Int(str(self.CC.Layer_d[4]))\r\n\r\n        self.Apply_tissue_PB = QPushButton('Apply Tissue update')\r\n        # grid = QGridLayout()\r\n\r\n        labelDensity1 = QLabel('Density')\r\n        labelDensity2 = QLabel(r'Neuron/mm<sup>3</sup>')\r\n        self.Density_e = LineEdit('3954334')\r\n        labelnbcell = QLabel('Nb cells')\r\n        self.nbcell_e = LineEdit_Int('1000')\r\n\r\n        self.get_XYZ_PB = QPushButton('Get XYZ')\r\n        self.get_Density_PB = QPushButton('Get Density')\r\n        self.get_nbcell_PB = QPushButton('Get Nb cells')\r\n        line = 0\r\n        grid = QGridLayout()\r\n        # grid.setContentsMargins(0,0,0,0)\r\n        # grid.setSpacing(0)\r\n        grid.addWidget(labelD, line, 0, 1, 4)\r\n        grid.addWidget(self.D_e, line, 4)\r\n        line += 1\r\n        grid.addWidget(labelL, line, 0, 1, 4)\r\n        grid.addWidget(self.L_e, line, 4)\r\n        line += 1\r\n        grid.addWidget(labelCourbure, line, 0, 1, 4)\r\n        grid.addWidget(self.C_e, line, 4)\r\n\r\n        line += 1\r\n        grid.addWidget(QLabel('thick 1'), line, 0)\r\n        grid.addWidget(QLabel('thick 2/3'), line, 1)\r\n        grid.addWidget(QLabel('thick 4'), line, 2)\r\n        grid.addWidget(QLabel('thick 5'), line, 3)\r\n        grid.addWidget(QLabel('thick 6'), line, 4)\r\n\r\n        line += 1\r\n        grid.addWidget(self.Layer_d1_l, line, 0)\r\n        grid.addWidget(self.Layer_d23_l, line, 1)\r\n        grid.addWidget(self.Layer_d4_l, line, 2)\r\n        grid.addWidget(self.Layer_d5_l, line, 3)\r\n        grid.addWidget(self.Layer_d6_l, line, 4)\r\n\r\n        line += 1\r\n        grid.addWidget(self.Apply_tissue_PB, line, 1, 1, 3)\r\n\r\n        self.Apply_tissue_PB.clicked.connect(self.set_tissue_func)\r\n\r\n        self.tissue_size_GB.setLayout(grid)\r\n\r\n        # %tage\r\n        self.pourcentageCell_GB = QGroupBox(r'% de cell')\r\n        labelnb1 = QLabel('nb cells 1')\r\n        labelnb23 = QLabel('nb cells 2/3')\r\n        labelnb4 = QLabel('nb cells 4')\r\n        labelnb5 = QLabel('nb cells 5')\r\n        labelnb6 = QLabel('nb cells 6')\r\n        labelnbtotal = QLabel('nb total')\r\n        self.nbcellsnb1 = LineEdit_Int(str(int(self.CC.Layer_nbCells[0])))\r\n        self.nbcellsnb23 = LineEdit_Int(str(int(self.CC.Layer_nbCells[1])))\r\n        self.nbcellsnb4 = LineEdit_Int(str(int(self.CC.Layer_nbCells[2])))\r\n        self.nbcellsnb5 = LineEdit_Int(str(int(self.CC.Layer_nbCells[3])))\r\n        self.nbcellsnb6 = LineEdit_Int(str(int(self.CC.Layer_nbCells[4])))\r\n        self.nbcellsnbtotal = LineEdit_Int(str(int(np.sum(self.CC.Layer_nbCells))))\r\n\r\n        self.nbcellsnb1.returnPressed.connect(lambda s='1': self.Nb_Cell_Changed(s))\r\n        self.nbcellsnb23.returnPressed.connect(lambda s='23': self.Nb_Cell_Changed(s))\r\n        self.nbcellsnb4.returnPressed.connect(lambda s='4': self.Nb_Cell_Changed(s))\r\n        self.nbcellsnb5.returnPressed.connect(lambda s='5': self.Nb_Cell_Changed(s))\r\n        self.nbcellsnb6.returnPressed.connect(lambda s='6': self.Nb_Cell_Changed(s))\r\n        self.nbcellsnbtotal.returnPressed.connect(lambda s='total': self.Nb_Cell_Changed(s))\r\n\r\n        grid = QGridLayout()\r\n        grid.setContentsMargins(5, 5, 5, 5)\r\n        grid.addWidget(labelnb1, 0, 0)\r\n        grid.addWidget(labelnb23, 0, 1)\r\n        grid.addWidget(labelnb4, 0, 2)\r\n        grid.addWidget(labelnb5, 0, 3)\r\n        grid.addWidget(labelnb6, 0, 4)\r\n        grid.addWidget(labelnbtotal, 0, 5)\r\n        grid.addWidget(self.nbcellsnb1, 1, 0)\r\n        grid.addWidget(self.nbcellsnb23, 1, 1)\r\n        grid.addWidget(self.nbcellsnb4, 1, 2)\r\n        grid.addWidget(self.nbcellsnb5, 1, 3)\r\n        grid.addWidget(self.nbcellsnb6, 1, 4)\r\n        grid.addWidget(self.nbcellsnbtotal, 1, 5)\r\n        self.pourcentageCell_GB.setLayout(grid)\r\n\r\n        # nbconnexion\r\n        label_source = QLabel('Layer')\r\n        label_PYR = QLabel('PYR')\r\n        label_PV = QLabel('PV')\r\n        label_SST = QLabel('SST')\r\n        label_VIP = QLabel('VIP')\r\n        label_RLN = QLabel('RLN')\r\n        label_1 = QLabel('1')\r\n        label_23 = QLabel('2/3')\r\n        label_4 = QLabel('4')\r\n        label_5 = QLabel('5')\r\n        label_6 = QLabel('6')\r\n        grid.addWidget(label_source, 4, 1, 1, 5, Qt.AlignHCenter)\r\n        grid.addWidget(label_PYR, 6, 0)\r\n        grid.addWidget(label_PV, 7, 0)\r\n        grid.addWidget(label_SST, 8, 0)\r\n        grid.addWidget(label_VIP, 9, 0)\r\n        grid.addWidget(label_RLN, 10, 0)\r\n        grid.addWidget(label_1, 5, 1)\r\n        grid.addWidget(label_23, 5, 2)\r\n        grid.addWidget(label_4, 5, 3)\r\n        grid.addWidget(label_5, 5, 4)\r\n        grid.addWidget(label_6, 5, 5)\r\n\r\n        self.List_PYRpercent = []\r\n        for l in range(len(self.CC.PYRpercent)):\r\n            edit = LineEdit(str(self.CC.PYRpercent[l]))\r\n            self.List_PYRpercent.append(edit)\r\n            grid.addWidget(edit, 6, l + 1)\r\n\r\n        self.List_PVpercent = []\r\n        for l in range(len(self.CC.PVpercent)):\r\n            edit = LineEdit(str(self.CC.PVpercent[l]))\r\n            self.List_PVpercent.append(edit)\r\n            grid.addWidget(edit, 7, l + 1)\r\n\r\n        self.List_SSTpercent = []\r\n        for l in range(len(self.CC.SSTpercent)):\r\n            edit = LineEdit(str(self.CC.SSTpercent[l]))\r\n            self.List_SSTpercent.append(edit)\r\n            grid.addWidget(edit, 8, l + 1)\r\n\r\n        self.List_VIPpercent = []\r\n        for l in range(len(self.CC.VIPpercent)):\r\n            edit = LineEdit(str(self.CC.VIPpercent[l]))\r\n            self.List_VIPpercent.append(edit)\r\n            grid.addWidget(edit, 9, l + 1)\r\n\r\n        self.List_RLNpercent = []\r\n        for l in range(len(self.CC.RLNpercent)):\r\n            edit = LineEdit(str(self.CC.RLNpercent[l]))\r\n            self.List_RLNpercent.append(edit)\r\n            grid.addWidget(edit, 10, l + 1)\r\n\r\n        # Compute cell number\r\n        self.Apply_percentage_PB = QPushButton('Apply Percentage')\r\n        grid.addWidget(self.Apply_percentage_PB, 11, 1, 1, 3)\r\n        self.Apply_percentage_PB.clicked.connect(self.update_cellNnumber)\r\n\r\n        # Connection matrixcc\r\n        self.Afferences_GB = QGroupBox(r'afference matrix')\r\n        Afferences_GB_l = QVBoxLayout()\r\n        self.Afferences_GB.setLayout(Afferences_GB_l)\r\n        self.Afferences_PB = QPushButton('Get Afference matrix')\r\n        self.Afference_group = QButtonGroup(self)\r\n        self.r0 = QRadioButton(\"Use percentage of the total number of cell\")\r\n        self.r1 = QRadioButton(\"Use fixed number of connection\")\r\n        self.Afference_group.addButton(self.r0)\r\n        self.Afference_group.addButton(self.r1)\r\n        self.r0.setChecked(True)\r\n        Afferences_choice_l = QHBoxLayout()\r\n        Afferences_choice_l.addWidget(self.r0)\r\n        Afferences_choice_l.addWidget(self.r1)\r\n        self.Connection_PB = QPushButton('See Connection number matrix')\r\n        Afferences_GB_l.addLayout(Afferences_choice_l)\r\n        Afferences_GB_l.addWidget(self.Afferences_PB)\r\n        Afferences_GB_l.addWidget(self.Connection_PB)\r\n        self.Afferences_PB.clicked.connect(self.update_connections)\r\n        self.Connection_PB.clicked.connect(self.See_connections)\r\n        self.r0.toggled.connect(self.update_connections_per_fixed)\r\n        self.r1.toggled.connect(self.update_connections_per_fixed)\r\n\r\n        # cell placement\r\n        self.cell_placement_GB = QGroupBox(r\"cell placement\")\r\n        self.cell_placement_CB = QComboBox()\r\n        list = ['Cylinder','Square', 'Rectange','Cylinder with curvature','Square with curvature', 'Rectange with curvature']\r\n        self.cell_placement_CB.addItems(list)\r\n        self.cell_placement_PB = QPushButton('Place cells')\r\n        self.cell_connectivity_PB = QPushButton('Compute connectivity')\r\n        self.cell_keep_model_param_CB = QCheckBox('Keep model parameters')\r\n        self.cell_keep_model_param_CB.setChecked(True)\r\n        layoutseed = QHBoxLayout()\r\n        self.seed_place = LineEdit_Int('0')\r\n        layoutseed.addWidget(QLabel('Place Seed'))\r\n        layoutseed.addWidget(self.seed_place)\r\n        grid = QGridLayout()\r\n        grid.setContentsMargins(5, 5, 5, 5)\r\n        grid.addWidget(self.cell_placement_CB, 0, 0, 1, 1)\r\n        grid.addWidget(self.cell_placement_PB, 0, 1, 1, 2 )\r\n        grid.addWidget(self.cell_connectivity_PB, 1, 1, 1, 2 )\r\n        grid.addLayout(layoutseed, 1, 0, 1, 1)\r\n        self.cell_placement_GB.setLayout(grid)\r\n        self.cell_placement_PB.clicked.connect(self.PlaceCell_func)\r\n        self.cell_connectivity_PB.clicked.connect(self.connectivityCell_func)\r\n\r\n        self.EField_parameters_GB = QGroupBox(r\"E-Field parameters\")\r\n        self.EField_Conv_PB = QPushButton('Convert a txt E-Field')\r\n        self.EField_file_PB = QPushButton('...')\r\n        self.EField_file_TE = QLineEdit('')\r\n\r\n        self.EField_TranslationX_LE = LineEdit('0')\r\n        self.EField_TranslationY_LE = LineEdit('0')\r\n        self.EField_TranslationZ_LE = LineEdit('0')\r\n        lay_Trans = QHBoxLayout()\r\n        lay_Trans.addWidget(QLabel('Translation'))\r\n        lay_Trans.addWidget(QLabel('x'))\r\n        lay_Trans.addWidget(self.EField_TranslationX_LE)\r\n        lay_Trans.addWidget(QLabel('y'))\r\n        lay_Trans.addWidget(self.EField_TranslationY_LE)\r\n        lay_Trans.addWidget(QLabel('z'))\r\n        lay_Trans.addWidget(self.EField_TranslationZ_LE)\r\n\r\n        self.EField_RotationXY_LE = LineEdit('0')\r\n\r\n        lay_Rot = QHBoxLayout()\r\n        lay_Rot.addWidget(QLabel('Rotation'))\r\n        lay_Rot.addWidget(QLabel('xy'))\r\n        lay_Rot.addWidget(self.EField_RotationXY_LE)\r\n        lay_Rot.addWidget(QLabel('Not Implemented yet'))\r\n\r\n        self.EField_OnOff_CB = QCheckBox('On-Off')\r\n        # self.EField_OnOff_CB.setEnabled(False)\r\n        self.EField_Start_LE = LineEdit('0')\r\n        self.EField_Length_LE = LineEdit('1000')\r\n\r\n        self.EField_group = QButtonGroup(self)\r\n        self.EField_File_RB = QRadioButton(\"Use File EField\")\r\n        self.EField_Const_RB = QRadioButton(\"Use Constant EField\")\r\n        self.EField_group.addButton(self.EField_File_RB)\r\n        self.EField_group.addButton(self.EField_Const_RB)\r\n        self.EField_Const_RB.setChecked(True)\r\n\r\n        self.EField_Display_PB = QPushButton('Display')\r\n\r\n        layu = QHBoxLayout()\r\n        self.EField_Const_Ex = LineEdit('0')\r\n        self.EField_Const_Ey = LineEdit('0')\r\n        self.EField_Const_Ez = LineEdit('7')\r\n        layu.addWidget(QLabel('Constant EField (mV/m)'))\r\n        layu.addWidget(QLabel('Ex'))\r\n        layu.addWidget(self.EField_Const_Ex)\r\n        layu.addWidget(QLabel('Ey'))\r\n        layu.addWidget(self.EField_Const_Ey)\r\n        layu.addWidget(QLabel('Ez'))\r\n        layu.addWidget(self.EField_Const_Ez)\r\n\r\n        lay_stim = QHBoxLayout()\r\n        self.EField_StimSig_CB = QComboBox()\r\n        self.EField_StimSig_CB.addItems(['Constant','Sinusoidal', 'rectangular', 'triangular'])\r\n        self.EField_StimSig_A_LE = LineEdit('1')\r\n        self.EField_StimSig_F_LE = LineEdit('1')\r\n        lay_stim.addWidget(self.EField_StimSig_CB)\r\n        lay_stim.addWidget(QLabel('A'))\r\n        lay_stim.addWidget(self.EField_StimSig_A_LE)\r\n        lay_stim.addWidget(QLabel('F'))\r\n        lay_stim.addWidget(self.EField_StimSig_F_LE)\r\n\r\n        grid = QGridLayout()\r\n        line = 0\r\n        grid.addWidget(self.EField_Conv_PB, line, 1, 1, 3)\r\n        line += 1\r\n        grid.addWidget(QLabel('E-Field File (.mat)'), line, 0, 1, 2)\r\n        grid.addWidget(self.EField_file_PB, line, 2, 1, 1)\r\n        grid.addWidget(self.EField_file_TE, line, 3, 1, 2)\r\n        line += 1\r\n        # grid.addLayout(lay_Trans, line, 0,1,5)\r\n        # line += 1\r\n        # grid.addLayout(lay_Rot, line, 0, 1, 4)\r\n        # line += 1\r\n        grid.addWidget(self.EField_File_RB, line, 0, 1, 2)\r\n        grid.addWidget(self.EField_Const_RB, line, 2, 1, 3)\r\n        grid.addWidget(self.EField_Display_PB, line, 5, 1, 1)\r\n        line += 1\r\n        grid.addLayout(layu, line, 0, 1, 6)\r\n        line += 1\r\n        grid.addWidget(self.EField_OnOff_CB, line, 0, 1, 1)\r\n        grid.addWidget(QLabel('Start'), line, 1,1,1)\r\n        grid.addWidget(self.EField_Start_LE, line, 2,1,1)\r\n        grid.addWidget(QLabel('Length'), line, 3,1,1)\r\n        grid.addWidget(self.EField_Length_LE, line, 4,1,1)\r\n        line += 1\r\n        grid.addLayout(lay_stim, line, 0, 1, 4)\r\n\r\n        self.EField_parameters_GB.setLayout(grid)\r\n\r\n        self.EField_Conv_PB.clicked.connect(self.EField_Conv_Fun)\r\n        self.EField_file_PB.clicked.connect(self.get_Efield_path)\r\n        self.EField_Display_PB.clicked.connect(self.EField_Display_Fun)\r\n\r\n        # Stim param I_inj=60, tau=4, stimDur=3, nbstim=5, varstim=12\r\n        self.Stimulation_parameters_GB = QGroupBox(r\"Stimulation parameters\")\r\n        label1 = QLabel('Stim duration (ms)')\r\n        label2 = QLabel(r\"Injected current density (A/cm<sup>2</sup>)\")\r\n        label3 = QLabel(\"Time constant RC (ms)\")\r\n        label4 = QLabel(\"Stim number per cell\")\r\n        label5 = QLabel(\"Jitter variance (ms)\")\r\n        label6 = QLabel(\"seed\")\r\n        self.StimDuration_e = LineEdit('3')\r\n        self.i_inj_e = LineEdit('60')\r\n        self.tau_e = LineEdit('4')\r\n        self.nbStim_e = LineEdit_Int('5')\r\n        self.varianceStim_e = LineEdit('12')\r\n        self.seed_e = LineEdit('0')\r\n        grid = QGridLayout()\r\n        grid.setContentsMargins(5, 5, 5, 5)\r\n        grid.addWidget(label1, 0, 0)\r\n        grid.addWidget(self.StimDuration_e, 0, 1)\r\n        grid.addWidget(label2, 1, 0)\r\n        grid.addWidget(self.i_inj_e, 1, 1)\r\n        grid.addWidget(label3, 2, 0)\r\n        grid.addWidget(self.tau_e, 2, 1)\r\n        grid.addWidget(label4, 3, 0)\r\n        grid.addWidget(self.nbStim_e, 3, 1)\r\n        grid.addWidget(label5, 4, 0)\r\n        grid.addWidget(self.varianceStim_e, 4, 1)\r\n        grid.addWidget(label6, 5, 0)\r\n        grid.addWidget(self.seed_e, 5, 1)\r\n        self.Stimulation_parameters_GB.setLayout(grid)\r\n\r\n        # InputTh param I_inj=25, tau=4, stimDur=3, nbstim=5, deltamin=14, delta=18)\r\n        self.InputTh_parameters_GB = QGroupBox(r\"InputTh parameters\")\r\n        label1 = QLabel('Stim duration (ms)')\r\n        label2 = QLabel(r\"Injected current density (A/cm<sup>2</sup>)\")\r\n        label3 = QLabel(\"Time constant RC (ms)\")\r\n        label4 = QLabel(\"Stim number per cell\")\r\n        label5 = QLabel(\"deltamin\")\r\n        label6 = QLabel(\"delta\")\r\n        self.TH_StimDuration_e = LineEdit('3')\r\n        self.TH_i_inj_e = LineEdit('25')\r\n        self.TH_tau_e = LineEdit('4')\r\n        self.TH_nbStim_e = LineEdit_Int('5')\r\n        self.TH_deltamin_e = LineEdit('14')\r\n        self.TH_delta_e = LineEdit('18')\r\n        grid = QGridLayout()\r\n        grid.setContentsMargins(5, 5, 5, 5)\r\n        grid.addWidget(label1, 0, 0)\r\n        grid.addWidget(self.TH_StimDuration_e, 0, 1)\r\n        grid.addWidget(label2, 1, 0)\r\n        grid.addWidget(self.TH_i_inj_e, 1, 1)\r\n        grid.addWidget(label3, 2, 0)\r\n        grid.addWidget(self.TH_tau_e, 2, 1)\r\n        grid.addWidget(label4, 3, 0)\r\n        grid.addWidget(self.TH_nbStim_e, 3, 1)\r\n        grid.addWidget(label5, 4, 0)\r\n        grid.addWidget(self.TH_deltamin_e, 4, 1)\r\n        grid.addWidget(label6, 5, 0)\r\n        grid.addWidget(self.TH_delta_e, 5, 1)\r\n        self.InputTh_parameters_GB.setLayout(grid)\r\n\r\n        # Simulation parameters\r\n        self.Simulation_parameters_GB = QGroupBox(r\"Simulation parameters\")\r\n        label1 = QLabel('Simulation duration (ms)')\r\n        label2 = QLabel(r\"Sampling frequency (kHz)\")\r\n        self.SimDuration_e = LineEdit('100')\r\n        self.Fs_e = LineEdit('25')\r\n        self.StimStart_e = LineEdit('50')\r\n        self.UpdateModel_PB = QPushButton('Update Model')\r\n        self.ModifyModel_PB = QPushButton('All Model Param')\r\n        self.ModifyXModel_PB = QPushButton('Modify X Models')\r\n        self.Reset_states_PB = QPushButton('Reset states')\r\n        self.Run_PB = QPushButton('Run')\r\n        self.displaycurves_CB = QCheckBox('Display Curves')\r\n        self.displayVTK_CB = QCheckBox('Display VTK')\r\n        self.displaycurve_per_e = LineEdit('100')\r\n        displaycurve_per_l = QLabel(r'% to plot')\r\n        self.displaycurve_per_e = LineEdit('100')\r\n\r\n        grid = QGridLayout()\r\n        grid.setContentsMargins(5, 5, 5, 5)\r\n        grid.addWidget(label1, 0, 0, 1, 2)\r\n        grid.addWidget(self.SimDuration_e, 0, 2)\r\n        grid.addWidget(label2, 1, 0, 1, 2)\r\n        grid.addWidget(self.Fs_e, 1, 2)\r\n        grid.addWidget(self.UpdateModel_PB, 0, 3)\r\n        grid.addWidget(self.ModifyModel_PB, 1, 3)\r\n        grid.addWidget(self.ModifyXModel_PB, 2, 3)\r\n        grid.addWidget(self.Run_PB, 3, 3)\r\n        grid.addWidget(self.Reset_states_PB, 3, 2)\r\n        grid.addWidget(self.displaycurves_CB, 3, 0)\r\n        grid.addWidget(self.displayVTK_CB, 2, 0)\r\n        label = QLabel('Stim Start')\r\n        label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)\r\n        grid.addWidget(label, 2, 1)\r\n        grid.addWidget(self.StimStart_e, 2, 2)\r\n        grid.addWidget(displaycurve_per_l, 4, 0)\r\n        grid.addWidget(self.displaycurve_per_e, 4, 1)\r\n        self.Simulation_parameters_GB.setLayout(grid)\r\n        self.Run_PB.clicked.connect(self.simulate)\r\n        self.UpdateModel_PB.clicked.connect(self.update_Model)\r\n        self.ModifyModel_PB.clicked.connect(self.modify_Model)\r\n        self.ModifyXModel_PB.clicked.connect(self.ModXNMMclicked)\r\n        self.Reset_states_PB.clicked.connect(self.Reset_states_clicked)\r\n        self.displaycurves_CB.stateChanged.connect(self.displaycurves_CB_fonc)\r\n        self.displaycurves_CB.setChecked(True)\r\n        self.displayVTK_CB.stateChanged.connect(self.displayVTK_CB_fonc)\r\n        self.displayVTK_CB.setChecked(True)\r\n\r\n        # electrode placement\r\n        self.electrode_placement_GB = QGroupBox(r\"electrode position\")\r\n        label_x = QLabel('x y z')\r\n        label_y = QLabel('y')\r\n        label_z = QLabel('z')\r\n        self.electrode_x_e = LineEdit(str(self.electrode_pos[0]))\r\n        self.electrode_y_e = LineEdit(str(self.electrode_pos[1]))\r\n        self.electrode_z_e = LineEdit(str(self.electrode_pos[2]))\r\n        self.Compute_LFP_PB = QPushButton('Point LFP')\r\n        self.Compute_LFP2_PB = QPushButton('Point LFP2')\r\n        self.electrod_disk_CB = QCheckBox('Disk')\r\n        self.electrode_radius_e = LineEdit('50')\r\n        self.electrode_angle1_e = LineEdit('0')\r\n        self.electrode_angle2_e = LineEdit('0')\r\n        self.Compute_LFPDisk_PB = QPushButton('Disk LFP')\r\n        self.Compute_LFPDiskCoated_PB = QPushButton('Coated Disk LFP')\r\n        self.Compute_LFPDiskCoated_type_CB = QComboBox()\r\n        listitem = ['carbon_non-coated_mean , radius = 200 m',\r\n                    'gold_non-coated_mean , radius = 62.5 m',\r\n                    'stainless_steel_non-coated_mean, radius = 62.5 m',\r\n                    'carbon_coated_5s, radius = 200 m',\r\n                    'carbon_coated_10s, radius = 200 m',\r\n                    'carbon_coated_50s, radius = 200 m',\r\n                    'gold_coated_5s, radius = 62.5 m',\r\n                    'gold_coated_10s, radius = 62.5 m',\r\n                    'gold_coated_50s, radius = 62.5 m']\r\n        self.Compute_LFPDiskCoated_type_CB.addItems(listitem)\r\n        self.Temporal_PSD_CB = QCheckBox('Temporal/PSD')\r\n        grid = QGridLayout()\r\n        grid.setContentsMargins(5, 5, 5, 5)\r\n        grid.addWidget(label_x, 0, 0)\r\n        grid.addWidget(self.electrode_x_e, 0, 1)\r\n        grid.addWidget(self.electrode_y_e, 0, 2)\r\n        grid.addWidget(self.electrode_z_e, 0, 3)\r\n        grid.addWidget(self.Compute_LFP_PB, 0, 4)\r\n        grid.addWidget(self.Compute_LFP2_PB, 0, 5)\r\n\r\n        grid.addWidget(self.electrod_disk_CB, 1, 0)\r\n        grid.addWidget(QLabel('r \\u03B81 \\u03B82'), 1, 1)\r\n        grid.addWidget(self.electrode_radius_e, 1, 2)\r\n        grid.addWidget(self.electrode_angle1_e, 1, 3)\r\n        grid.addWidget(self.electrode_angle2_e, 1, 4)\r\n        grid.addWidget(self.Compute_LFPDisk_PB, 1, 5)\r\n        # grid.addWidget(QLabel('material'), 2, 0)\r\n        grid.addWidget(self.Compute_LFPDiskCoated_type_CB, 2, 0, 1, 4)\r\n        grid.addWidget(self.Compute_LFPDiskCoated_PB, 2, 4, 1, 2)\r\n        grid.addWidget(self.Temporal_PSD_CB, 3, 4, 1, 2)\r\n\r\n        self.electrode_placement_GB.setLayout(grid)\r\n        [x.editingFinished.connect(self.electrode_placement_func) for x in [self.electrode_x_e, self.electrode_y_e, self.electrode_z_e]]\r\n        [x.editingFinished.connect(self.electrode_placement_func) for x in [self.electrode_radius_e, self.electrode_angle1_e, self.electrode_angle2_e]]\r\n        self.electrod_disk_CB.stateChanged.connect(self.electrode_placement_func)\r\n        self.Compute_LFP_PB.clicked.connect(lambda state, meth=0: self.Compute_LFP_fonc(meth) )\r\n        self.Compute_LFP2_PB.clicked.connect(lambda state, meth=1: self.Compute_LFP_fonc(meth) )\r\n        self.Compute_LFPDisk_PB.clicked.connect(self.Compute_LFPDisk_fonc)\r\n        self.Compute_LFPDiskCoated_PB.clicked.connect(self.Compute_LFPDiskCoated_fonc)\r\n        self.Temporal_PSD_CB.stateChanged.connect(self.UpdateLFP)\r\n\r\n        self.somaSize = 15.0 * 10e-3  # 15 micrometres = 15 * 10e-3 mm\r\n        self.dendriteSize = 300.0 * 10e-3  # 800  micrometres = 400 * 10e-3 mm\r\n        self.sigma = 33.0 * 10e-5\r\n        self.gc = 10.e-5\r\n        self.p = 0.15\r\n\r\n        # synchro\r\n        self.synchro_GB = QGroupBox(r\"synchronisation algorithm\")\r\n        self.synchro_l = QVBoxLayout()\r\n        self.synchro_method_CB = QComboBox()\r\n        list = ['Thresholding', 'AutoCorrelation', 'Nearest delay','ISI-distance','van Rossum distance','Victor Purpura distance' ]\r\n        self.synchro_method_CB.addItems(list)\r\n\r\n        self.synchro_l.addWidget(self.synchro_method_CB)\r\n        self.synchro_widget = QWidget()\r\n        self.synchro_l.addWidget(self.synchro_widget)\r\n        self.update_synchro_method()\r\n\r\n        self.synchro_GB.setLayout(self.synchro_l)\r\n        self.synchro_method_CB.currentTextChanged.connect(self.update_synchro_method)\r\n\r\n\r\n        self.Param_VBOX.addWidget(self.tissue_size_GB)\r\n        self.Param_VBOX.addWidget(self.pourcentageCell_GB)\r\n        self.Param_VBOX.addWidget(self.Afferences_GB)\r\n        self.Param_VBOX.addWidget(self.cell_placement_GB)\r\n        self.Param_VBOX.addWidget(self.EField_parameters_GB)\r\n        self.Param_VBOX.addWidget(self.Stimulation_parameters_GB)\r\n        self.Param_VBOX.addWidget(self.InputTh_parameters_GB)\r\n        self.Param_VBOX.addWidget(self.Simulation_parameters_GB)\r\n        self.Param_VBOX.addWidget(self.electrode_placement_GB)\r\n        self.Param_VBOX.addWidget(self.synchro_GB)\r\n        self.Param_VBOX.addSpacerItem(QSpacerItem(0, 0, QSizePolicy.Expanding))\r\n        # self.Param_VBOX.addLayout(QVBoxLayout( ))\r\n\r\n        self.NewCreate_EField_view = []\r\n\r\n\r\n    def Nb_Cell_Changed(self,s):\r\n        if s in [\"1\",\"23\",\"4\",\"5\",\"6\"]:\r\n            somme = 0\r\n            somme += int(self.nbcellsnb1.text())\r\n            somme += int(self.nbcellsnb23.text())\r\n            somme += int(self.nbcellsnb4.text())\r\n            somme += int(self.nbcellsnb5.text())\r\n            somme += int(self.nbcellsnb6.text())\r\n            self.nbcellsnbtotal.setText(str(int(somme)))\r\n            self.update_cellNnumber()\r\n        elif s == 'total':\r\n            Nbcells = self.CC.Nbcells\r\n            ratio = np.array([int(self.nbcellsnb1.text()),int(self.nbcellsnb23.text()),int(self.nbcellsnb4.text()),int(self.nbcellsnb5.text()),int(self.nbcellsnb6.text())]).astype(float)\r\n            ratio /= float(Nbcells)\r\n            new_Nbcells = float(self.nbcellsnbtotal.text())\r\n            self.nbcellsnb1.setText(str(int(new_Nbcells*ratio[0])))\r\n            self.nbcellsnb23.setText(str(int(new_Nbcells*ratio[1])))\r\n            self.nbcellsnb4.setText(str(int(new_Nbcells*ratio[2])))\r\n            self.nbcellsnb5.setText(str(int(new_Nbcells*ratio[3])))\r\n            self.nbcellsnb6.setText(str(int(new_Nbcells*ratio[4])))\r\n            self.update_cellNnumber()\r\n\r\n    def update_synchro_method(self):\r\n        self.synchro_l.removeWidget(self.synchro_widget)\r\n        self.synchro_widget.deleteLater()\r\n        self.synchro_widget = None\r\n\r\n        if self.synchro_method_CB.currentText() == 'Thresholding':\r\n            self.synchro_widget = QWidget()\r\n            label_Thresholding = QLabel('Threshold (mV)')\r\n            self.Synchro_Thresholding_Threshold_e = LineEdit('0')\r\n            label_Thresholding_perc = QLabel('Area over (%)')\r\n            self.Synchro_Thresholding_Threshold_perc_e = LineEdit('10')\r\n            self.Synchro_Thresholding_PB = QPushButton('Apply')\r\n            grid = QGridLayout()\r\n            grid.addWidget(label_Thresholding, 0, 0)\r\n            grid.addWidget(self.Synchro_Thresholding_Threshold_e, 0, 1)\r\n            grid.addWidget(self.Synchro_Thresholding_PB, 0, 2)\r\n            grid.addWidget(label_Thresholding_perc, 0, 3)\r\n            grid.addWidget(self.Synchro_Thresholding_Threshold_perc_e, 0, 4)\r\n            self.synchro_widget.setLayout(grid)\r\n            self.Synchro_Thresholding_PB.clicked.connect(self.Synchro_Method_PB_Apply)\r\n        elif self.synchro_method_CB.currentText() == 'AutoCorrelation':\r\n            self.synchro_widget = QWidget()\r\n            label_AutoCorrelation = QLabel('Threshold (mV)')\r\n            self.Synchro_AutoCorrelation_Threshold_e = LineEdit('0')\r\n            label_AutoCorrelation_perc = QLabel('Area over (%)')\r\n            self.Synchro_AutoCorrelation_Threshold_perc_e = LineEdit('10')\r\n            self.Synchro_AutoCorrelation_PB = QPushButton('Apply')\r\n            grid = QGridLayout()\r\n            grid.addWidget(label_AutoCorrelation, 0, 0)\r\n            grid.addWidget(self.Synchro_AutoCorrelation_Threshold_e, 0, 1)\r\n            grid.addWidget(self.Synchro_AutoCorrelation_PB, 0, 2)\r\n            grid.addWidget(label_AutoCorrelation_perc, 0, 3)\r\n            grid.addWidget(self.Synchro_AutoCorrelation_Threshold_perc_e, 0, 4)\r\n            self.synchro_widget.setLayout(grid)\r\n            self.Synchro_AutoCorrelation_PB.clicked.connect(self.Synchro_Method_PB_Apply)\r\n\r\n        elif self.synchro_method_CB.currentText() == 'Nearest delay':\r\n            self.synchro_widget = QWidget()\r\n            label_NearestDelay = QLabel('Delta')\r\n            self.Synchro_NearestDelay_Threshold_e = LineEdit('50')\r\n            self.Synchro_NearestDelay_PB = QPushButton('Apply')\r\n            grid = QGridLayout()\r\n            grid.addWidget(label_NearestDelay, 0, 0)\r\n            grid.addWidget(self.Synchro_NearestDelay_Threshold_e, 0, 1)\r\n            grid.addWidget(self.Synchro_NearestDelay_PB, 0, 2)\r\n            self.synchro_widget.setLayout(grid)\r\n            self.Synchro_NearestDelay_PB.clicked.connect(self.Synchro_Method_PB_Apply)\r\n        elif self.synchro_method_CB.currentText() == 'ISI-distance':\r\n            self.synchro_widget = QWidget()\r\n            label_ISI = QLabel('Delta')\r\n            self.Synchro_ISI_Threshold_e = LineEdit('50')\r\n            self.Synchro_ISI_PB = QPushButton('Apply')\r\n            grid = QGridLayout()\r\n            grid.addWidget(label_ISI, 0, 0)\r\n            grid.addWidget(self.Synchro_ISI_Threshold_e, 0, 1)\r\n            grid.addWidget(self.Synchro_ISI_PB, 0, 2)\r\n            self.synchro_widget.setLayout(grid)\r\n            self.Synchro_ISI_PB.clicked.connect(self.Synchro_Method_PB_Apply)\r\n        elif self.synchro_method_CB.currentText() == 'van Rossum distance':\r\n            self.synchro_widget = QWidget()\r\n            label_vanRossum_Tau = QLabel('Tau (s)')\r\n            label_vanRossum_delta = QLabel('delta (mV)')\r\n            self.Synchro_vanRossum_Tau_e = LineEdit('1')\r\n            self.Synchro_vanRossum_delta_e = LineEdit('50')\r\n            self.Synchro_vanRossum_PB = QPushButton('Apply')\r\n            grid = QGridLayout()\r\n            grid.addWidget(label_vanRossum_delta, 0, 0)\r\n            grid.addWidget(self.Synchro_vanRossum_delta_e, 0, 1)\r\n            grid.addWidget(label_vanRossum_Tau, 0, 2)\r\n            grid.addWidget(self.Synchro_vanRossum_Tau_e, 0, 3)\r\n            grid.addWidget(self.Synchro_vanRossum_PB, 0, 4)\r\n            self.synchro_widget.setLayout(grid)\r\n            self.Synchro_vanRossum_PB.clicked.connect(self.Synchro_Method_PB_Apply)\r\n        elif self.synchro_method_CB.currentText() == 'Victor Purpura distance':\r\n            self.synchro_widget = QWidget()\r\n            label_VictorPurpura_q = QLabel('q (Hz)')\r\n            label_VictorPurpura_delta = QLabel('delta (mV)')\r\n            self.Synchro_VictorPurpura_q_e = LineEdit('1')\r\n            self.Synchro_VictorPurpura_delta_e = LineEdit('50')\r\n            self.Synchro_VictorPurpura_PB = QPushButton('Apply')\r\n            grid = QGridLayout()\r\n            grid.addWidget(label_VictorPurpura_delta, 0, 0)\r\n            grid.addWidget(self.Synchro_VictorPurpura_delta_e, 0, 1)\r\n            grid.addWidget(label_VictorPurpura_q, 0, 2)\r\n            grid.addWidget(self.Synchro_VictorPurpura_q_e, 0, 3)\r\n            grid.addWidget(self.Synchro_VictorPurpura_PB, 0, 4)\r\n            self.synchro_widget.setLayout(grid)\r\n            self.Synchro_VictorPurpura_PB.clicked.connect(self.Synchro_Method_PB_Apply)\r\n\r\n        self.synchro_l.insertWidget(1, self.synchro_widget)\r\n\r\n    def Synchro_Method_PB_Apply(self):\r\n        try:\r\n            self.Sigs_dict\r\n        except:\r\n            return\r\n        if self.synchro_method_CB.currentText() == 'Thresholding':\r\n            Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n            t = Sigs_dict.pop('t')\r\n            keys = list(Sigs_dict.keys())\r\n            array_Sigs = []\r\n            for i, v in enumerate(self.List_Neurone_type):\r\n                if v == 1:\r\n                    array_Sigs.append(Sigs_dict[keys[i]])\r\n            array_Sigs = np.array(array_Sigs)\r\n            threshold = float(self.Synchro_Thresholding_Threshold_e.text())\r\n            threshold_perc = float(self.Synchro_Thresholding_Threshold_perc_e.text()) / 100\r\n            sigbin = array_Sigs > threshold\r\n\r\n            Aps = []\r\n            for i in range(sigbin.shape[0]):\r\n                Ap = 0\r\n                for j in range(sigbin.shape[1] - 1):\r\n                    if sigbin[i, j] == False and sigbin[i, j + 1] == True:\r\n                        Ap += 1\r\n                Aps.append(Ap)\r\n            Aps = int(np.sum(np.array(Aps)))\r\n\r\n            synchro_sig = np.sum(sigbin, axis=0)\r\n            synchro_sig = synchro_sig / array_Sigs.shape[0]\r\n\r\n            sigbin_perc = np.zeros(synchro_sig.shape) * np.nan\r\n            threshold_perc_sig = synchro_sig > threshold_perc\r\n            selection = np.ones(len(threshold_perc_sig), dtype=bool)\r\n            selection[1:] = threshold_perc_sig[1:] != threshold_perc_sig[:-1]\r\n            selection[0] = False\r\n            selection &= threshold_perc_sig != 0\r\n            threshold_perc_NB = np.sum(threshold_perc_sig[selection])\r\n\r\n            sigbin_perc[synchro_sig > threshold_perc] = synchro_sig[synchro_sig > threshold_perc]\r\n\r\n            sigbin_perc_sum = np.nansum(sigbin_perc - threshold_perc) * (t[1] - t[0])\r\n\r\n            chaine = 'Total number of APs on Pyr = ' + str(Aps) + \\\r\n                     ', Nb passage over' + self.Synchro_Thresholding_Threshold_perc_e.text() + '% = ' + str(\r\n                threshold_perc_NB) + \\\r\n                     ', Area over' + self.Synchro_Thresholding_Threshold_perc_e.text() + '% = ' + str(sigbin_perc_sum)\r\n            self.mascene_LFPViewer.update_synchro_thresholding(synchro_sig, sigbin_perc,\r\n                                                               shiftT=self.CC.tps_start - self.T, titre=chaine)\r\n        elif self.synchro_method_CB.currentText() == 'AutoCorrelation':\r\n            Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n            t = Sigs_dict.pop('t')\r\n            keys = list(Sigs_dict.keys())\r\n            array_Sigs = []\r\n            for i, v in enumerate(self.List_Neurone_type):\r\n                if v == 1:\r\n                    array_Sigs.append(Sigs_dict[keys[i]])\r\n            array_Sigs = np.array(array_Sigs)\r\n            threshold = float(self.Synchro_AutoCorrelation_Threshold_e.text())\r\n            threshold_perc = float(self.Synchro_AutoCorrelation_Threshold_perc_e.text()) / 100\r\n            sigbin = array_Sigs > threshold\r\n\r\n            Aps = []\r\n            for i in range(sigbin.shape[0]):\r\n                Ap = 0\r\n                for j in range(sigbin.shape[1] - 1):\r\n                    if sigbin[i, j] == False and sigbin[i, j + 1] == True:\r\n                        Ap += 1\r\n                Aps.append(Ap)\r\n            Aps = int(np.sum(np.array(Aps)))\r\n\r\n            synchro_sig = np.sum(sigbin, axis=0)\r\n            synchro_sig = synchro_sig / array_Sigs.shape[0]\r\n\r\n            sigbin_perc_autocorrel = signal.correlate(synchro_sig, synchro_sig, mode='full')\r\n\r\n            chaine = 'Total number of APs on Pyr = ' + str(Aps)\r\n\r\n            self.mascene_LFPViewer.update_synchro_AutoCorrelation(synchro_sig, sigbin_perc_autocorrel, shiftT=self.CC.tps_start - self.T, titre=chaine)\r\n\r\n        elif self.synchro_method_CB.currentText() == 'Nearest delay':\r\n            Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n            t = Sigs_dict.pop('t')\r\n            keys = list(Sigs_dict.keys())\r\n            array_Sigs = []\r\n            for i, v in enumerate(self.List_Neurone_type):\r\n                if v == 1:\r\n                    array_Sigs.append(Sigs_dict[keys[i]])\r\n            array_Sigs = np.array(array_Sigs)\r\n            delta = float(self.Synchro_NearestDelay_Threshold_e.text())\r\n\r\n            # sigbin = array_Sigs > threshold\r\n            # Aps_centers = []\r\n            # for i in range(sigbin.shape[0]):\r\n            #     Aps = []\r\n            #     newone = False\r\n            #     currentAp = []\r\n            #     for j in range(sigbin.shape[1] - 1):\r\n            #         if sigbin[i, j] == True and sigbin[i, j + 1] == True:\r\n            #             currentAp.append(t[j])\r\n            #             newone = True\r\n            #         else:\r\n            #             if newone == False:\r\n            #                 pass\r\n            #             elif newone == True:\r\n            #                 Aps.append(np.mean(currentAp))\r\n            #                 currentAp = []\r\n            #                 newone = False\r\n            #     Aps_centers.append(Aps)\r\n            Aps_centers = []\r\n            for i in range(array_Sigs.shape[0]):\r\n                maxi, mini = peakdet(array_Sigs[i, :], delta)\r\n                if len(maxi) > 0:\r\n                    Aps_centers.append(t[maxi[:, 0].astype(int)])\r\n                    # Aps_centers.append(maxi[:, 0].astype(int))\r\n                else:\r\n                    Aps_centers.append(np.array([]))\r\n\r\n            # self.mascene_LFPViewer.update_synchro_NearestDelay_scatter(Aps_centers, shiftT=self.CC.tps_start - self.T, titre='')\r\n\r\n            def find_nearest(array, value):\r\n                array = np.asarray(array)\r\n                idx = (np.abs(array - value)).argmin()\r\n                return array[idx]\r\n\r\n            Aps_delays = []\r\n            meanDelay = []\r\n            for i in range(len(Aps_centers)):\r\n                if not Aps_centers[i] == []:\r\n                    meanDelay.append(np.diff(np.array(Aps_centers[i])))\r\n\r\n                    delaysline = []\r\n                    for j in range(len(Aps_centers[i])):\r\n                        delays = []\r\n                        for k in range(len(Aps_centers)):\r\n                            if not k == i:\r\n                                if not len(Aps_centers[k]) == 0:\r\n                                    found_delay = find_nearest(Aps_centers[k], Aps_centers[i][j])\r\n                                    delays.append(abs(Aps_centers[i][j] - found_delay))\r\n                        delaysline.append(delays)\r\n                    Aps_delays.append(delaysline)\r\n                else:\r\n                    Aps_delays.append([])\r\n\r\n            meanDelay = np.mean(np.concatenate(meanDelay).ravel())\r\n            # self.mascene_LFPViewer.update_synchro_NearestDelay_boxplot(Aps_delays, shiftT=self.CC.tps_start - self.T, titre='')\r\n\r\n            Aps_delays_flatten = []\r\n            for i in range(len(Aps_delays)):\r\n                if not Aps_delays[i] == []:\r\n                    Aps_delays_flatten.append(np.concatenate(Aps_delays[i]).ravel())\r\n                else:\r\n                    Aps_delays_flatten.append([])\r\n            meanDiffDelay = np.mean(np.concatenate(Aps_delays_flatten).ravel())\r\n            # self.mascene_LFPViewer.update_synchro_NearestDelay(Aps_centers,Aps_delays, shiftT=self.CC.tps_start - self.T, titre='Delay Mean = ' + str(meanDelay) + ', Delay Diff Mean = ' + str(meanDiffDelay))\r\n\r\n            Aps_gauss_fit = []\r\n\r\n            def gaus(x, a, sigma):\r\n                return a * np.exp(-(x) ** 2 / (2 * sigma ** 2))\r\n\r\n            # for i in range(len(Aps_delays)):\r\n            #     gauss_fit = []\r\n            #     for j in range(len(Aps_delays[i])):\r\n            #         monAP = Aps_delays[i][j]\r\n            #         maxi = np.max(np.abs(monAP))\r\n            #         x = np.linspace(-maxi, maxi, 1000)\r\n            #         y = np.zeros(x.shape)\r\n            #         for val in np.abs(monAP):\r\n            #             y[np.abs(x) < val] += np.ones(len(y[np.abs(x) < val]))\r\n            #         popt, pcov = curve_fit(gaus, x, y, p0=[1, 1])\r\n            #         gauss_fit.append(popt[0])\r\n            #     Aps_gauss_fit.append(gauss_fit)\r\n            Aps_gauss_fit = []\r\n            # plt.figure()\r\n            for i in range(len(Aps_delays_flatten)):\r\n                if len(Aps_delays_flatten[i]) >0:\r\n                    h = np.histogram(Aps_delays_flatten[i], bins=int(np.max(Aps_delays_flatten[i])), range=(0, int(np.max(Aps_delays_flatten[i]))))\r\n                    x = np.hstack((-h[1][-2:0:-1], h[1][:-1]))\r\n                    y = np.hstack((+h[0][-1:0:-1], h[0][:]))\r\n                    popt, pcov = curve_fit(gaus, x, y, p0=[1, 1])\r\n\r\n                    Aps_gauss_fit.append(popt[1])\r\n                    # plt.subplot(10, 10, i + 1)\r\n                    # plt.plot(x, y)\r\n                    # plt.plot(x, gaus(x, *popt), 'ro:', label='fit')\r\n                    # plt.axis([-200, 200, 0, 100])\r\n\r\n            meangauss_fit = np.mean(Aps_gauss_fit)\r\n            # meangauss_fit = np.mean(np.concatenate(Aps_gauss_fit).ravel())\r\n            self.mascene_LFPViewer.update_synchro_NearestDelay2(Aps_centers,Aps_delays, Aps_gauss_fit, shiftT=self.CC.tps_start - self.T,\r\n                                                               titre='Delay Mean = ' + str(meanDelay) + ', Delay Diff Mean = ' + str(meanDiffDelay) + ',  gauss fit sigma = ' + str(meangauss_fit))\r\n\r\n\r\n\r\n            #\r\n            # plt.figure()\r\n            # for i in range(54):\r\n            #     monAP = Aps_delays[0][i]\r\n            #     maxi = np.max(np.abs(monAP))\r\n            #     x = np.linspace(-maxi, maxi, 1000)\r\n            #     y = np.zeros(x.shape)\r\n            #     for val in np.abs(monAP):\r\n            #         y[np.abs(x) < val] += np.ones(len(y[np.abs(x) < val]))\r\n            #\r\n            #     def gaus(x, a, x0, sigma):\r\n            #         return a * np.exp(-(x - x0) ** 2 / (2 * sigma ** 2))\r\n            #\r\n            #     popt, pcov = curve_fit(gaus, x, y, p0=[1, 0, 1])\r\n            #\r\n            #     plt.subplot(8, 6, i + 1)\r\n            #     plt.plot(x, y)\r\n            #     plt.plot(x, gaus(x, *popt), 'ro:', label='fit')\r\n            #     plt.axis([-200, 200, 0, 100])\r\n\r\n        elif self.synchro_method_CB.currentText() == 'ISI-distance':\r\n            Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n            t = Sigs_dict.pop('t')\r\n            dt = t[1] - t[0]\r\n            keys = list(Sigs_dict.keys())\r\n            array_Sigs = []\r\n            for i, v in enumerate(self.List_Neurone_type):\r\n                if v == 1:\r\n                    array_Sigs.append(Sigs_dict[keys[i]])\r\n            array_Sigs = np.array(array_Sigs)\r\n            delta = float(self.Synchro_ISI_Threshold_e.text())\r\n\r\n            Aps = []\r\n            for i in range(array_Sigs.shape[0]):\r\n                maxi, mini = peakdet(array_Sigs[i, :], delta)\r\n                if len(maxi) > 0:\r\n                    # Aps.append(t[maxi[:, 0].astype(int)])\r\n                    Aps.append(maxi[:, 0].astype(int))\r\n                else:\r\n                    Aps.append(np.array([]))\r\n\r\n            # fig = plt.figure()\r\n            # ax = fig.add_subplot(111)\r\n            # for i in range(len(Aps)):\r\n            #     plt.plot(t,array_Sigs[i,:]+i*50)\r\n            #     plt.scatter(Aps[i],array_Sigs[i, [int(a/dt) for a in Aps[i]]]+i*50)\r\n\r\n            # ISI distance\r\n            array_ISI = np.zeros(array_Sigs.shape) * np.NAN\r\n            for i in range(len(Aps)):\r\n                for j in range(len(Aps[i]) - 1):\r\n                    array_ISI[i, Aps[i][j]:Aps[i][j + 1]] = t[Aps[i][j + 1]] - t[Aps[i][j]]\r\n\r\n            # fig = plt.figure()\r\n            # ax = fig.add_subplot(111)\r\n            # for i in range(len(Aps)):\r\n            #     plt.plot(t,array_ISI[i,:]+i*10)\r\n\r\n            array_ratio = np.zeros((array_ISI.shape[0], array_ISI.shape[0], array_ISI.shape[1]))\r\n            array_ratio = self.ISI_ratio(array_ISI, array_ratio)\r\n\r\n            # fig = plt.figure()\r\n            # ax = fig.add_subplot(111)\r\n            # for i in range(len(Aps)):\r\n            #     plt.plot(t,array_ratio[i,0,:]+i*10)\r\n\r\n            IntegralI = np.zeros((array_ISI.shape[0], array_ISI.shape[0])) * np.NAN\r\n            for i in range(array_ISI.shape[0]):  # xisi\r\n                for j in range(array_ISI.shape[0]):  # y\r\n                    if not j == i:\r\n                        IntegralI[i,j] = np.nansum(np.abs(array_ratio[i,j,:])) / np.sum(np.isnan(array_ratio[i,j,:]))\r\n                        if IntegralI[i,j]==0.:\r\n                            IntegralI[i,j] = np.NAN\r\n\r\n            self.mascene_LFPViewer.update_synchro_ISI_distance(IntegralI, titre='ISI_distance')\r\n\r\n        elif self.synchro_method_CB.currentText() == 'van Rossum distance':\r\n            delta = float(self.Synchro_vanRossum_delta_e.text())\r\n            Tau = float(self.Synchro_vanRossum_Tau_e.text())\r\n\r\n            Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n            t = Sigs_dict.pop('t')\r\n            keys = list(Sigs_dict.keys())\r\n            array_Sigs = []\r\n            for i, v in enumerate(self.List_Neurone_type):\r\n                if v == 1:\r\n                    array_Sigs.append(Sigs_dict[keys[i]])\r\n            array_Sigs = np.array(array_Sigs)\r\n\r\n            Aps_centers = []\r\n            for i in range(array_Sigs.shape[0]):\r\n                maxi, mini = peakdet(array_Sigs[i, :], delta)\r\n                if len(maxi) > 0:\r\n                    Aps_centers.append(t[maxi[:, 0].astype(int)])\r\n                    # Aps_centers.append(maxi[:, 0].astype(int))\r\n                else:\r\n                    Aps_centers.append(np.array([]))\r\n\r\n            if Tau <= 0:\r\n                spike_counts = [len(st) for st in Aps_centers]\r\n                vr_dist = np.sqrt(spike_counts + np.atleast_2d(spike_counts).T)\r\n            elif Tau == np.inf:\r\n                spike_counts = [len(st) for st in Aps_centers]\r\n                vr_dist = np.absolute(spike_counts - np.atleast_2d(spike_counts).T)\r\n            else:\r\n                k_dist = self._summed_dist_matrix(Aps_centers, Tau, True)\r\n                vr_dist = np.empty_like(k_dist)\r\n                for i, j in np.ndindex(k_dist.shape):\r\n                    vr_dist[i, j] = (\r\n                            k_dist[i, i] + k_dist[j, j] - k_dist[i, j] - k_dist[j, i])\r\n                vr_dist = np.sqrt(vr_dist)\r\n\r\n            # f = plt.figure()\r\n            # ax = f.add_subplot(111)\r\n            # current_cmap = matplotlib.cm.get_cmap('viridis')\r\n            # current_cmap.set_bad(color='black')\r\n            # im = ax.imshow(vr_dist, cmap=current_cmap)\r\n            # f.colorbar(im)\r\n            self.mascene_LFPViewer.update_synchro_vanRossum_distance(vr_dist, titre='vanRossum_distance')\r\n\r\n        elif self.synchro_method_CB.currentText() == 'Victor Purpura distance':\r\n            delta = float(self.Synchro_VictorPurpura_delta_e.text())\r\n            q = float(self.Synchro_VictorPurpura_q_e.text())\r\n\r\n            Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n            t = Sigs_dict.pop('t')\r\n            keys = list(Sigs_dict.keys())\r\n            array_Sigs = []\r\n            for i, v in enumerate(self.List_Neurone_type):\r\n                if v == 1:\r\n                    array_Sigs.append(Sigs_dict[keys[i]])\r\n            array_Sigs = np.array(array_Sigs)\r\n\r\n            Aps_centers = []\r\n            for i in range(array_Sigs.shape[0]):\r\n                maxi, mini = peakdet(array_Sigs[i, :], delta)\r\n                if len(maxi) > 0:\r\n                    Aps_centers.append(t[maxi[:, 0].astype(int)])\r\n                    # Aps_centers.append(maxi[:, 0].astype(int))\r\n                else:\r\n                    Aps_centers.append(np.array([]))\r\n\r\n            if q <= 0:\r\n                num_spikes = np.atleast_2d([len(st) for st in Aps_centers])\r\n                vp_dist = np.absolute(num_spikes.T - num_spikes)\r\n            elif q == np.inf:\r\n                num_spikes = np.atleast_2d([len(st) for st in Aps_centers])\r\n                vp_dist = num_spikes.T + num_spikes\r\n            else:\r\n                shape = (len(Aps_centers), len(Aps_centers))\r\n                vp_dist = np.empty(shape)\r\n                for i in range(shape[0]):\r\n                    for j in range(i, shape[1]):\r\n                        # if len(Aps_centers[i]) == 0 or len(Aps_centers[j]) == 0:\r\n                        #     vp_dist[i, j] = vp_dist[j, i] = np.NAN\r\n                        # else:\r\n                        vp_dist[i, j] = vp_dist[j, i] = self._victor_purpura_dist_for_st_pair_intuitive(Aps_centers[i],\r\n                                                                                                        Aps_centers[j],\r\n                                                                                                        q=q)\r\n            # f = plt.figure()\r\n            # ax = f.add_subplot(111)\r\n            # current_cmap = matplotlib.cm.get_cmap('viridis')\r\n            # current_cmap.set_bad(color='black')\r\n            # im = ax.imshow(vr_dist, cmap=current_cmap)\r\n            # f.colorbar(im)\r\n            self.mascene_LFPViewer.update_synchro_VictorPurpura_distance(vp_dist, titre='VictorPurpura_distance')\r\n\r\n    @staticmethod\r\n    def _victor_purpura_dist_for_st_pair_intuitive(train_a, train_b, q=1.0):\r\n        nspk_a = len(train_a)\r\n        nspk_b = len(train_b)\r\n        scr = np.zeros((nspk_a + 1, nspk_b + 1))\r\n        scr[:, 0] = range(0, nspk_a + 1)\r\n        scr[0, :] = range(0, nspk_b + 1)\r\n\r\n        if nspk_a > 0 and nspk_b > 0:\r\n            for i in range(1, nspk_a + 1):\r\n                for j in range(1, nspk_b + 1):\r\n                    scr[i, j] = min(scr[i - 1, j] + 1, scr[i, j - 1] + 1)\r\n                    scr[i, j] = min(scr[i, j], scr[i - 1, j - 1]\r\n                                    + np.float64((q * abs(train_a[i - 1] - train_b[j - 1]))))\r\n        return scr[nspk_a, nspk_b]\r\n\r\n    def _summed_dist_matrix(self, spiketrains, tau, presorted=False):\r\n        # The algorithm underlying this implementation is described in\r\n        # Houghton, C., & Kreuz, T. (2012). On the efficient calculation of van\r\n        # Rossum distances. Network: Computation in Neural Systems, 23(1-2),\r\n        # 48-58. We would like to remark that in this paper in formula (9) the\r\n        # left side of the equation should be divided by two.\r\n        #\r\n        # Given N spiketrains with n entries on average the run-time complexity is\r\n        # O(N^2 * n). O(N^2 + N * n) memory will be needed.\r\n\r\n        if len(spiketrains) <= 0:\r\n            return np.zeros((0, 0))\r\n\r\n        if not presorted:\r\n            spiketrains = [v.copy() for v in spiketrains]\r\n            for v in spiketrains:\r\n                v.sort()\r\n\r\n        sizes = np.asarray([v.size for v in spiketrains])\r\n        values = np.empty((len(spiketrains), max(1, sizes.max())))\r\n        values.fill(np.nan)\r\n        for i, v in enumerate(spiketrains):\r\n            if v.size > 0:\r\n                values[i, :v.size] = \\\r\n                    (v / tau)\r\n\r\n        exp_diffs = np.exp(values[:, :-1] - values[:, 1:])\r\n        markage = np.zeros(values.shape)\r\n        for u in range(len(spiketrains)):\r\n            markage[u, 0] = 0\r\n            for i in range(sizes[u] - 1):\r\n                markage[u, i + 1] = (markage[u, i] + 1.0) * exp_diffs[u, i]\r\n\r\n        # Same spiketrain terms\r\n        D = np.empty((len(spiketrains), len(spiketrains)))\r\n        D[np.diag_indices_from(D)] = sizes + 2.0 * np.sum(markage, axis=1)\r\n\r\n        # Cross spiketrain terms\r\n        for u in range(D.shape[0]):\r\n            all_ks = np.searchsorted(values[u], values, 'left') - 1\r\n            for v in range(u):\r\n                js = np.searchsorted(values[v], values[u], 'right') - 1\r\n                ks = all_ks[v]\r\n                slice_j = np.s_[np.searchsorted(js, 0):sizes[u]]\r\n                slice_k = np.s_[np.searchsorted(ks, 0):sizes[v]]\r\n                D[u, v] = np.sum(\r\n                    np.exp(values[v][js[slice_j]] - values[u][slice_j]) *\r\n                    (1.0 + markage[v][js[slice_j]]))\r\n                D[u, v] += np.sum(\r\n                    np.exp(values[u][ks[slice_k]] - values[v][slice_k]) *\r\n                    (1.0 + markage[u][ks[slice_k]]))\r\n                D[v, u] = D[u, v]\r\n\r\n        return D\r\n\r\n    @staticmethod\r\n    @njit\r\n    def ISI_ratio(array_ISI, array_ratio):\r\n        for i in range(array_ISI.shape[0]):  # xisi\r\n            for j in range(array_ISI.shape[0]):  # y\r\n                if not j > i:\r\n                    for tt in range(array_ISI.shape[1]):\r\n                        if array_ISI[i, tt] <= array_ISI[j, tt]:\r\n                            array_ratio[i, j, tt] = array_ISI[i, tt] / array_ISI[j, tt] - 1\r\n                            array_ratio[j, i, tt] = array_ISI[i, tt] / array_ISI[j, tt] - 1\r\n                        else:\r\n                            array_ratio[i, j, tt] = -(array_ISI[j, tt] / array_ISI[i, tt] - 1)\r\n                            array_ratio[j, i, tt] = -(array_ISI[j, tt] / array_ISI[i, tt] - 1)\r\n        return array_ratio\r\n\r\n    def get_new_List_C(self):\r\n        for l in range(len(self.List_C)):\r\n            for c in range(len(self.List_C[0])):\r\n                self.List_C[l, c] = float(self.List_C_e[l * len(self.List_C[0]) + c].text())\r\n                # if c == 4:\r\n                #     self.List_C[l, c] = float(self.List_C_e[l*len(self.List_C[0])+c].text() )\r\n                # else:\r\n                #     self.List_C[l, c] = int(float(self.List_C_e[l*len(self.List_C[0])+c].text() ))\r\n\r\n    def get_new_List_Var(self):\r\n        for l in range(len(self.List_Var)):\r\n            for c in range(len(self.List_Var)):\r\n                self.List_Var[l, c] = float(self.List_Var_e[l * len(self.List_Var) + c].text())\r\n\r\n    pyqtSlot(int)\r\n    def PlaceCell_msg(self, cellnb):\r\n        if cellnb == -2:\r\n            self.msg = msg_wait(\"Cell Placement in progress\\n\"+'0/'+str(np.sum(self.CC.Layer_nbCells))+\"\\nPlease wait.\")\r\n            self.msg.setStandardButtons(QMessageBox.Cancel)\r\n            self.PlaceCell_msg_cnacel = False\r\n            self.parent.processEvents()\r\n        elif cellnb == -1:\r\n            self.PlaceCell_msg_cnacel = False\r\n        else:\r\n            self.msg.setText(\"Cell Placement in progress\\n\"+str(cellnb)+'/'+str(np.sum(self.CC.Layer_nbCells))+\"\\nPlease wait.\")\r\n            self.parent.processEvents()\r\n\r\n    def connectivityCell_func(self):\r\n        seed = int(self.seed_place.text())\r\n        self.Connectivitymatrix, self.Connectivityweight = self.CC.Create_Connectivity_Matrix(seed=seed)\r\n        self.update_model_with_same_param()\r\n        self.masceneCM.update()\r\n\r\n    def EField_Conv_Fun(self):\r\n        fileName = QFileDialog.getOpenFileName(self, \"E-Field text file\", \"\", \"txt (*.txt)\")\r\n        if fileName[0] == '':\r\n            return\r\n        if fileName[1] == \"txt (*.txt)\":\r\n            try:\r\n                n = np.loadtxt(fileName[0], comments='%')\r\n\r\n                x = n[:, 0] * 1000\r\n                xmin = np.round(np.min(x) * 1000000) / 1000000\r\n                xmax = np.round(np.max(x) * 1000000) / 1000000\r\n                xsteps = len(set(x))\r\n                xrange = abs(xmax - xmin)\r\n                y = n[:, 1] * 1000\r\n                ymin = np.round(np.min(y) * 1000000) / 1000000\r\n                ymax = np.round(np.max(y) * 1000000) / 1000000\r\n                ysteps = len(set(y))\r\n                yrange = abs(ymax - ymin)\r\n                z = n[:, 2] * 1000\r\n                zmin = np.round(np.min(z) * 1000000) / 1000000\r\n                zmax = np.round(np.max(z) * 1000000) / 1000000\r\n                zsteps = len(set(z))\r\n                zrange = abs(zmax - zmin)\r\n\r\n                E = n[:, 4:] * 1000\r\n                Er = np.zeros((xsteps, ysteps, zsteps, 3), dtype=np.float32)\r\n                i = 0\r\n                for kx in range(xsteps):\r\n                    for ky in range(ysteps):\r\n                        for kz in range(zsteps):\r\n                            Er[kx, ky, kz, :] = E[i, :]\r\n                            i += 1\r\n\r\n                mdic = {\"Er\": Er,\r\n                        \"xmin\": xmin,\r\n                        \"xmax\": xmax,\r\n                        \"xsteps\": xsteps,\r\n                        \"xrange\": xrange,\r\n                        \"ymin\": ymin,\r\n                        \"ymax\": ymax,\r\n                        \"ysteps\": ysteps,\r\n                        \"yrange\": yrange,\r\n                        \"zmin\": zmin,\r\n                        \"zmax\": zmax,\r\n                        \"zsteps\": zsteps,\r\n                        \"zrange\": zrange, }\r\n\r\n                fileName = QFileDialog.getSaveFileName(caption='Save parameters',\r\n                                                       directory=os.path.splitext(fileName[0])[0] + '.mat',\r\n                                                       filter=\"mat (*.mat)\")\r\n                if (fileName[0] == ''):\r\n                    return\r\n                if os.path.splitext(fileName[0])[1] == '':\r\n                    fileName = (fileName[0] + '.mat', fileName[1])\r\n                if fileName[1] == \"mat (*.mat)\":\r\n                    scipy.io.savemat(fileName[0], mdic)\r\n            except:\r\n                msg_cri(s='Something went wrong')\r\n\r\n    def get_Efield_path(self, ):\r\n        extension = \"mat\"\r\n        fileName = QFileDialog.getOpenFileName(caption='Load mesh file', filter=extension + \" (*.\" + extension + \")\")\r\n        if (fileName[0] == ''):\r\n            return\r\n        if os.path.splitext(fileName[0])[1] == '':\r\n            fileName = (fileName[0] + '.' + extension, fileName[1])\r\n        if fileName[1] == extension + \" (*.\" + extension + \")\":\r\n            try:\r\n                self.EField_file_TE.setText(fileName[0])\r\n                self.EField_Load_file()\r\n            except:\r\n                self.EField_file_TE.setText('')\r\n                msg_cri('VTK file cannot be loaded.\\nPlease, load another one.')\r\n\r\n    def EField_Load_file(self):\r\n        mat = scipy.io.loadmat(self.EField_file_TE.text())\r\n        self.EFieldFile = {}\r\n        for key in [key for key in mat.keys() if not '__' in key]:\r\n            self.EFieldFile[key] = mat[key]  # [0][0]\r\n            if self.EFieldFile[key].shape == (1, 1):\r\n                self.EFieldFile[key] = self.EFieldFile[key][0][0]\r\n\r\n        self.EField_XYZ_comp()\r\n        self.EField_Rot_XY_comp()\r\n        self.EFieldFile['Er'] = self.EFieldFile['Er'].astype(np.float64)\r\n\r\n        self.EField_OnOff_CB.setEnabled(True)\r\n\r\n    def EField_XYZ_comp(self):\r\n        xT = float(self.EField_TranslationX_LE.text())\r\n        yT = float(self.EField_TranslationY_LE.text())\r\n        zT = float(self.EField_TranslationZ_LE.text())\r\n\r\n        self.EFieldFile['x'] = np.linspace(-self.EFieldFile['xrange']/2+xT,self.EFieldFile['xrange']/2+xT, self.EFieldFile['xsteps'])\r\n        self.EFieldFile['y'] = np.linspace(-self.EFieldFile['yrange']/2+yT,self.EFieldFile['yrange']/2+yT, self.EFieldFile['ysteps'])\r\n        self.EFieldFile['z'] = np.linspace(0+zT,self.EFieldFile['zrange']+zT, self.EFieldFile['zsteps'])\r\n\r\n    def EField_Rot_XY_comp(self):\r\n        self.EField_theta = float(self.EField_RotationXY_LE.text())\r\n        # sintheta = np.sin(theta)\r\n        # costheta = np.cos(theta)\r\n        # for ix in range(self.EFieldFile['Er'].shape[0]):\r\n        #     x = self.EFieldFile['x'][ix]\r\n        #     for iy in range(self.EFieldFile['Er'].shape[1]):\r\n        #         y = self.EFieldFile['y'][iy]\r\n        #         for iz in range(self.EFieldFile['Er'].shape[2]):\r\n        #             x2 = self.EFieldFile['Er'][ix,iy,iz,0] + x\r\n        #             y2 = self.EFieldFile['Er'][ix,iy,iz,1] + y\r\n        #             xp = x2 * costheta - y2 * sintheta\r\n        #             yp = x2 * sintheta + y2 * costheta\r\n        #             self.EFieldFile['Er'][ix,iy,iz,0] = xp\r\n        #             self.EFieldFile['Er'][ix,iy,iz,1] = yp\r\n        # x = self.EFieldFile['x']\r\n        # b = np.repeat(x[:, np.newaxis], self.EFieldFile['Er'].shape[1], axis=1)\r\n        # b2 = np.repeat(b[:, :, np.newaxis], self.EFieldFile['Er'].shape[2], axis=2)\r\n        # y = self.EFieldFile['y']\r\n        # c = np.repeat(y[:, np.newaxis], self.EFieldFile['Er'].shape[1], axis=1)\r\n        # c2 = np.repeat(c[:, :, np.newaxis], self.EFieldFile['Er'].shape[2], axis=2)\r\n        #\r\n        # x2 = self.EFieldFile['Er'][:,:,:,0] + b2\r\n        # y2 = self.EFieldFile['Er'][:,:,:,1] + c2\r\n        # xp = x2 * costheta - y2 * sintheta\r\n        # yp = x2 * sintheta + y2 * costheta\r\n        #\r\n        # self.EFieldFile['Er'][:,:,:,0] = xp\r\n        # self.EFieldFile['Er'][:,:,:,1] = yp\r\n\r\n        # x = self.EFieldFile['x']\r\n        # y = self.EFieldFile['y']\r\n        # xp = x * np.cos(theta) - 0 * np.sin(theta)\r\n        # yp = 0 * np.sin(theta) + y * np.cos(theta)\r\n        # self.EFieldFile['x'] = xp\r\n        # self.EFieldFile['y'] = yp\r\n\r\n\r\n        # x = self.EFieldFile['x']\r\n        # b = np.repeat(x[:, np.newaxis], self.EFieldFile['Er'].shape[1], axis=1)\r\n        # b2 = np.repeat(b[:, :, np.newaxis], self.EFieldFile['Er'].shape[2], axis=2)\r\n        # y = self.EFieldFile['y']\r\n        # c = np.repeat(y[:, np.newaxis], self.EFieldFile['Er'].shape[1], axis=1)\r\n        # c2 = np.repeat(c[:, :, np.newaxis], self.EFieldFile['Er'].shape[2], axis=2)\r\n        #\r\n        # self.EFieldFile['Er'][:,:,:,0] -= b2\r\n        # self.EFieldFile['Er'][:,:,:,1] -= c2\r\n\r\n    def EField_Const_fun(self):\r\n        Er = np.array([float(self.EField_Const_Ex.text()) ,float(self.EField_Const_Ey.text()) ,float(self.EField_Const_Ez.text())])\r\n        self.EField_Const = {\"Er\": Er}\r\n\r\n    def EField_Display_Fun(self):\r\n            if self.EField_Const_RB.isChecked():\r\n                self.EField_Const_fun()\r\n                self.EField = self.EField_Const\r\n                self.NewCreate_EField_view.append(Graph_EField_VTK(self,fromfile = False))\r\n                self.NewCreate_EField_view[-1].show()\r\n\r\n            elif self.EField_File_RB.isChecked():\r\n                self.EField_Load_file()\r\n                self.EField = self.EFieldFile\r\n                self.NewCreate_EField_view.append(Graph_EField_VTK(self))\r\n                self.NewCreate_EField_view[-1].show()\r\n        # except:\r\n        #     msg_cri(\"Display not available\")\r\n\r\n    def PlaceCell_func(self):\r\n        seed = int(self.seed_place.text())\r\n        placement = self.cell_placement_CB.currentText()\r\n        print('placement')\r\n        self.CC.updateCell.something_happened.connect(self.PlaceCell_msg)\r\n        self.CellPosition = self.CC.PlaceCell_func(placement,seed = seed)\r\n        print('Create_Connectivity_Matrices')\r\n        t0 = time.time()\r\n        self.Connectivitymatrix, self.Connectivityweight = self.CC.Create_Connectivity_Matrix(seed = seed)\r\n        print(time.time() - t0)\r\n        self.CC.updateCell.something_happened.disconnect(self.PlaceCell_msg)\r\n\r\n        self.CellPosition = np.array(self.CellPosition)\r\n        self.createCells = True\r\n\r\n        # # self.Create_Connectivity_Matrices()\r\n        # # print(self.ConnectivityMatrix)\r\n        # print('List_Names')\r\n        self.List_Names = []\r\n        self.List_Colors = []\r\n        self.List_Neurone_type = []\r\n\r\n        colors_PYR = ['#000000', '#9370db', '#9400d3', '#8b008b', '#4b0082']\r\n        for i in range(5):\r\n            s = ''\r\n            if i == 0:\r\n                s = s + (\"1_\")\r\n            elif i == 1:\r\n                s = s + (\"23_\")\r\n            elif i == 2:\r\n                s = s + (\"4_\")\r\n            elif i == 3:\r\n                s = s + (\"5_\")\r\n            elif i == 4:\r\n                s = s + (\"6_\")\r\n            Names = []\r\n            Colors = []\r\n            Neurone_type = []\r\n            for j in range(self.CC.NB_PYR[i]):\r\n                Names.append(s + 'PYR_' + str(j))\r\n                Colors.append(colors_PYR[i])\r\n                Neurone_type.append(1)\r\n\r\n            for j in range(self.CC.NB_PV[i]):\r\n                Names.append(s + 'PV_' + str(j))\r\n                Colors.append('#228B22')\r\n                Neurone_type.append(2)\r\n\r\n            for j in range(self.CC.NB_SST[i]):\r\n                Names.append(s + 'SST_' + str(j))\r\n                Colors.append('#0000cd')\r\n                Neurone_type.append(3)\r\n\r\n            for j in range(self.CC.NB_VIP[i]):\r\n                Names.append(s + 'VIP_' + str(j))\r\n                Colors.append('#cd5c5c')\r\n                Neurone_type.append(4)\r\n\r\n            for j in range(self.CC.NB_RLN[i]):\r\n                Names.append(s + 'RLN_' + str(j))\r\n                Colors.append('#FFA500')\r\n                Neurone_type.append(5)\r\n\r\n            self.List_Colors.append(Colors)\r\n            self.List_Names.append(Names)\r\n            self.List_Neurone_type.append(Neurone_type)\r\n\r\n        # self.List_Names = ['PYR']*self.Nb_of_PYR + ['BAS']*self.Nb_of_BAS + ['SOM']*self.Nb_of_SOM + ['BIS']*self.Nb_of_BIS\r\n        # self.List_Colors = [self.list_neurone_color[0]]*self.Nb_of_PYR + \\\r\n        #                    [self.list_neurone_color[1]]*self.Nb_of_BAS + \\\r\n        #                    [self.list_neurone_color[2]]*self.Nb_of_SOM + \\\r\n        #                    [self.list_neurone_color[3]]*self.Nb_of_BIS\r\n        #\r\n        # print('List_PYR_Stimulated')\r\n        # for cell in self.List_PYR_Stimulated:\r\n        #     self.List_Names[cell] = 'PYR_STIM'\r\n        #     self.List_Colors[cell] = self.list_neurone_color[4]\r\n        # print('electrode_placement_func')\r\n        self.update_Model()\r\n        self.electrode_placement_func()\r\n        self.masceneCM.update()\r\n        self.update_graph()\r\n\r\n    def scalesize_func(self):\r\n        exPopup = Rescalesize(self, x=self.x_e.text(), y=self.y_e.text(), z=self.z_e.text())\r\n        # exPopup.show()\r\n        if exPopup.exec_() == QDialog.Accepted:\r\n            # exPopup.editfromlabel()\r\n            # self.parent.Graph_Items[cellId] = exPopup.item\r\n            print('Accepted')\r\n            xs = float(exPopup.xs_e.text())\r\n            ys = float(exPopup.ys_e.text())\r\n            zs = float(exPopup.zs_e.text())\r\n            self.x_e.setText(str(float(self.x_e.text()) * xs))\r\n            self.y_e.setText(str(float(self.y_e.text()) * ys))\r\n            self.z_e.setText(str(float(self.z_e.text()) * zs))\r\n\r\n            self.CellPosition = self.CellPosition * np.array([xs, ys, zs])\r\n\r\n            self.update_graph()\r\n\r\n\r\n        else:\r\n            print('Cancelled')\r\n        exPopup.deleteLater()\r\n\r\n    def update_graph(self):\r\n        if self.displayVTK_CB.isChecked():\r\n            self.Graph_viewer.draw_Graph()\r\n            self.Graph_viewer.set_center()\r\n            self.parent.processEvents()\r\n\r\n    def electrode_placement_func(self):\r\n        self.electrode_pos = [float(x.text()) for x in [self.electrode_x_e, self.electrode_y_e, self.electrode_z_e]]\r\n        self.electrode_disk = [self.electrod_disk_CB.isChecked(),\r\n                               -float(self.electrode_radius_e.text()),\r\n                               -float(self.electrode_angle1_e.text()),\r\n                               float(self.electrode_angle2_e.text())]\r\n        self.update_graph()\r\n\r\n    def bruitGaussien(self, s, m):\r\n        return np.random.normal(m, s)\r\n\r\n    def Create_Connectivity_Matrices_sparse(self):\r\n        print('ConnectivityMatrix')\r\n        # cordinate_target_source = []\r\n        cordinate_target_source = [[] for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[3])]\r\n        # self.ConnectivityMatrix = sparse.coo_matrix(([], ([], [])), shape=(self.Nb_of_PYR_BAS_SOM_BIS_sum[3], self.Nb_of_PYR_BAS_SOM_BIS_sum[3]))\r\n        print('CellDistances')\r\n        self.CellDistances = distance.cdist(self.CellPosition, self.CellPosition, 'euclidean')\r\n\r\n        print('Nb_of_PYR')\r\n        if self.Nb_of_PYR > 0:\r\n            for i in range(self.Nb_of_PYR):\r\n                if i in self.List_PYR_Stimulated:\r\n                    # loop = 3\r\n                    # pickedcell = np.array([-1] * loop)\r\n                    # size = np.array([-1] * loop)\r\n                    # pickcell_simple_fun(size, loop, self.Nb_of_PYR_Stimulated, self.Nb_of_PYR_BAS_SOM_BIS_sum[0], pickedcell)\r\n                    # for k in pickedcell:\r\n                    #     cordinate_target_source[k].append(i)\r\n                    #     # cordinate_target_source.append([i, k, 1])\r\n                    #     # self.ConnectivityMatrix[k, i] = 1\r\n                    continue\r\n\r\n                pickedcell_list = []\r\n                loop = int(self.List_C[0, 0])\r\n                if loop > (self.Nb_of_PYR - self.Nb_of_PYR_Stimulated) - 1:\r\n                    loop = (self.Nb_of_PYR - self.Nb_of_PYR_Stimulated) - 1\r\n                if not loop <= 0:\r\n                    # sortedIndex = np.zeros( self.Nb_of_PYR_BAS_SOM_BIS_sum[0]-self.Nb_of_PYR_Stimulated,dtype=np.int64)\r\n                    # argsort_list_fun(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]], self.Nb_of_PYR_Stimulated, sortedIndex)\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[0, 0] - int(self.List_C[0, 0])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_Stimulated, self.Nb_of_PYR_BAS_SOM_BIS_sum[0])])\r\n\r\n\r\n                loop = int(self.List_C[0, 1])\r\n                if loop > self.Nb_of_BAS:\r\n                    loop = self.Nb_of_BAS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[0, 1] - int(self.List_C[0, 1])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[0], self.Nb_of_PYR_BAS_SOM_BIS_sum[1])])\r\n\r\n                loop = int(self.List_C[0, 2])\r\n                if loop > self.Nb_of_SOM:\r\n                    loop = self.Nb_of_SOM\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                ajout = self.List_C[0, 2] - int(self.List_C[0, 2])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[1], self.Nb_of_PYR_BAS_SOM_BIS_sum[2])])\r\n\r\n                loop = int(self.List_C[0, 3])\r\n                if loop > self.Nb_of_BIS:\r\n                    loop = self.Nb_of_BIS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[0, 3] - int(self.List_C[0, 3])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[3], self.Nb_of_PYR_BAS_SOM_BIS_sum[3])])\r\n\r\n\r\n                #For connecting too stym CA3\r\n                loop = int(self.List_C[0, 4])\r\n                if loop > self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_simple_fun(size, loop,0, self.Nb_of_PYR_Stimulated, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[0, 4] - int(self.List_C[0, 4])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(0, self.Nb_of_PYR_Stimulated)])\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    cordinate_target_source[i].append(k)\r\n                    # cordinate_target_source.append([k, i, 1])\r\n                    # self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Nb_of_BAS')\r\n        if self.Nb_of_BAS > 0:\r\n            for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[0], self.Nb_of_PYR_BAS_SOM_BIS_sum[1]):\r\n\r\n                pickedcell_list = []\r\n                loop = int(self.List_C[1, 0])\r\n                if loop > self.Nb_of_PYR - self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR - self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[1, 0] - int(self.List_C[1, 0])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_Stimulated, self.Nb_of_PYR_BAS_SOM_BIS_sum[0])])\r\n\r\n                loop = int(self.List_C[1, 1])\r\n                if loop > (self.Nb_of_BAS)-1:\r\n                    loop = (self.Nb_of_BAS)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[1, 1] - int(self.List_C[1, 1])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[0], self.Nb_of_PYR_BAS_SOM_BIS_sum[1])])\r\n\r\n                loop = int(self.List_C[1, 2])\r\n                if loop > self.Nb_of_SOM:\r\n                    loop = self.Nb_of_SOM\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[1, 2] - int(self.List_C[1, 2])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[1], self.Nb_of_PYR_BAS_SOM_BIS_sum[2])])\r\n\r\n                loop = int(self.List_C[1, 3])\r\n                if loop > self.Nb_of_BIS:\r\n                    loop = self.Nb_of_BIS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[1, 3] - int(self.List_C[1, 3])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[2], self.Nb_of_PYR_BAS_SOM_BIS_sum[3])])\r\n\r\n                # For connecting too stym CA3\r\n                loop = int(self.List_C[1, 4])\r\n                if loop > self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_simple_fun(size, loop, 0, self.Nb_of_PYR_Stimulated, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[1, 4] - int(self.List_C[1, 4])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(0, self.Nb_of_PYR_Stimulated)])\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    cordinate_target_source[i].append(k)\r\n                    # cordinate_target_source.append([k, i, 1])\r\n                    # self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Nb_of_OLM')\r\n        if self.Nb_of_SOM > 0:\r\n            for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[1], self.Nb_of_PYR_BAS_SOM_BIS_sum[2]):\r\n\r\n                pickedcell_list = []\r\n                loop = int(self.List_C[2, 0])\r\n                if loop > self.Nb_of_PYR - self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR - self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[2, 0] - int(self.List_C[2, 0])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_Stimulated, self.Nb_of_PYR_BAS_SOM_BIS_sum[0])])\r\n\r\n                loop = int(self.List_C[2, 1])\r\n                if loop > self.Nb_of_BAS:\r\n                    loop = self.Nb_of_BAS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[2, 1] - int(self.List_C[2, 1])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[0], self.Nb_of_PYR_BAS_SOM_BIS_sum[1])])\r\n\r\n                loop = int(self.List_C[2, 2])\r\n                if loop > (self.Nb_of_SOM)-1:\r\n                    loop = (self.Nb_of_SOM)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[2, 2] - int(self.List_C[2, 2])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[1], self.Nb_of_PYR_BAS_SOM_BIS_sum[2])])\r\n\r\n                loop = int(self.List_C[2, 3])\r\n                if loop > self.Nb_of_BIS:\r\n                    loop = self.Nb_of_BIS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[2, 3] - int(self.List_C[2, 3])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[2], self.Nb_of_PYR_BAS_SOM_BIS_sum[3])])\r\n\r\n                # For connecting too stym CA3\r\n                loop = int(self.List_C[2, 4])\r\n                if loop > self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_simple_fun(size, loop, 0, self.Nb_of_PYR_Stimulated, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[2, 4] - int(self.List_C[2, 4])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(0, self.Nb_of_PYR_Stimulated)])\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    cordinate_target_source[i].append(k)\r\n                    # cordinate_target_source.append([k, i, 1])\r\n                    # self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Nb_of_BIS')\r\n        if self.Nb_of_BIS > 0:\r\n            # count = 0\r\n            for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[2], self.Nb_of_PYR_BAS_SOM_BIS_sum[3]):\r\n                # if count < self.Nb_of_BIS and count < self.Nb_of_PYR_Stimulated:\r\n                #     pickedcell_list = []\r\n                #     pickedcell_list.append([count])  # connection entre cell CA3 est BIS\r\n                #     count += 1\r\n                # else:\r\n                #     pickedcell_list = []\r\n\r\n                pickedcell_list = []\r\n                loop = int(self.List_C[3, 0])\r\n                if loop > self.Nb_of_PYR - self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR - self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[3, 0] - int(self.List_C[3, 0])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_Stimulated, self.Nb_of_PYR_BAS_SOM_BIS_sum[0])])\r\n\r\n                loop = int(self.List_C[3, 1])\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[3, 1] - int(self.List_C[3, 1])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[0], self.Nb_of_PYR_BAS_SOM_BIS_sum[1])])\r\n\r\n                loop = int(self.List_C[3, 2])\r\n                if loop > self.Nb_of_SOM:\r\n                    loop = self.Nb_of_SOM\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[3, 2] - int(self.List_C[3, 2])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[1], self.Nb_of_PYR_BAS_SOM_BIS_sum[2])])\r\n\r\n                loop = int(self.List_C[3, 3])\r\n                if loop > (self.Nb_of_BIS)-1:\r\n                    loop = (self.Nb_of_BIS)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[3, 3] - int(self.List_C[3, 3])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(self.Nb_of_PYR_BAS_SOM_BIS_sum[2], self.Nb_of_PYR_BAS_SOM_BIS_sum[3])])\r\n\r\n                # For connecting too stym CA3\r\n                loop = int(self.List_C[3, 4])\r\n                if loop > self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_simple_fun(size, loop, 0, self.Nb_of_PYR_Stimulated, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n                ajout = self.List_C[3, 4] - int(self.List_C[3, 4])\r\n                randval = np.random.uniform()\r\n                if randval < ajout:\r\n                    pickedcell_list.append([np.random.randint(0, self.Nb_of_PYR_Stimulated)])\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    cordinate_target_source[i].append(k)\r\n                    # cordinate_target_source.append([k, i, 1])\r\n                    # self.ConnectivityMatrix[i, k] = 1\r\n        self.ConnectivityMatrix = np.array([np.array(c) for c in cordinate_target_source])\r\n        # self.ConnectivityMatrix = sparse.coo_matrix((cordinate_target_source[:,2], (cordinate_target_source[:,1], cordinate_target_source[:,0])), shape=(self.Nb_of_PYR_BAS_SOM_BIS_sum[3], self.Nb_of_PYR_BAS_SOM_BIS_sum[3]))\r\n\r\n        print('Compute_synaptic_connections')\r\n        self.Compute_synaptic_connections_sparse()\r\n        # self.Compute_synaptic_connections()\r\n\r\n        print('update fig')\r\n        self.masceneCM.update()\r\n        print('update done')\r\n\r\n    def Create_Connectivity_Matrices(self):\r\n        print('ConnectivityMatrix')\r\n        self.ConnectivityMatrix = np.zeros((self.Nb_of_PYR_BAS_SOM_BIS_sum[3],self.Nb_of_PYR_BAS_SOM_BIS_sum[3]))\r\n        # tirer n nombre parmis nombre de neurones / Tirage Alatoire par loi gaussienne\r\n\r\n        print('CellDistances')\r\n        self.CellDistances = distance.cdist(self.CellPosition, self.CellPosition,'euclidean')\r\n\r\n        print('Nb_of_PYR')\r\n        if self.Nb_of_PYR > 0:\r\n            for i in range(self.Nb_of_PYR):\r\n\r\n                if i in self.List_PYR_Stimulated:\r\n                    loop = 3\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_simple_fun(size, loop, self.Nb_of_PYR_Stimulated, self.Nb_of_PYR_BAS_SOM_BIS_sum[0], pickedcell)\r\n                    for k in pickedcell:\r\n                        self.ConnectivityMatrix[k, i] = 1\r\n                    continue\r\n\r\n                pickedcell_list = []\r\n                loop = self.List_C[0, 0]\r\n                if loop > (self.Nb_of_PYR - self.Nb_of_PYR_Stimulated)-1:\r\n                    loop = (self.Nb_of_PYR - self.Nb_of_PYR_Stimulated)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 0], self.CellDistances[i,:], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[0, 1]\r\n                if loop > self.Nb_of_BAS:\r\n                    loop = self.Nb_of_BAS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[0, 2]\r\n                if loop > self.Nb_of_SOM:\r\n                    loop = self.Nb_of_SOM\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[0, 3]\r\n                if loop > self.Nb_of_BIS:\r\n                    loop = self.Nb_of_BIS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[0, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Nb_of_BAS')\r\n        if self.Nb_of_BAS > 0:\r\n            for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[0], self.Nb_of_PYR_BAS_SOM_BIS_sum[1]):\r\n\r\n                pickedcell_list = []\r\n                loop = self.List_C[1, 0]\r\n                if loop > self.Nb_of_PYR - self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR - self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[1, 1]\r\n                if loop > (self.Nb_of_BAS)-1:\r\n                    loop = (self.Nb_of_BAS)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[1, 2]\r\n                if loop > self.Nb_of_SOM:\r\n                    loop = self.Nb_of_SOM\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[1, 3]\r\n                if loop > self.Nb_of_BIS:\r\n                    loop = self.Nb_of_BIS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[1, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Nb_of_OLM')\r\n        if self.Nb_of_SOM > 0:\r\n            for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[1], self.Nb_of_PYR_BAS_SOM_BIS_sum[2]):\r\n\r\n                pickedcell_list = []\r\n                loop = self.List_C[2, 0]\r\n                if loop > self.Nb_of_PYR - self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR - self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[2, 1]\r\n                if loop > self.Nb_of_BAS:\r\n                    loop = self.Nb_of_BAS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[2, 2]\r\n                if loop > (self.Nb_of_SOM)-1:\r\n                    loop = (self.Nb_of_SOM)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[2, 3]\r\n                if loop > self.Nb_of_BIS:\r\n                    loop = self.Nb_of_BIS\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[2, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Nb_of_BIS')\r\n        if self.Nb_of_BIS > 0:\r\n            count = 0\r\n            for i in range(self.Nb_of_PYR_BAS_SOM_BIS_sum[2], self.Nb_of_PYR_BAS_SOM_BIS_sum[3]):\r\n                if count <self.Nb_of_BIS and count < self.Nb_of_PYR_Stimulated:\r\n                    pickedcell_list = []\r\n                    pickedcell_list.append([count]) # connection entre cell CA3 est BIS\r\n                    count += 1\r\n                else:\r\n                    pickedcell_list = []\r\n\r\n                # pickedcell_list = []\r\n                loop = self.List_C[3, 0]\r\n                if loop > self.Nb_of_PYR - self.Nb_of_PYR_Stimulated:\r\n                    loop = self.Nb_of_PYR - self.Nb_of_PYR_Stimulated\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_Stimulated: self.Nb_of_PYR_BAS_SOM_BIS_sum[0]]) + self.Nb_of_PYR_Stimulated\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 0], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[3, 1]\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[0]: self.Nb_of_PYR_BAS_SOM_BIS_sum[1]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[0]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 1], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[3, 2]\r\n                if loop > self.Nb_of_SOM:\r\n                    loop = self.Nb_of_SOM\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[1]: self.Nb_of_PYR_BAS_SOM_BIS_sum[2]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[1]\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 2], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                loop = self.List_C[3, 3]\r\n                if loop > (self.Nb_of_BIS)-1:\r\n                    loop = (self.Nb_of_BIS)-1\r\n                if not loop <= 0:\r\n                    sortedIndex = np.argsort(self.CellDistances[i, self.Nb_of_PYR_BAS_SOM_BIS_sum[2]: self.Nb_of_PYR_BAS_SOM_BIS_sum[3]]) + self.Nb_of_PYR_BAS_SOM_BIS_sum[2]\r\n                    sortedIndex = np.delete(sortedIndex, 0)\r\n                    pickedcell = np.array([-1] * loop)\r\n                    size = np.array([-1] * loop)\r\n                    pickcell_gauss_fun(size, loop, 0, self.List_Var[3, 3], self.CellDistances[i, :], sortedIndex, pickedcell)\r\n                    pickedcell_list.append(pickedcell)\r\n\r\n                for k in [item for sublist in pickedcell_list for item in sublist]:\r\n                    self.ConnectivityMatrix[i, k] = 1\r\n\r\n        print('Compute_synaptic_connections')\r\n        self.Compute_synaptic_connections()\r\n\r\n        print('update fig')\r\n        self.masceneCM.update()\r\n        print('update done')\r\n\r\n    def Compute_synaptic_connections_sparse(self):\r\n        self.PreSynaptic_Cell_AMPA = []\r\n        self.PreSynaptic_Cell_GABA = []\r\n        self.PreSynaptic_Soma_Dend_AMPA = []\r\n        self.PreSynaptic_Soma_Dend_AMPA_not = []\r\n        self.PreSynaptic_Soma_Dend_GABA = []\r\n        self.PreSynaptic_Soma_Dend_GABA_not = []\r\n        for i, c in enumerate(self.List_Neurone_type):\r\n            # convect = self.ConnectivityMatrix[i, :]\r\n            # convect = self.ConnectivityMatrix.getrow(i).todense()\r\n            # convect = np.where(convect == 1)[0]\r\n            convect = self.ConnectivityMatrix[i]\r\n            convect_AMPA = []\r\n            convect_GABA = []\r\n            convect_Soma_Dend_AMPA = []\r\n            convect_Soma_Dend_GABA = []\r\n            for k in convect:\r\n                if self.List_Neurone_type[k] in [1, 2]:  # si from CA1 ou CA3\r\n                    convect_AMPA.append(k)\r\n                    if c in [3, 4, 5]:  # interneurones\r\n                        convect_Soma_Dend_AMPA.append(1)\r\n                    else:\r\n                        if self.List_Neurone_type[k] in [1, 2, 4, 5]:  # si from CA1, CA3, SOM, ou BIS\r\n                            convect_Soma_Dend_AMPA.append(0)\r\n                        else:  # si from BAS\r\n                            convect_Soma_Dend_AMPA.append(1)\r\n\r\n                else:  # from interneurone\r\n                    convect_GABA.append(k)\r\n                    if c in [3, 4, 5]:  # interneurones\r\n                        convect_Soma_Dend_GABA.append(1)\r\n                    else:\r\n                        if self.List_Neurone_type[k] in [1, 2, 4, 5]:  # si from CA1, CA3, SOM, ou BIS\r\n                            convect_Soma_Dend_GABA.append(0)\r\n                        else:  # si from BAS\r\n                            convect_Soma_Dend_GABA.append(1)\r\n\r\n            self.PreSynaptic_Cell_AMPA.append(convect_AMPA)\r\n            self.PreSynaptic_Cell_GABA.append(convect_GABA)\r\n            self.PreSynaptic_Soma_Dend_AMPA.append(np.array(convect_Soma_Dend_AMPA))\r\n            self.PreSynaptic_Soma_Dend_AMPA_not.append(np.abs(np.array(convect_Soma_Dend_AMPA) - 1))\r\n            self.PreSynaptic_Soma_Dend_GABA.append(np.array(convect_Soma_Dend_GABA))\r\n            self.PreSynaptic_Soma_Dend_GABA_not.append(np.abs(np.array(convect_Soma_Dend_GABA) - 1))\r\n\r\n    def Compute_synaptic_connections(self):\r\n        self.PreSynaptic_Cell_AMPA = []\r\n        self.PreSynaptic_Cell_GABA = []\r\n        self.PreSynaptic_Soma_Dend_AMPA = []\r\n        self.PreSynaptic_Soma_Dend_AMPA_not = []\r\n        self.PreSynaptic_Soma_Dend_GABA = []\r\n        self.PreSynaptic_Soma_Dend_GABA_not = []\r\n        for i, c in enumerate(self.List_Neurone_type):\r\n            convect = self.ConnectivityMatrix[i, :]\r\n            convect = np.where(convect == 1)[0]\r\n            convect_AMPA = []\r\n            convect_GABA = []\r\n            convect_Soma_Dend_AMPA = []\r\n            convect_Soma_Dend_GABA = []\r\n            for k in convect:\r\n                if self.List_Neurone_type[k] in [1, 2]:  # si from CA1 ou CA3\r\n                    convect_AMPA.append(k)\r\n                    if c in [3, 4, 5]:  # interneurones\r\n                        convect_Soma_Dend_AMPA.append(1)\r\n                    else:\r\n                        if self.List_Neurone_type[k] in [1, 2, 4, 5]:  # si from CA1, CA3, SOM, ou BIS\r\n                            convect_Soma_Dend_AMPA.append(0)\r\n                        else:  # si from BAS\r\n                            convect_Soma_Dend_AMPA.append(1)\r\n\r\n                else:  # from interneurone\r\n                    convect_GABA.append(k)\r\n                    if c in [3, 4, 5]:  # interneurones\r\n                        convect_Soma_Dend_GABA.append(1)\r\n                    else:\r\n                        if self.List_Neurone_type[k] in [1, 2, 4, 5]:  # si from CA1, CA3, SOM, ou BIS\r\n                            convect_Soma_Dend_GABA.append(0)\r\n                        else:  # si from BAS\r\n                            convect_Soma_Dend_GABA.append(1)\r\n\r\n            self.PreSynaptic_Cell_AMPA.append(convect_AMPA)\r\n            self.PreSynaptic_Cell_GABA.append(convect_GABA)\r\n            self.PreSynaptic_Soma_Dend_AMPA.append(np.array(convect_Soma_Dend_AMPA))\r\n            self.PreSynaptic_Soma_Dend_AMPA_not.append(np.abs(np.array(convect_Soma_Dend_AMPA) - 1))\r\n            self.PreSynaptic_Soma_Dend_GABA.append(np.array(convect_Soma_Dend_GABA))\r\n            self.PreSynaptic_Soma_Dend_GABA_not.append(np.abs(np.array(convect_Soma_Dend_GABA) - 1))\r\n\r\n    def update_cellNnumber(self):\r\n\r\n        Layer_nbCells = np.array( [int(self.nbcellsnb1.text()), int(self.nbcellsnb23.text()),  int(self.nbcellsnb4.text()),  int(self.nbcellsnb5.text()), int(self.nbcellsnb6.text())])\r\n\r\n        PYRpercent = []\r\n        for e in self.List_PYRpercent:\r\n            PYRpercent.append(float(e.text()))\r\n        PYRpercent = np.array(PYRpercent)\r\n\r\n        PVpercent = []\r\n        for e in self.List_PVpercent:\r\n            PVpercent.append(float(e.text()))\r\n        PVpercent = np.array(PVpercent)\r\n\r\n        SSTpercent = []\r\n        for e in self.List_SSTpercent:\r\n            SSTpercent.append(float(e.text()))\r\n        SSTpercent = np.array(SSTpercent)\r\n\r\n        VIPpercent = []\r\n        for e in self.List_VIPpercent:\r\n            VIPpercent.append(float(e.text()))\r\n        VIPpercent = np.array(VIPpercent)\r\n\r\n        RLNpercent = []\r\n        for e in self.List_RLNpercent:\r\n            RLNpercent.append(float(e.text()))\r\n        RLNpercent = np.array(RLNpercent)\r\n\r\n        self.CC.update_cellNumber(Layer_nbCells,\r\n                                 PYRpercent,\r\n                                 PVpercent,\r\n                                 SSTpercent,\r\n                                 VIPpercent,\r\n                                 RLNpercent)\r\n        self.CC.update_inputNB()\r\n        self.nbcellsnbtotal.setText(str(int(np.sum(self.CC.Layer_nbCells))))\r\n\r\n    def update_connections(self):\r\n        Norm = Afferences_ManagmentTable(self)\r\n        if Norm.exec_():\r\n            self.CC.update_connections(self.CC.Afferences, fixed = not self.r0.isChecked())\r\n            pass\r\n\r\n    def See_connections(self):\r\n        Norm = Connection_ManagmentTable(self)\r\n        if Norm.exec_():\r\n            pass\r\n\r\n    def update_connections_per_fixed(self):\r\n        self.CC.update_connections(self.CC.Afferences, fixed = not self.r0.isChecked())\r\n\r\n    def take_cell_number(self):\r\n        if not int(self.Nb_of_PYR_l.text()) == self.Nb_of_PYR:\r\n            self.createCells = True\r\n        self.Nb_of_PYR = int(self.Nb_of_PYR_l.text())\r\n        if not int(self.Nb_of_BAS_l.text()) == self.Nb_of_BAS:\r\n            self.createCells = True\r\n        self.Nb_of_BAS = int(self.Nb_of_BAS_l.text())\r\n        if not int(self.Nb_of_SOM_l.text()) == self.Nb_of_SOM:\r\n            self.createCells = True\r\n        self.Nb_of_SOM = int(self.Nb_of_SOM_l.text())\r\n        if not int(self.Nb_of_BIS_l.text()) == self.Nb_of_BIS:\r\n            self.createCells = True\r\n        self.Nb_of_BIS = int(self.Nb_of_BIS_l.text())\r\n        if not int(self.Nb_of_PYR_Stimulated_l.text()) == self.Nb_of_PYR_Stimulated:\r\n            self.createCells = True\r\n        self.Nb_of_PYR_Stimulated = int(self.Nb_of_PYR_Stimulated_l.text())\r\n\r\n        self.Nb_of_PYR_BAS_SOM_BIS_sum = [self.Nb_of_PYR,\r\n                                          self.Nb_of_PYR + self.Nb_of_BAS,\r\n                                          self.Nb_of_PYR + self.Nb_of_BAS + self.Nb_of_SOM,\r\n                                          self.Nb_of_PYR + self.Nb_of_BAS + self.Nb_of_SOM + self.Nb_of_BIS]\r\n\r\n        self.List_Neurone_type = [2] *  self.Nb_of_PYR_Stimulated + [1] * (self.Nb_of_PYR-self.Nb_of_PYR_Stimulated)  + [3] * self.Nb_of_BAS + [4] * self.Nb_of_SOM + [5] * self.Nb_of_BIS\r\n        self.List_PYR_Stimulated = [i for i in range(self.Nb_of_PYR_Stimulated)]\r\n\r\n    def update_percent_sum(self):\r\n        sum = float(self.Per_PYR.text())+float(self.Per_BAS.text())+float(self.Per_SOM.text())+float(self.Per_BIS.text())\r\n        self.labelSUM2.setText(str(sum))\r\n        if sum == 100:\r\n            self.labelSUM2.setStyleSheet(\"QLabel { background-color : none}\")\r\n        else:\r\n            self.labelSUM2.setStyleSheet(\"QLabel { background-color : red}\")\r\n\r\n    def set_tissue_func(self):\r\n\r\n        D = float(self.D_e.text())\r\n        L = float(self.L_e.text())\r\n        C = float(self.C_e.text())\r\n\r\n        L_d1 = float(self.Layer_d1_l.text())\r\n        L_d23 = float(self.Layer_d23_l.text())\r\n        L_d4 = float(self.Layer_d4_l.text())\r\n        L_d5 = float(self.Layer_d5_l.text())\r\n        L_d6 = float(self.Layer_d6_l.text())\r\n\r\n        self.CC.updateTissue(D, L, C, np.array([L_d1, L_d23, L_d4, L_d5, L_d6]))\r\n\r\n    def Generate_Stim_Signals(self):\r\n\r\n        self.nbOfSamplesStim = int(float(self.StimDuration_e.text()) / self.dt)\r\n        self.i_inj = float(self.i_inj_e.text())\r\n        self.tau = float(self.tau_e.text())\r\n        self.nbStim = int(self.nbStim_e.text())\r\n        self.varianceStim = int(float(self.varianceStim_e.text()) / self.dt)\r\n        self.seed = int(self.seed_e.text())\r\n\r\n        nb_Stim_Signals = len(self.List_PYR_Stimulated)\r\n\r\n        self.dt = 1 / float(self.Fs_e.text())\r\n        self.T = float(self.SimDuration_e.text())\r\n        self.nbEch = int(self.T / self.dt)\r\n\r\n        Stim_Signals_in = np.zeros((nb_Stim_Signals, self.nbEch))\r\n        Stim_Signals_out = np.zeros((nb_Stim_Signals, self.nbEch))\r\n\r\n        Generate_Stim_Signals(Stim_Signals_in, self.seed, self.nbOfSamplesStim, self.i_inj, self.tau, self.nbStim, self.varianceStim, nb_Stim_Signals, self.nbEch, self.dt, Stim_Signals_out)\r\n\r\n        self.Stim_Signals = Stim_Signals_out\r\n\r\n        if not self.seed == 0:\r\n            np.random.seed(self.seed)\r\n        # else:\r\n        #     np.random.seed()\r\n\r\n    def update_model_with_same_param(self):\r\n        List_Neurone_param = copy.deepcopy(self.CC.List_Neurone_param)\r\n        self.CC.create_cells()\r\n        self.createCells = False\r\n        self.Reset_states_clicked()\r\n        self.CC.List_Neurone_param = List_Neurone_param\r\n        self.CC.Update_param_model()\r\n\r\n    def update_Model(self):\r\n        # try:\r\n        #     self.List_Neurone_type\r\n        # except:\r\n        #     msg_cri(\"You must place the cell first.\")\r\n        #     return\r\n\r\n        # self.Compute_synaptic_connections_sparse()\r\n        # self.CC.create_cells(   self.Nb_of_PYR,\r\n        #                         self.Nb_of_SOM,\r\n        #                         self.Nb_of_BAS,\r\n        #                         self.Nb_of_BIS,\r\n        #                         copy.deepcopy(self.List_PYR_Stimulated),\r\n        #                         copy.deepcopy(self.PreSynaptic_Cell_AMPA),\r\n        #                         copy.deepcopy(self.PreSynaptic_Cell_GABA),\r\n        #                         copy.deepcopy(self.PreSynaptic_Soma_Dend_AMPA),\r\n        #                         copy.deepcopy(self.PreSynaptic_Soma_Dend_AMPA_not),\r\n        #                         copy.deepcopy(self.PreSynaptic_Soma_Dend_GABA),\r\n        #                         copy.deepcopy(self.PreSynaptic_Soma_Dend_GABA_not),\r\n        #                         createCells = self.createCells)\r\n        self.CC.create_cells()\r\n        self.createCells = False\r\n        self.Reset_states_clicked()\r\n\r\n    def modify_Model(self):\r\n        try:\r\n            if self.NewModify1NMM == None and self.NewModifyXNMM == None :\r\n                self.NewModify1NMM = Modify_1_NMM(Dict_Param=self.CC.List_Neurone_param, List_Names=self.List_Names, List_Color=self.List_Colors)\r\n                self.NewModify1NMM.Mod_OBJ.connect(self.ApplyMod1NMM)\r\n                self.NewModify1NMM.Close_OBJ.connect(self.closeMod1NMM)\r\n                self.NewModify1NMM.show()\r\n            else:\r\n                self.put_window_on_top()\r\n        except:\r\n            pass\r\n\r\n    @pyqtSlot(list, list, list)\r\n    def ApplyMod1NMM(self, Dict_Param, popName, popColor):\r\n        for idx, p in enumerate(Dict_Param):\r\n            for idx_v,key in enumerate(Dict_Param[idx].keys()):\r\n                self.CC.List_Neurone_param[idx][key]=Dict_Param[idx][key]\r\n        # self.CC.List_Neurone_param = Dict_Param\r\n        self.List_Names = popName\r\n        self.List_Colors = popColor\r\n        self.update_graph()\r\n\r\n    @pyqtSlot()\r\n    def closeMod1NMM(self, ):\r\n        self.NewModify1NMM.deleteLater()\r\n        self.NewModify1NMM.destroyed.connect(self.on_destroyed_NewModify1NMM)\r\n        # self.NewModify1NMM = None\r\n\r\n    @pyqtSlot('QObject*')\r\n    def on_destroyed_NewModify1NMM(self, o):\r\n        self.NewModify1NMM = None\r\n\r\n    def ModXNMMclicked(self, ):\r\n        try:\r\n            if self.NewModify1NMM == None and self.NewModifyXNMM == None:\r\n                self.NewModifyXNMM = Modify_X_NMM(parent= self,List_Neurone_type=self.List_Neurone_type,Dict_Param=self.CC.List_Neurone_param, List_Names=self.List_Names, List_Color=self.List_Colors, initcell = 0, CellPosition=self.CellPosition)\r\n                self.NewModifyXNMM.Mod_OBJ.connect(self.ApplyModXNMM)\r\n                self.NewModifyXNMM.Close_OBJ.connect(self.close_ModXNMM)\r\n                self.NewModifyXNMM.updateVTK_OBJ.connect(self.update_VTKgraph_from_ModXNMM)\r\n                self.NewModifyXNMM.show()\r\n            else:\r\n                self.put_window_on_top()\r\n\r\n        except:\r\n            pass\r\n\r\n    @pyqtSlot(list, list, list)\r\n    def ApplyModXNMM(self, Dict_Param, popName, popColor):\r\n        for idx, p in enumerate(Dict_Param):\r\n            for idx2, p2 in enumerate(p):\r\n                for idx_v,key in enumerate(p2.keys()):\r\n                    self.CC.List_Neurone_param[idx][idx2][key]=Dict_Param[idx][idx2][key]\r\n        # self.CC.List_Neurone_param = Dict_Param\r\n        self.CC.Update_param_model()\r\n        self.List_Names = popName\r\n        self.List_Colors = popColor\r\n        self.update_graph()\r\n\r\n    @pyqtSlot()\r\n    def close_ModXNMM(self, ):\r\n        self.NewModifyXNMM.deleteLater()\r\n        self.NewModifyXNMM.destroyed.connect(self.on_destroyed_NewModifyXNMM)\r\n        # pass\r\n        # self.NewModifyXNMM = None\r\n\r\n    @pyqtSlot('QObject*')\r\n    def on_destroyed_NewModifyXNMM(self, o):\r\n        self.NewModifyXNMM = None\r\n        print(self.NewModifyXNMM)\r\n\r\n    @pyqtSlot(list,)\r\n    def update_VTKgraph_from_ModXNMM(self,selectedcell):\r\n        self.Graph_viewer.selected_cells = selectedcell\r\n        if self.displayVTK_CB.isChecked():\r\n            self.Graph_viewer.draw_Graph()\r\n\r\n    def update_ModXNMM_from_VTKgraph(self,seleced_cell):\r\n        if not self.NewModifyXNMM == None:\r\n            self.NewModifyXNMM.PopNumber.setCurrentIndex(seleced_cell)\r\n\r\n    def put_window_on_top(self):\r\n        self.parent.processEvents()\r\n        if not self.NewModify1NMM == None:\r\n            self.NewModify1NMM.activateWindow()\r\n        elif not self.NewModifyXNMM == None:\r\n            self.NewModifyXNMM.activateWindow()\r\n\r\n    def update_samples(self):\r\n        try:\r\n            self.CC.tps_start = 0.\r\n            self.CC.Reset_states()\r\n        except:\r\n            pass\r\n\r\n    def Reset_states_clicked(self):\r\n        try:\r\n            self.CC.tps_start = 0.\r\n            self.CC.Reset_states()\r\n        except:\r\n            pass\r\n\r\n    def simulate(self):\r\n        if self.CC.ImReady == False:\r\n            msg_cri('The model is not ready to Simulate')\r\n            return\r\n        if not self.Colonne_cortical_Thread.isRunning():\r\n            t0 = time.time()\r\n            self.msg = msg_wait(\"Computation in progress\\nPlease wait.\")\r\n            self.msg.setStandardButtons(QMessageBox.Cancel)\r\n            # self.msg.buttonClicked.connect(self.Cancelpressed)\r\n            self.parent.processEvents()\r\n\r\n            Fs = int(self.Fs_e.text())\r\n            self.dt = 1 / Fs\r\n            self.T = float(self.SimDuration_e.text())\r\n            self.nbEch = int(self.T / self.dt)\r\n            self.CC.nbEch = self.nbEch\r\n            self.CC.dt = self.dt\r\n            # self.CC.update_samples(Fs,self.T)\r\n            self.Reset_states_clicked()\r\n            S_nbOfSamplesStim =  float(self.StimDuration_e.text())\r\n            S_i_inj = float(self.i_inj_e.text())\r\n            S_tau = float(self.tau_e.text())\r\n            S_nbStim = int(self.nbStim_e.text())\r\n            S_varianceStim = float(self.varianceStim_e.text())\r\n            S_seed = int(self.seed_e.text())\r\n            S_StimStart = float(self.StimStart_e.text())\r\n\r\n            # if not S_seed == 0:\r\n            #     np.random.seed(S_seed)\r\n            # else:\r\n            #     np.random.seed()\r\n            self.CC.set_seed(S_seed)\r\n            self.CC.Generate_Stims( I_inj=S_i_inj, tau=S_tau, stimDur=S_nbOfSamplesStim, nbstim=S_nbStim, varstim=S_varianceStim,StimStart=S_StimStart)\r\n\r\n            TH_nbOfSamplesStim = float(self.TH_StimDuration_e.text())\r\n            TH_i_inj = float(self.TH_i_inj_e.text())\r\n            TH_tau = float(self.TH_tau_e.text())\r\n            TH_nbStim = int(self.TH_nbStim_e.text())\r\n            TH_deltamin = float(self.TH_deltamin_e.text())\r\n            TH_delta = float(self.TH_delta_e.text())\r\n\r\n\r\n            self.CC.Generate_input( I_inj=TH_i_inj, tau=TH_tau, stimDur=TH_nbOfSamplesStim, nbstim=TH_nbStim, deltamin=TH_deltamin, delta=TH_delta)\r\n\r\n\r\n\r\n            if self.EField_OnOff_CB.isChecked():\r\n                if self.EField_Const_RB.isChecked():\r\n                    self.EField_Const_fun()\r\n                    self.EField = self.EField_Const\r\n                elif self.EField_File_RB.isChecked():\r\n                    self.EField = self.EFieldFile\r\n                self.CC.Generate_EField(self.EField,np.float(self.EField_OnOff_CB.isChecked()),bool(self.EField_Const_RB.isChecked()))\r\n            else:\r\n                self.EField = {'Er': np.array([0.,0.,0.])}\r\n                self.CC.Generate_EField(self.EField,0.,True)\r\n\r\n\r\n            A = float(self.EField_StimSig_A_LE.text())\r\n            F = float(self.EField_StimSig_F_LE.text())\r\n            stimOnOff = int(self.EField_OnOff_CB.isChecked())\r\n            Start = float(self.EField_Start_LE.text())\r\n            Length = float(self.EField_Length_LE.text())\r\n            self.CC.Generate_EField_Stim(self.EField_StimSig_CB.currentText(),A,F, stimOnOff,Start = Start, Length = Length)\r\n\r\n            self.t0 = time.time()\r\n            self.t, self.pyrVs, self.pyrVd,self.pyrVa, self.pyrPPSE_d1, self.pyrPPSE_d23, self.pyrPPSE_d4, self.pyrPPSE_d5, self.pyrPPSE_d6, self.pyrPPSI_d1, self.pyrPPSI_d23, self.pyrPPSI_d4, self.pyrPPSI_d5, self.pyrPPSI_d6, self.pyrPPSI_s, self.pyrPPSI_a, self.PV_Vs, self.SST_Vs, self.VIP_Vs, self.RLN_Vs, self.DPYR_Vs, self.Th_Vs = self.CC.runSim()\r\n\r\n            self.msg = msg_wait(\"Computation finished\\nResults are currently displayed.\\nPlease wait.\")\r\n\r\n            self.flatindex = []\r\n            for i in range(len(self.CellPosition)):\r\n                for j in range(len(self.CellPosition[i])):\r\n                    self.flatindex.append([i, j])\r\n\r\n            self.Color = []\r\n            self.Sigs_dict = {}\r\n            self.Sigs_dict[\"t\"] = self.t + self.CC.tps_start\r\n            self.CC.tps_start = self.t[-1]\r\n            # count = 0\r\n            # for i in range(self.pyrVs.shape[0]):\r\n            #     if i in self.List_PYR_Stimulated:\r\n            #         self.Color.append(self.List_Colors[count])\r\n            #         self.Sigs_dict[\"Pyr_\" + str(i) + 'Stim'] = self.pyrVs[i, :]\r\n            #     else:\r\n            #         self.Color.append(self.List_Colors[count])\r\n            #         self.Sigs_dict[\"Pyr_\" + str(i)] = self.pyrVs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.basketVs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[count])\r\n            #     self.Sigs_dict[\"BAS_\" + str(i)] = self.basketVs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.olmVs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[count])\r\n            #     self.Sigs_dict[\"SOM_\" + str(i)] = self.olmVs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.BisVs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[count])\r\n            #     self.Sigs_dict[\"BIS_\" + str(i)] = self.BisVs[i, :]\r\n            #     count += 1\r\n\r\n            # count = 0\r\n            # for i in range(self.pyrVs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[self.flatindex[count][0]][self.flatindex[count][1]])\r\n            #     self.Sigs_dict[self.List_Names[self.flatindex[count][0]][self.flatindex[count][1]]] = self.pyrVs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.PV_Vs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[self.flatindex[count][0]][self.flatindex[count][1]])\r\n            #     self.Sigs_dict[self.List_Names[self.flatindex[count][0]][self.flatindex[count][1]]] = self.PV_Vs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.SST_Vs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[self.flatindex[count][0]][self.flatindex[count][1]])\r\n            #     self.Sigs_dict[self.List_Names[self.flatindex[count][0]][self.flatindex[count][1]]] = self.SST_Vs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.VIP_Vs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[self.flatindex[count][0]][self.flatindex[count][1]])\r\n            #     self.Sigs_dict[self.List_Names[self.flatindex[count][0]][self.flatindex[count][1]]] = self.VIP_Vs[i, :]\r\n            #     count += 1\r\n            #\r\n            # for i in range(self.RLN_Vs.shape[0]):\r\n            #     self.Color.append(self.List_Colors[self.flatindex[count][0]][self.flatindex[count][1]])\r\n            #     self.Sigs_dict[self.List_Names[self.flatindex[count][0]][self.flatindex[count][1]]] = self.RLN_Vs[i, :]\r\n            #     count += 1\r\n\r\n            nb_pyr = 0\r\n            nb_pv = 0\r\n            nb_sst = 0\r\n            nb_vip = 0\r\n            nb_rln = 0\r\n            count = 0\r\n            for i in range(len(self.flatindex)):\r\n                l = self.flatindex[i][0]\r\n                n = self.flatindex[i][1]\r\n                if self.List_Neurone_type[l][n] == 1:\r\n                    self.Color.append(self.List_Colors[l][n])\r\n                    self.Sigs_dict[self.List_Names[l][n]] = self.pyrVs[nb_pyr, :]\r\n                    nb_pyr += 1\r\n                elif self.List_Neurone_type[l][n] == 2:\r\n                    self.Color.append(self.List_Colors[l][n])\r\n                    self.Sigs_dict[self.List_Names[l][n]] = self.PV_Vs[nb_pv, :]\r\n                    nb_pv += 1\r\n                elif self.List_Neurone_type[l][n] == 3:\r\n                    self.Color.append(self.List_Colors[l][n])\r\n                    self.Sigs_dict[self.List_Names[l][n]] = self.SST_Vs[nb_sst, :]\r\n                    nb_sst += 1\r\n                elif self.List_Neurone_type[l][n] == 4:\r\n                    self.Color.append(self.List_Colors[l][n])\r\n                    self.Sigs_dict[self.List_Names[l][n]] = self.VIP_Vs[nb_vip, :]\r\n                    nb_vip += 1\r\n                elif self.List_Neurone_type[l][n] == 5:\r\n                    self.Color.append(self.List_Colors[l][n])\r\n                    self.Sigs_dict[self.List_Names[l][n]] = self.RLN_Vs[nb_rln, :]\r\n                    nb_rln += 1\r\n                count += 1\r\n\r\n            for i in range(self.DPYR_Vs.shape[0]):\r\n                self.Color.append(\"#000000\")\r\n                self.Sigs_dict['DPYR' + str(i)] = self.DPYR_Vs[i, :]\r\n                count += 1\r\n            for i in range(self.Th_Vs.shape[0]):\r\n                self.Color.append(\"#999999\")\r\n                self.Sigs_dict['Th' + str(i)] = self.Th_Vs[i, :]\r\n                count += 1\r\n            if self.displaycurves_CB.isChecked():\r\n                print('update draw')\r\n                # self.mascene_EEGViewer.setWindowSizeWithoutRedraw(int(self.T))\r\n                self.mascene_EEGViewer.update(Sigs_dict=self.Sigs_dict, Colors=self.Color, percentage=float(self.displaycurve_per_e.text()))\r\n                print('finish update draw')\r\n\r\n            print(str(datetime.timedelta(seconds=int(time.time()-t0))))\r\n            self.msg.close()\r\n            self.parent.processEvents()\r\n\r\n    def displaycurves_CB_fonc(self):\r\n        if hasattr(self, 'Sigs_dict'):\r\n            if self.displaycurves_CB.isChecked():\r\n                # self.mascene_EEGViewer.setWindowSizeWithoutRedraw(int(self.T))\r\n                self.mascene_EEGViewer.update(Sigs_dict=self.Sigs_dict, Colors=self.Color, percentage=float(self.displaycurve_per_e.text()))\r\n\r\n    def displayVTK_CB_fonc(self):\r\n        if self.displayVTK_CB.isChecked():\r\n            try:\r\n                self.Graph_viewer.draw_Graph()\r\n                self.Graph_viewer.set_center()\r\n                self.parent.processEvents()\r\n            except:\r\n                pass\r\n\r\n    def Compute_LFP_fonc(self,meth=0):\r\n        if meth == 0:\r\n            electrode_pos = np.array(self.electrode_pos)\r\n\r\n            CellPosition = []\r\n            for layer in range(len(self.CC.Cellpos)):\r\n                for n in range(self.CC.Cellpos[layer].shape[0]):\r\n                    if self.CC.List_celltypes[layer][n] == 0:\r\n                        CellPosition.append(self.CC.Cellpos[layer][n])\r\n            CellPosition = np.array(CellPosition)\r\n            #print(electrode_pos)\r\n            Distance_from_electrode = distance.cdist([electrode_pos, electrode_pos], CellPosition, 'euclidean')[0, :]\r\n            # vect direction??\r\n            U = (CellPosition - electrode_pos) / Distance_from_electrode[:, None]\r\n\r\n            Ssoma = np.pi * (self.somaSize / 2.) * ((self.somaSize / 2.) + self.somaSize * np.sqrt(5. / 4.))\r\n            Stotal = Ssoma / self.p\r\n\r\n            # potentials\r\n            self.LFP = np.zeros(self.pyrVs.shape[1])\r\n            Vs_d = self.pyrVs - self.pyrVd\r\n            Vs_a = self.pyrVs - self.pyrVa\r\n\r\n            for i in range(len(Vs_d)):\r\n                Vdi = np.zeros((len(Vs_d[i, :]), 3))\r\n                Vdi[:, 2] = Vs_d[i, :]\r\n                Vm = np.sum(Vdi * U[i, :], axis=1)\r\n                Vm = Vm / (4. * self.sigma * np.pi * Distance_from_electrode[i] * Distance_from_electrode[i])\r\n                Vm = Vm * (self.dendriteSize + self.somaSize) / 2. * self.gc * Stotal\r\n                self.LFP += Vm * 10.e02\r\n\r\n            self.mascene_LFPViewer.update(shiftT=self.CC.tps_start - self.T)\r\n        elif meth == 1:\r\n            electrode_pos = np.array(self.electrode_pos)\r\n\r\n            # for i, ind in enumerate(self.CC.PreSynaptic_Cell_AMPA):\r\n            #     pos_neuron = self.CellPosition[self.flatindex[i][0]][self.flatindex[i][1]]\r\n            #     pos_pre = []\r\n            #     for k in ind:\r\n            #         pos_pre.append(self.CellPosition[self.flatindex[k][0]][self.flatindex[k][1]])\r\n\r\n            CellPosition_d = []\r\n            CellPosition_s = []\r\n            CellPosition_a = []\r\n            target = Cell_morphology.Neuron(0, 1)\r\n            for layer in range(len(self.CC.Cellpos)):\r\n                for n in range(self.CC.Cellpos[layer].shape[0]):\r\n                    if self.CC.List_celltypes[layer][n] == 0:\r\n                        CellPosition_s.append(self.CC.Cellpos[layer][n])\r\n                        # subtype == 0  # TPC  subtype = 1  # UPC subtype = 2  # IPC subtype = 3  # BPC subtype = 4  # SSC\r\n                        subtype = self.CC.List_cellsubtypes[layer][n]\r\n                        target.update_type(0, layer=layer, subtype=subtype)\r\n                        diff_d = np.array([0., 0., target.mid_dend])\r\n                        diff_a = np.array([0., 0., -target.hsoma])\r\n                        if subtype in [0, 1, 2, 4]:\r\n                            CellPosition_d.append(self.CC.Cellpos[layer][n] + diff_d)\r\n                            CellPosition_a.append(self.CC.Cellpos[layer][n] - diff_a)\r\n                        else:\r\n                            CellPosition_d.append(self.CC.Cellpos[layer][n] - diff_d)\r\n                            CellPosition_a.append(self.CC.Cellpos[layer][n] + diff_a)\r\n\r\n            CellPosition_d = np.array(CellPosition_d)\r\n            CellPosition_s = np.array(CellPosition_s)\r\n            CellPosition_a = np.array(CellPosition_a)\r\n\r\n            Distance_from_electrode_d = distance.cdist([electrode_pos, electrode_pos], CellPosition_d, 'euclidean')[0,\r\n                                        :]\r\n            Distance_from_electrode_s = distance.cdist([electrode_pos, electrode_pos], CellPosition_s, 'euclidean')[0,\r\n                                        :]\r\n            Distance_from_electrode_a = distance.cdist([electrode_pos, electrode_pos], CellPosition_a, 'euclidean')[0,\r\n                                        :]\r\n\r\n            Res = np.zeros(self.pyrPPSE_d.shape[1])\r\n            sigma = 33e-5\r\n            for k in range(CellPosition_a.shape[0]):\r\n                Res = Res + ((self.pyrPPSE_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d[k]))\r\n                Res = Res - ((self.pyrPPSE_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))\r\n\r\n                Res = Res - ((self.pyrPPSI_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d[k]))\r\n                Res = Res + ((self.pyrPPSI_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))\r\n\r\n                Res = Res - ((self.pyrPPSI_s[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))\r\n                Res = Res + ((self.pyrPPSI_s[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d[k]))\r\n\r\n                Res = Res - ((self.pyrPPSI_a[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_a[k]))\r\n                Res = Res + ((self.pyrPPSI_a[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))\r\n\r\n            self.LFP = Res\r\n            self.mascene_LFPViewer.update(shiftT=self.CC.tps_start - self.T)\r\n\r\n\r\n\r\n\r\n    def Compute_LFPDisk_fonc(self):\r\n        print('Electrod disk')\r\n        t0 = time.time()\r\n        self.electrode_pos = [float(x.text()) for x in [self.electrode_x_e, self.electrode_y_e, self.electrode_z_e]]\r\n        print(self.electrode_pos)\r\n        self.electrode_disk = [self.electrod_disk_CB.isChecked(),\r\n                               float(self.electrode_radius_e.text()),\r\n                               float(self.electrode_angle1_e.text()),\r\n                               float(self.electrode_angle2_e.text())]\r\n        Fs = int(self.Fs_e.text())\r\n        ComputeLFP=RecordedPotential.LFP(Fs=Fs, re=self.electrode_disk[1], tx=self.electrode_disk[2], ty=self.electrode_disk[3], pos=self.electrode_pos)\r\n\r\n        coords = ComputeLFP.get_electrode_coordinates()\r\n        # coords = Ds.T\r\n        self.Graph_viewer.draw_DiskPoints(coords)\r\n        self.Graph_viewer.set_center()\r\n        self.parent.processEvents()\r\n\r\n        Vs_d = self.pyrVs - self.pyrVd\r\n        Vs_a = self.pyrVs - self.pyrVa\r\n\r\n\r\n        PCsubtypes_Per = np.cumsum(self.CC.PCsubtypes_Per, axis=1)\r\n        Cellsubtypes = []\r\n        for l in range(len(self.CC.Layer_nbCells)):\r\n            for cell in range(int(self.CC.Layer_nbCells[l])):\r\n                if (self.CC.List_celltypes[l][cell] == 0):  # getsubtype\r\n                    if cell < PCsubtypes_Per[l][0]:\r\n                        Cellsubtypes.append(0)  # TPC\r\n                    elif (cell >= PCsubtypes_Per[l][0]) and (cell < PCsubtypes_Per[l][1]):\r\n                        Cellsubtypes.append(1)  # UPC\r\n                    elif (cell >= PCsubtypes_Per[l][1]) and (cell < PCsubtypes_Per[l][2]):\r\n                        Cellsubtypes.append(2)  # IPC\r\n                    elif (cell >= PCsubtypes_Per[l][2]) and (cell < PCsubtypes_Per[l][3]):\r\n                        Cellsubtypes.append(3)  # BPC\r\n                    elif (cell >= PCsubtypes_Per[l][3]) and (cell < PCsubtypes_Per[l][4]):\r\n                        Cellsubtypes.append(4)  # SSC\r\n\r\n        nb_pyr = 0\r\n        cellspos = []\r\n        layers = []\r\n        for i in range(len(self.flatindex)):\r\n            l = self.flatindex[i][0]\r\n            n = self.flatindex[i][1]\r\n            if self.CC.List_celltypes[l][n] == 0:\r\n                cellspos.append(self.CellPosition[l][n])\r\n                layers.append(l)\r\n                nb_pyr += 1\r\n        cellspos = np.array(cellspos)\r\n        print(cellspos)\r\n\r\n#        self.LFP = ComputeLFP.compute_dipoles(Vs_a, cellspos, Cellsubtypes,layers)\r\n#        self.LFP1 = ComputeLFP.compute_dipoles(Vs_d, cellspos, Cellsubtypes,layers)\r\n\r\n#        plt.plot(self.LFP)\r\n#        plt.plot(self.LFP1)\r\n#        plt.plot(self.LFP-self.LFP1)\r\n#        plt.show()\r\n\r\n\r\n        print(time.time() - t0)\r\n\r\n        self.mascene_LFPViewer.update(shiftT=self.CC.tps_start - self.T)\r\n\r\n    def UpdateLFP(self):\r\n        if self.Temporal_PSD_CB.isChecked():\r\n            self.mascene_LFPViewer.updatePSD(shiftT=self.CC.tps_start - self.T)\r\n        else:\r\n            self.mascene_LFPViewer.update(shiftT=self.CC.tps_start - self.T)\r\n\r\n    def Compute_LFPDiskCoated_fonc(self):\r\n        self.electrode_pos = [float(x.text()) for x in [self.electrode_x_e, self.electrode_y_e, self.electrode_z_e]]\r\n        self.electrode_disk = [self.electrod_disk_CB.isChecked(),\r\n                               float(self.electrode_radius_e.text()),\r\n                               float(self.electrode_angle1_e.text()),\r\n                               float(self.electrode_angle2_e.text())]\r\n\r\n        ind = self.Compute_LFPDiskCoated_type_CB.currentIndex()\r\n        if ind in [0, 1, 2]:\r\n            coated = 0\r\n        else:\r\n            coated = 1\r\n        e_g = Electrode.ElectrodeModel( re=self.electrode_disk[1] , Etype=ind, coated=coated )\r\n        LFP = e_g.GetVelec(self.LFP, Fs = int(1000/self.dt))\r\n        self.mascene_LFPViewer.addLFP(LFP,shiftT=self.CC.tps_start - self.T)\r\n\r\n    def SaveSimul(self):\r\n        extension = \"txt\"\r\n        fileName = QFileDialog.getSaveFileName(caption='Save parameters', filter=extension + \" (*.\" + extension + \")\")\r\n        if (fileName[0] == ''):\r\n            return\r\n        if os.path.splitext(fileName[0])[1] == '':\r\n            fileName = (fileName[0] + '.' + extension, fileName[1])\r\n        try:\r\n            if fileName[1] == extension +\" (*.\" + extension +\")\" :\r\n                f = open(fileName[0] , 'w')\r\n                f.write(\"D\" + \"\\t\" + str(self.CC.D) +\"\\n\")\r\n                f.write(\"L\" + \"\\t\" + str(self.CC.L) +\"\\n\")\r\n                f.write(\"Layer_d\" + \"\\t\" + str(self.CC.Layer_d) + \"\\n\")\r\n\r\n                f.write(\"Layer_nbCells\" + \"\\t\" + str(self.CC.Layer_nbCells.tolist()) + \"\\n\")\r\n                f.write(\"PYRpercent\" + \"\\t\" + str(self.CC.PYRpercent.tolist()) + \"\\n\")\r\n                f.write(\"PVpercent\" + \"\\t\" + str(self.CC.PVpercent.tolist()) + \"\\n\")\r\n                f.write(\"SSTpercent\" + \"\\t\" + str(self.CC.SSTpercent.tolist()) + \"\\n\")\r\n                f.write(\"VIPpercent\" + \"\\t\" + str(self.CC.VIPpercent.tolist()) + \"\\n\")\r\n                f.write(\"RLNpercent\" + \"\\t\" + str(self.CC.RLNpercent.tolist()) + \"\\n\")\r\n\r\n                f.write(\"PCsubtypes_Per\" + \"\\t\" + str(self.CC.PCsubtypes_Per.tolist()) + \"\\n\")\r\n                f.write(\"NB_PYR\" + \"\\t\" + str(self.CC.NB_PYR.tolist()) + \"\\n\")\r\n                f.write(\"NB_IN\" + \"\\t\" + str(self.CC.NB_IN.tolist()) + \"\\n\")\r\n                f.write(\"NB_PV\" + \"\\t\" + str(self.CC.NB_PV.tolist()) + \"\\n\")\r\n                f.write(\"NB_PV_BC\" + \"\\t\" + str(self.CC.NB_PV_BC.tolist()) + \"\\n\")\r\n                f.write(\"NB_PV_ChC\" + \"\\t\" + str(self.CC.NB_PV_ChC.tolist()) + \"\\n\")\r\n                f.write(\"NB_SST\" + \"\\t\" + str(self.CC.NB_SST.tolist()) + \"\\n\")\r\n                f.write(\"NB_VIP\" + \"\\t\" + str(self.CC.NB_VIP.tolist()) + \"\\n\")\r\n                f.write(\"NB_RLN\" + \"\\t\" + str(self.CC.NB_RLN.tolist()) + \"\\n\")\r\n\r\n                f.write(\"Afference_type\" + \"\\t\" + str(self.r0.isChecked()) + \"\\n\")\r\n                f.write(\"Afferences\" + \"\\t\" + str(self.CC.Afferences.tolist()) + \"\\n\")\r\n\r\n                f.write(\"StimDuration\" + \"\\t\" + self.StimDuration_e.text() +\"\\n\")\r\n                f.write(\"i_inj\" + \"\\t\" + self.i_inj_e.text() +\"\\n\")\r\n                f.write(\"tau\" + \"\\t\" + self.tau_e.text() +\"\\n\")\r\n                f.write(\"nbStim\" + \"\\t\" + self.nbStim_e.text() +\"\\n\")\r\n                f.write(\"varianceStim\" + \"\\t\" + self.varianceStim_e.text() +\"\\n\")\r\n                f.write(\"seed\" + \"\\t\" + self.seed_e.text() +\"\\n\")\r\n\r\n                f.write(\"TH_StimDuration_e\" + \"\\t\" + self.TH_StimDuration_e.text() +\"\\n\")\r\n                f.write(\"TH_i_inj_e\" + \"\\t\" + self.TH_i_inj_e.text() +\"\\n\")\r\n                f.write(\"TH_tau_e\" + \"\\t\" + self.TH_tau_e.text() +\"\\n\")\r\n                f.write(\"TH_nbStim_e\" + \"\\t\" + self.TH_nbStim_e.text() +\"\\n\")\r\n                f.write(\"TH_deltamin_e\" + \"\\t\" + self.TH_deltamin_e.text() +\"\\n\")\r\n                f.write(\"TH_delta_e\" + \"\\t\" + self.TH_delta_e.text() +\"\\n\")\r\n\r\n                f.write(\"SimDuration\" + \"\\t\" + self.SimDuration_e.text() +\"\\n\")\r\n                f.write(\"Fs\" + \"\\t\" + self.Fs_e.text() +\"\\n\")\r\n\r\n                f.write(\"Cellpos1\" + \"\\t\" + str(self.CC.Cellpos[0].tolist() ) + \"\\n\")\r\n                f.write(\"Cellpos23\" + \"\\t\" + str(self.CC.Cellpos[1].tolist() ) + \"\\n\")\r\n                f.write(\"Cellpos4\" + \"\\t\" + str(self.CC.Cellpos[2].tolist() ) + \"\\n\")\r\n                f.write(\"Cellpos5\" + \"\\t\" + str(self.CC.Cellpos[3].tolist() ) + \"\\n\")\r\n                f.write(\"Cellpos6\" + \"\\t\" + str(self.CC.Cellpos[4].tolist() ) + \"\\n\")\r\n\r\n                f.write(\"cell_placement_CB\" + \"\\t\" + self.cell_placement_CB.currentText() + \"\\n\")\r\n                f.write(\"cellplace\" + \"\\t\" + self.seed_place.text() + \"\\n\")\r\n\r\n                f.write(\"electrode_x\" + \"\\t\" + self.electrode_x_e.text() + \"\\n\")\r\n                f.write(\"electrode_y\" + \"\\t\" + self.electrode_y_e.text() + \"\\n\")\r\n                f.write(\"electrode_z\" + \"\\t\" + self.electrode_z_e.text() + \"\\n\")\r\n\r\n                f.write(\"List_Names\" + \"\\t\" + str(self.List_Names) + \"\\n\")\r\n                f.write(\"List_Colors\" + \"\\t\" + str(self.List_Colors) + \"\\n\")\r\n                f.write(\"List_Neurone_type\" + \"\\t\" + str(self.List_Neurone_type) + \"\\n\")\r\n\r\n                for dictlayer in self.CC.List_Neurone_param:\r\n                    for dict_param in dictlayer:\r\n                        f.write(\"dict_param\" + \"\\t\" + str(dict_param) + \"\\n\")\r\n\r\n                f.close()\r\n        except:\r\n            msg_cri('Not able to save the simulation')\r\n\r\n    def LoadSimul(self):\r\n        extension = \"txt\"\r\n        fileName = QFileDialog.getOpenFileName(caption='Load parameters' ,filter= extension +\" (*.\" + extension +\")\")\r\n        if  (fileName[0] == '') :\r\n            return\r\n        if os.path.splitext(fileName[0])[1] == '':\r\n            fileName= (fileName[0] + '.' + extension , fileName[1])\r\n        if fileName[1] == extension +\" (*.\" + extension +\")\" :\r\n            f = open(fileName[0], 'r')\r\n            line = f.readline()\r\n            self.D_e.setText(line.split(\"\\t\")[-1].replace('\\n','').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.L_e.setText(line.split(\"\\t\")[-1].replace('\\n','').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.Layer_d\t= [float(l) for l in line.split(\"\\t\")[-1].replace('\\n','').replace(\"[\", \"\").replace(\"]\", \"\").split(\" \")]\r\n\r\n            self.Layer_d1_l.setText(str(self.Layer_d[0]))\r\n            self.Layer_d23_l.setText(str(self.Layer_d[1]))\r\n            self.Layer_d4_l.setText(str(self.Layer_d[2]))\r\n            self.Layer_d5_l.setText(str(self.Layer_d[3]))\r\n            self.Layer_d6_l.setText(str(self.Layer_d[4]))\r\n            self.set_tissue_func()\r\n\r\n            line = f.readline()\r\n            Layer_nbCells= [int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")]\r\n            line = f.readline()\r\n            PYRpercent = [float(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")]\r\n            line = f.readline()\r\n            PVpercent = [float(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")]\r\n            line = f.readline()\r\n            SSTpercent = [float(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")]\r\n            line = f.readline()\r\n            VIPpercent = [float(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")]\r\n            line = f.readline()\r\n            RLNpercent = [float(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")]\r\n\r\n            line = f.readline()\r\n            PCsubtypes_Per = np.array([ [float(r) for r in l.split(\", \")]  for l in line.split(\"\\t\")[-1].replace('\\n', '').replace('[[', '').replace(']]', '').split(\"], [\")])\r\n            line = f.readline()\r\n            NB_PYR = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",\"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_IN = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",\"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_PV = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",\"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_PV_BC = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",                                                                                                                \"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_PV_ChC = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_SST = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",\"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_VIP = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",\"\").split(\" \")])\r\n            line = f.readline()\r\n            NB_RLN = np.array([int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\",\"\").split(\" \")])\r\n\r\n\r\n\r\n            self.CC.update_cellNumber(np.array(Layer_nbCells),\r\n                                      np.array(PYRpercent),\r\n                                      np.array(PVpercent),\r\n                                      np.array(SSTpercent),\r\n                                      np.array(VIPpercent),\r\n                                      np.array(RLNpercent),\r\n                                      PCsubtypes_Per=np.array(PCsubtypes_Per),\r\n                                      NB_PYR=NB_PYR,\r\n                                      NB_PV_BC=NB_PV_BC,\r\n                                      NB_PV_ChC=NB_PV_ChC,\r\n                                      NB_IN=NB_IN,\r\n                                      NB_PV=NB_PV,\r\n                                      NB_SST=NB_SST,\r\n                                      NB_VIP=NB_VIP,\r\n                                      NB_RLN=NB_RLN\r\n                                      )\r\n\r\n            self.nbcellsnb1.setText(str(int(self.CC.Layer_nbCells[0])))\r\n            self.nbcellsnb23.setText(str(int(self.CC.Layer_nbCells[1])))\r\n            self.nbcellsnb4.setText(str(int(self.CC.Layer_nbCells[2])))\r\n            self.nbcellsnb5.setText(str(int(self.CC.Layer_nbCells[3])))\r\n            self.nbcellsnb6.setText(str(int(self.CC.Layer_nbCells[4])))\r\n            self.nbcellsnbtotal.setText(str(int(np.sum(self.CC.Layer_nbCells))))\r\n\r\n            # self.update_cellNnumber()\r\n\r\n            self.CC.update_inputNB()\r\n\r\n            for i, l in enumerate(self.List_PYRpercent):\r\n                l.setText(str(PYRpercent[i]))\r\n\r\n            for i, l in enumerate(self.List_PVpercent):\r\n                l.setText(str(PVpercent[i]))\r\n\r\n            for i, l in enumerate(self.List_SSTpercent):\r\n                l.setText(str(SSTpercent[i]))\r\n\r\n            for i, l in enumerate(self.List_VIPpercent):\r\n                l.setText(str(VIPpercent[i]))\r\n\r\n            for i, l in enumerate(self.List_RLNpercent):\r\n                l.setText(str(RLNpercent[i]))\r\n\r\n            line = f.readline()\r\n            Afference_type = line.split(\"\\t\")[-1].replace('\\n','').replace(\" \", \"\")\r\n            if Afference_type == 'True':\r\n                self.r0.setChecked(True)\r\n            else:\r\n                self.r1.setChecked(True)\r\n\r\n            line = f.readline()\r\n            Afferences = np.array([ [float(r) for r in l.split(\", \")]  for l in line.split(\"\\t\")[-1].replace('\\n', '').replace('[[', '').replace(']]', '').split(\"], [\")])\r\n            self.CC.update_connections(Afferences, fixed=not self.r0.isChecked())\r\n\r\n            line = f.readline()\r\n            self.StimDuration_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.i_inj_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.tau_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.nbStim_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.varianceStim_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.seed_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n\r\n            line = f.readline()\r\n            self.TH_StimDuration_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.TH_i_inj_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.TH_tau_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.TH_nbStim_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.TH_deltamin_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.TH_delta_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n\r\n            line = f.readline()\r\n            self.SimDuration_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.Fs_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n\r\n            line = f.readline()\r\n            sublist = line.split(\"\\t\")[-1].replace('\\n', '').replace(' ', '').replace('[[', '').replace(']]', '').split('],[')\r\n            Cellpos = []\r\n            for s in sublist:\r\n                Cellpos.append([float(s2) for s2 in s.split(',')])\r\n            self.CC.Cellpos = [np.array(Cellpos)]\r\n            line = f.readline()\r\n            sublist = line.split(\"\\t\")[-1].replace('\\n', '').replace(' ', '').replace('[[', '').replace(']]', '').split('],[')\r\n            Cellpos = []\r\n            for s in sublist:\r\n                Cellpos.append([float(s2) for s2 in s.split(',')])\r\n            self.CC.Cellpos.append(np.array(Cellpos))\r\n            line = f.readline()\r\n            sublist = line.split(\"\\t\")[-1].replace('\\n', '').replace(' ', '').replace('[[', '').replace(']]', '').split('],[')\r\n            Cellpos = []\r\n            for s in sublist:\r\n                Cellpos.append([float(s2) for s2 in s.split(',')])\r\n            self.CC.Cellpos.append(np.array(Cellpos))\r\n            line = f.readline()\r\n            sublist = line.split(\"\\t\")[-1].replace('\\n', '').replace(' ', '').replace('[[', '').replace(']]', '').split('],[')\r\n            Cellpos = []\r\n            for s in sublist:\r\n                Cellpos.append([float(s2) for s2 in s.split(',')])\r\n            self.CC.Cellpos.append(np.array(Cellpos))\r\n            line = f.readline()\r\n            sublist = line.split(\"\\t\")[-1].replace('\\n', '').replace(' ', '').replace('[[', '').replace(']]', '').split('],[')\r\n            Cellpos = []\r\n            for s in sublist:\r\n                Cellpos.append([float(s2) for s2 in s.split(',')])\r\n            self.CC.Cellpos.append(np.array(Cellpos))\r\n            self.CellPosition = self.CC.Cellpos\r\n\r\n            line = f.readline()\r\n            index = self.cell_placement_CB.findText(line.split(\"\\t\")[-1].replace('\\n', ''),\r\n                                                    Qt.MatchExactly | Qt.MatchCaseSensitive)\r\n            self.cell_placement_CB.setCurrentIndex(index)\r\n\r\n            line = f.readline()\r\n            seed = line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\")\r\n            self.seed_place.setText(seed)\r\n            seed = int(seed)\r\n            self.Connectivitymatrix, self.Connectivityweight = self.CC.Create_Connectivity_Matrix(seed=seed)\r\n\r\n            line = f.readline()\r\n            self.electrode_x_e.setText(line.split(\"\\t\")[-1].replace('\\n', '').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.electrode_y_e.setText(line.split(\"\\t\")[-1].replace('\\n','').replace(\" \", \"\"))\r\n            line = f.readline()\r\n            self.electrode_z_e.setText(line.split(\"\\t\")[-1].replace('\\n','').replace(\" \", \"\"))\r\n\r\n            line = f.readline()\r\n            List_Names = line.split(\"\\t\")[-1].replace('\\n','').replace('[','').replace(']','').replace(\"'\",'').replace(\" \",'').split(',')\r\n            index = 0\r\n            self.List_Names = []\r\n            for l in range(len(self.CC.Cellpos)):\r\n                length = len(self.CC.Cellpos[l])\r\n                self.List_Names.append(List_Names[index:index+length])\r\n                index += length\r\n            line = f.readline()\r\n            List_Colors = line.split(\"\\t\")[-1].replace('\\n','').replace('[','').replace(']','').replace(\"'\",'').replace(\" \",'').split(',')\r\n            index = 0\r\n            self.List_Colors = []\r\n            for l in range(len(self.CC.Cellpos)):\r\n                length = len(self.CC.Cellpos[l])\r\n                self.List_Colors.append(List_Colors[index:index+length])\r\n                index += length\r\n            line = f.readline()\r\n            List_Neurone_type = [int(l) for l in line.split(\"\\t\")[-1].replace('\\n', '').replace('[', '').replace(']', '').replace(\"'\",'').replace(\" \", '').split(',')]\r\n            index = 0\r\n            self.List_Neurone_type = []\r\n            for l in range(len(self.CC.Cellpos)):\r\n                length = len(self.CC.Cellpos[l])\r\n                self.List_Neurone_type.append(List_Neurone_type[index:index + length])\r\n                index += length\r\n            List_Neurone_param=[]\r\n            for line in f:\r\n                finalstring = line.split(\"\\t\")[-1].replace('\\n','').replace(\"{\", \"\").replace(\"}\", \"\").replace(\"'\", \"\").replace(\" \", \"\").replace(\" \", \"\")\r\n\r\n                # Splitting the string based on , we get key value pairs\r\n                listdict = finalstring.split(\",\")\r\n\r\n                dictionary = {}\r\n                for i in listdict:\r\n                    # Get Key Value pairs separately to store in dictionary\r\n                    keyvalue = i.split(\":\")\r\n\r\n                    # Replacing the single quotes in the leading.\r\n                    m = keyvalue[0].strip('\\'')\r\n                    m = m.replace(\"\\\"\", \"\")\r\n                    dictionary[m] = float(keyvalue[1].strip('\"\\''))\r\n                List_Neurone_param.append(dictionary)\r\n\r\n            index = 0\r\n            List_Neurone_param2 = []\r\n            for l in range(len(self.CC.Cellpos)):\r\n                length = len(self.CC.Cellpos[l])\r\n                List_Neurone_param2.append(List_Neurone_param[index:index+length])\r\n                index += length\r\n\r\n            self.createCells = True\r\n            self.update_Model()\r\n            self.CC.List_Neurone_param=List_Neurone_param2\r\n\r\n            self.masceneCM.update()\r\n            # self.update_graph()\r\n            self.electrode_placement_func()\r\n\r\n    def SaveRes(self):\r\n        if hasattr(self, 'Sigs_dict'):\r\n            exPopup = QuestionWhatToSave(self)\r\n            if exPopup.exec_() == QDialog.Accepted:\r\n                saveLFP = exPopup.save_lfp_CB.isChecked()\r\n                savesignals = exPopup.save_signal_CB.isChecked()\r\n                savecoords = exPopup.save_coord_CB.isChecked()\r\n                if not saveLFP and not savesignals and not savecoords:\r\n                    return\r\n            else:\r\n                return\r\n            exPopup.deleteLater()\r\n            if not savesignals:\r\n                Sigs_dict={}\r\n            else:\r\n                Sigs_dict = copy.deepcopy(self.Sigs_dict)\r\n\r\n            if not 't' in Sigs_dict.keys():\r\n                Sigs_dict[\"t\"] = self.t\r\n\r\n            if hasattr(self, 'LFP') and saveLFP:\r\n                if len(self.LFP) == len(Sigs_dict[\"t\"]):\r\n                    Sigs_dict['LFP']= self.LFP\r\n\r\n            if hasattr(self, 'CellPosition') and savecoords:\r\n                    Sigs_dict['Coordinates'] = self.CellPosition\r\n\r\n            if savecoords:\r\n                fileName = QFileDialog.getSaveFileName(caption='Save parameters', filter=\".mat (*.mat);;.data (*.data)\")\r\n            else:\r\n                fileName = QFileDialog.getSaveFileName(caption='Save parameters', filter=\".mat (*.mat);;.data (*.data);;.csv (*.csv);;.dat (*.dat);;.bin (*.bin);;.edf (*.edf)\")\r\n\r\n            if (fileName[0] == ''):\r\n                return\r\n            tp = Sigs_dict['t']\r\n            if fileName[1] == '.data (*.data)':\r\n                file_pi = open(fileName[0], 'wb')\r\n                pickle.dump(Sigs_dict, file_pi, -1)\r\n                file_pi.close()\r\n            elif fileName[1] == '.bin (*.bin)':\r\n                # write .des file\r\n                path, name = os.path.split(fileName[0])\r\n                name = name.split('.')[0]\r\n                file = open(os.path.join(path, name + '.des'), \"w\")\r\n                file.write(\"[patient]  x\" + '\\n')\r\n                file.write(\"[date] \" + datetime.datetime.today().strftime('%m/%d/%Y') + '\\n')\r\n                file.write(\"[time] \" + datetime.datetime.today().strftime('%H:%M:%S') + '\\n')\r\n                Fs = int(1. / (tp[1] - tp[0]))\r\n                file.write(\"[samplingfreq] \" + str(Fs) + '\\n')\r\n                file.write(\"[nbsegments] 1\" + '\\n')\r\n                file.write(\"[enabled] 1\" + '\\n')\r\n                nsample = len(tp)\r\n                file.write(\"[nbsamples] \" + str(nsample) + '\\n')\r\n                file.write(\"[segmentsize] \" + str(nsample) + '\\n')\r\n                file.write(\"[segmentInitialTimes] 0.0\" + '\\n')\r\n                file.write(\"[nbchannels] \" + str(len(Sigs_dict)) + '\\n')\r\n                file.write(\"[channelnames] :\" + '\\n')\r\n                for s in Sigs_dict.keys():\r\n                    file.write(s + \" ------\" + '\\n')\r\n                # file.write('aaa'+\" ------\"+ '\\n')\r\n                file.close()\r\n                keys = list(Sigs_dict.keys())\r\n                array = np.array(Sigs_dict[keys[0]])\r\n                for s in keys[1:]:\r\n                    array = np.vstack((array, Sigs_dict[s] * 1000))\r\n                array = array.T.flatten()\r\n                array.astype('float32')\r\n                s = struct.pack('f' * len(array), *array)\r\n                file = open(os.path.join(path, name + '.bin'), \"wb\")\r\n                # array.tofile(file)\r\n                file.write(s)\r\n                file.close()\r\n\r\n            elif fileName[1] == '.mat (*.mat)':\r\n                scipy.io.savemat(fileName[0], mdict=Sigs_dict)\r\n            elif fileName[1] == '.csv (*.csv)':\r\n                f = open(fileName[0], 'w')\r\n                w = csv.writer(f, delimiter='\\t', lineterminator='\\n')\r\n                w.writerow(Sigs_dict.keys())\r\n                for values in Sigs_dict.values():\r\n                    w.writerow(['{:e}'.format(var) for var in values])\r\n                f.close()\r\n            elif fileName[1] == '.dat (*.dat)':\r\n                # write .des file\r\n                path, name = os.path.split(fileName[0])\r\n                name = name.split('.')[0]\r\n                file = open(os.path.join(path, name + '.des'), \"w\")\r\n                file.write(\"[patient]  x\" + '\\n')\r\n                file.write(\"[date] \" + datetime.datetime.today().strftime('%m/%d/%Y') + '\\n')\r\n                file.write(\"[time] \" + datetime.datetime.today().strftime('%H:%M:%S') + '\\n')\r\n                Fs = int(1. / (tp[1] - tp[0]))\r\n                file.write(\"[samplingfreq] \" + str(Fs) + '\\n')\r\n                file.write(\"[nbsegments] 1\" + '\\n')\r\n                file.write(\"[enabled] 1\" + '\\n')\r\n                nsample = len(tp)\r\n                file.write(\"[nbsamples] \" + str(nsample) + '\\n')\r\n                file.write(\"[segmentsize] \" + str(nsample) + '\\n')\r\n                file.write(\"[segmentInitialTimes] 0.0\" + '\\n')\r\n                file.write(\"[nbchannels] \" + str(len(Sigs_dict)) + '\\n')\r\n                file.write(\"[channelnames] :\" + '\\n')\r\n                for s in Sigs_dict.keys():\r\n                    file.write(s + \" ------\" + '\\n')\r\n                #\r\n                file.close()\r\n                f = open(fileName[0], 'w')\r\n                w = csv.writer(f, delimiter=' ', lineterminator='\\n')\r\n                for idx in range(len(tp)):\r\n                    line = []\r\n                    for i_v, values in enumerate(Sigs_dict.values()):\r\n                        if i_v == 0:\r\n                            line.append(values[idx])\r\n                        else:\r\n                            line.append(values[idx] * 1000)\r\n                    w.writerow(['{:f}'.format(var) for var in line])\r\n                f.close()\r\n            elif fileName[1] == '.edf (*.edf)':\r\n                Fs = int(1. / (tp[1] - tp[0]))\r\n                Sigs_dict.pop(\"t\")\r\n                N = len(Sigs_dict.keys())\r\n                f = pyedflib.EdfWriter(fileName[0], N, file_type=1)\r\n\r\n                lims = 0\r\n                for key, value in Sigs_dict.items():\r\n                    if key not in 't':\r\n                        lims = max(lims,np.max(np.abs(value)))\r\n\r\n                lims *= 2\r\n                for i, key in enumerate(Sigs_dict.keys()):\r\n                    f.setLabel(i, key)\r\n                    f.setSamplefrequency(i, Fs)\r\n                    f.setPhysicalMaximum(i, lims)\r\n                    f.setPhysicalMinimum(i, -lims)\r\n                f.update_header()\r\n\r\n                kiter = len(tp) // Fs\r\n                for k in range(kiter):\r\n                    for i, key in enumerate(Sigs_dict.keys()):\r\n                        f.writePhysicalSamples(Sigs_dict[key][k * Fs:(k + 1) * Fs].flatten())\r\n\r\n                f.update_header()\r\n                f.close()\r\n\r\n        return\r\n\r\n    def LoadModel(self):\r\n        fileName = QFileDialog.getOpenFileName(self, \"Open Model\", \"\", \"Cortical column (*.py)\")\r\n        if fileName[0] == '':\r\n            return\r\n        if fileName[1] == \"Cortical column (*.py)\":\r\n            if os.path.splitext(fileName[0])[1] == '':\r\n                fileName[0] = (fileName[0] + '.py', fileName[1])\r\n            fileName = str(fileName[0])\r\n            (filepath, filename) = os.path.split(fileName)\r\n            sys.path.append(filepath)\r\n            (shortname, extension) = os.path.splitext(filename)\r\n            self.Colonne_class = __import__(shortname)\r\n            self.Colonne = getattr(self.Colonne_class, 'Colonne_cortical')\r\n            self.CC = self.Colonne()\r\n            self.CC.updateTime.something_happened.connect(self.updateTime)\r\n            self.createCells = True\r\n\r\n    def LoadRes(self):\r\n        pass\r\n        #self.mascene_EEGViewer.update(Sigs_dict=self.Sigs_dict, Colors=self.Color)\r\n\r\n    def setmarginandspacing(self, layout):\r\n        layout.setContentsMargins(5, 5, 5, 5)\r\n        layout.setSpacing(5)\r\n\r\n\r\nclass QuestionWhatToSave(QDialog):\r\n    def __init__(self, parent=None, item=None,Graph_Items=None):\r\n        super(QuestionWhatToSave, self).__init__(parent)\r\n        self.parent=parent\r\n        self.Param_box = QGroupBox(\"Select information you wan to save:\")\r\n        self.Param_box.setFixedWidth(300)\r\n        self.layout_Param_box = QVBoxLayout()\r\n        self.item =item\r\n\r\n        self.CB_layout = QVBoxLayout()\r\n        self.save_lfp_CB = QCheckBox('LFP')\r\n        self.save_signal_CB = QCheckBox('Signals')\r\n        self.save_coord_CB = QCheckBox('Coordinates')\r\n        self.save_coord_l = QLabel('Coordinates can only be save in .mat and .data format.')\r\n        self.CB_layout.addWidget(self.save_lfp_CB)\r\n        self.CB_layout.addWidget(self.save_signal_CB)\r\n        self.CB_layout.addWidget(self.save_coord_CB)\r\n        self.CB_layout.addWidget(self.save_coord_l)\r\n        [cb.setChecked(True) for cb in [self.save_lfp_CB,self.save_signal_CB,self.save_coord_CB]]\r\n\r\n        self.horizontalGroupBox_Actions = QWidget()\r\n        self.horizontalGroupBox_Actions.setFixedSize(285,80)\r\n        self.layout_Actions = QHBoxLayout()\r\n        self.Button_Ok=QPushButton('Ok')\r\n        self.Button_Cancel=QPushButton('Cancel')\r\n        self.Button_Ok.setFixedSize(66,30)\r\n        self.Button_Cancel.setFixedSize(66,30)\r\n        self.layout_Actions.addWidget(self.Button_Ok)\r\n        self.layout_Actions.addWidget(self.Button_Cancel)\r\n        self.horizontalGroupBox_Actions.setLayout(self.layout_Actions)\r\n\r\n        self.layout_Param_box.addLayout(self.CB_layout)\r\n        self.layout_Param_box.addWidget(self.horizontalGroupBox_Actions)\r\n        self.Param_box.setLayout(self.layout_Param_box)\r\n        self.setLayout(self.layout_Param_box)\r\n\r\n        self.Button_Ok.clicked.connect(self.myaccept)\r\n        self.Button_Cancel.clicked.connect(self.reject)\r\n\r\n    def myaccept(self):\r\n        self.accept()\r\n\r\n\r\nclass CMViewer(QGraphicsView):\r\n    def __init__(self, parent=None):\r\n        super(CMViewer, self).__init__(parent)\r\n        self.parent = parent\r\n        self.setStyleSheet(\"border: 0px\")\r\n        self.scene = QGraphicsScene(self)\r\n        self.setScene(self.scene)\r\n        self.figure = Figure(facecolor='white')#Figure()\r\n        self.figure.subplots_adjust(left=0.03, bottom=0.02, right=0.95, top=0.95, wspace=0.0, hspace=0.0)\r\n        self.canvas = FigureCanvas(self.figure)\r\n        self.toolbar = NavigationToolbar(self.canvas, self)\r\n\r\n        # self.canvas.setGeometry(0, 0, 1600, 500 )\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(self.toolbar)\r\n        layout.addWidget(self.canvas)\r\n        self.setLayout(layout)\r\n        self.canvas.show()\r\n\r\n    def update(self):\r\n        ConnectivityMatrix = self.parent.Connectivitymatrix\r\n        ExternalPreSynaptic_Cell_AMPA_DPYR = self.parent.CC.ExternalPreSynaptic_Cell_AMPA_DPYR\r\n        ExternalPreSynaptic_Cell_AMPA_Th = self.parent.CC.ExternalPreSynaptic_Cell_AMPA_Th\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        ax = self.figure.add_subplot(111)\r\n        if scipy.sparse.issparse(ConnectivityMatrix):\r\n            im = ax.spy(self.ConnectivityMatrix,markersize=1)\r\n        elif type(ConnectivityMatrix) == type([]):\r\n\r\n            # raw=[]\r\n            # col=[]\r\n            # dat=[]\r\n            #\r\n            # for l in range(len(ConnectivityMatrix)):\r\n            #     for c in ConnectivityMatrix[l]:\r\n            #         raw.append(l)\r\n            #         col.append(c)\r\n            #         dat.append(1)\r\n            #         nb+=1\r\n            # s = sparse.coo_matrix((dat, (raw, col)), shape=(len(ConnectivityMatrix), len(ConnectivityMatrix)))\r\n            # im = ax.spy(s,markersize=1)\r\n            raw=[]\r\n            col=[]\r\n            colors=[]\r\n            nb=0\r\n            flat_list = [item for sublist in self.parent.List_Colors for item in sublist]\r\n            for l in range(len(ConnectivityMatrix)):\r\n                raw.append(-self.parent.CC.NB_Th-self.parent.CC.NB_DPYR-2)\r\n                col.append(l)\r\n                colors.append(flat_list[l])\r\n\r\n                for c in ConnectivityMatrix[l]:\r\n                    raw.append(c)\r\n                    col.append(l)\r\n                    colors.append(flat_list[c])\r\n                    nb+=1\r\n            for l in range(len(ExternalPreSynaptic_Cell_AMPA_DPYR)):\r\n                for c in range(len(ExternalPreSynaptic_Cell_AMPA_DPYR[l])):\r\n                    raw.append(-ExternalPreSynaptic_Cell_AMPA_DPYR[l][c]-1)\r\n                    col.append(l)\r\n                    colors.append(\"#000000\")\r\n            for l in range(len(ExternalPreSynaptic_Cell_AMPA_Th)):\r\n                for c in range(len(ExternalPreSynaptic_Cell_AMPA_Th[l])):\r\n                    raw.append(-ExternalPreSynaptic_Cell_AMPA_Th[l][c]-1-self.parent.CC.NB_DPYR)\r\n                    col.append(l)\r\n                    colors.append(\"#999999\")\r\n            if platform.system() in [\"Windows\",\"Linux\"]:\r\n                ax.scatter(raw, col, c=colors, s=10)\r\n            elif platform.system() == \"Darwin\":\r\n                ax.scatter(raw, col, c=colors, s=5)\r\n\r\n        else:\r\n            im = ax.imshow(ConnectivityMatrix)\r\n        if platform.system() in [\"Windows\", \"Linux\"]:\r\n            ax.set_title('ConnectivityMatrix' + str(nb), fontdict={'fontsize': 10})\r\n        elif platform.system() == \"Darwin\":\r\n            ax.set_title('ConnectivityMatrix' + str(nb), fontdict={'fontsize': 5})\r\n\r\n\r\n        ax.set_xlabel('Sources')\r\n        ax.set_ylabel('Targets')\r\n\r\n        # rect = patches.Rectangle((0, 0), self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[3] - 1, self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[3] - 1, linewidth=1, edgecolor='y', facecolor='none')\r\n        # ax.add_patch(rect)\r\n        # rect = patches.Rectangle((0, 0), self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[2] - 1, self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[2] - 1, linewidth=1, edgecolor='b', facecolor='none')\r\n        # ax.add_patch(rect)\r\n        # rect = patches.Rectangle((0, 0), self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[1] - 1, self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[1] - 1, linewidth=1, edgecolor='g', facecolor='none')\r\n        # ax.add_patch(rect)\r\n        # rect = patches.Rectangle((0, 0), self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[0] - 1, self.parent.Nb_of_PYR_BAS_SOM_BIS_sum[0] - 1, linewidth=1, edgecolor='r', facecolor='none')\r\n        # ax.add_patch(rect)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    # def closeEvent(self, event):\r\n    #     plt.close(self.figure)\r\n\r\nclass StimViewer(QGraphicsView):\r\n    def __init__(self, parent=None):\r\n        super(StimViewer, self).__init__(parent)\r\n        self.parent = parent\r\n        self.setStyleSheet(\"border: 0px\")\r\n        self.scene = QGraphicsScene(self)\r\n        self.setScene(self.scene)\r\n        self.figure = Figure(facecolor='white')#Figure()\r\n        self.figure.subplots_adjust(left=0.10, bottom=0.10, right=0.95, top=0.95, wspace=0.0, hspace=0.0)\r\n        self.canvas = FigureCanvas(self.figure)\r\n        self.toolbar = NavigationToolbar(self.canvas, self)\r\n\r\n        # self.canvas.setGeometry(0, 0, 1600, 500 )\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(self.toolbar)\r\n        layout.addWidget(self.canvas)\r\n        self.setLayout(layout)\r\n        self.canvas.show()\r\n\r\n    def update(self, stim, th):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n\r\n        if not stim == []:\r\n            t = np.arange(stim.shape[1]) * self.parent.dt\r\n            ax = self.figure.add_subplot(211)\r\n            for i, s in enumerate(stim):\r\n                ax.plot(t, s + i * float(self.parent.TH_i_inj_e.text()),c='#000000')\r\n        if not th == []:\r\n            t = np.arange(th.shape[1]) * self.parent.dt\r\n            ax = self.figure.add_subplot(212)\r\n            for i, s in enumerate(th):\r\n                ax.plot(t, s + i * float(self.parent.i_inj_e.text()),c='#999999')\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    # def closeEvent(self, event):\r\n    #     plt.close(self.figure)\r\n\r\nclass LFPViewer(QGraphicsView):\r\n    def __init__(self, parent=None):\r\n        super(LFPViewer, self).__init__(parent)\r\n        self.parent = parent\r\n        self.setStyleSheet(\"border: 0px\")\r\n        self.scene = QGraphicsScene(self)\r\n        self.setScene(self.scene)\r\n        self.figure = Figure(facecolor='white')\r\n        self.figure.subplots_adjust(left=0.10, bottom=0.10, right=0.95, top=0.95, wspace=0.0, hspace=0.0)\r\n        self.canvas = FigureCanvas(self.figure)\r\n        self.toolbar = NavigationToolbar(self.canvas, self)\r\n\r\n        # self.canvas.setGeometry(0, 0, 1600, 500 )\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(self.toolbar)\r\n        layout.addWidget(self.canvas)\r\n        self.setLayout(layout)\r\n        self.canvas.show()\r\n\r\n    def addLFP(self,lfp, shiftT=0.):\r\n        self.LFP = self.parent.LFP\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n\r\n        t = np.arange(self.parent.nbEch) * self.parent.dt + shiftT\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        ax.plot(t,self.LFP)\r\n        ax.plot(t,lfp)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def updatePSD(self, shiftT=0.):\r\n        self.LFP = self.parent.LFP\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n\r\n        fs = int(1 / self.parent.dt )\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n\r\n        # f, t, Sxx = signal.spectrogram(self.LFP, fs* 1000, return_onesided=True,nperseg=fs*50, noverlap=fs*49, nfft=None)\r\n        f, t, Sxx = signal.spectrogram(self.LFP, fs* 1000, return_onesided=True,nperseg=fs*20, noverlap=fs*19, nfft=fs*100)\r\n        fmax=500\r\n        indfmax = np.where(f>fmax)[0][0]\r\n        # ax.pcolormesh(t, f[:indfmax], 10*np.log10(Sxx[:indfmax,:]) )\r\n        ax.pcolormesh(t, f[:indfmax],  Sxx[:indfmax,:] )\r\n\r\n        ax.set_ylabel('Frequency [Hz]')\r\n\r\n        ax.set_xlabel('Time [sec]')\r\n\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update(self, shiftT=0.):\r\n        self.LFP = self.parent.LFP\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n\r\n        t = np.arange(self.parent.nbEch) * self.parent.dt + shiftT\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        ax.plot(t,self.LFP)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_thresholding(self,sig,sigbin_perc, shiftT=0.,titre=''):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n\r\n        t = np.arange(self.parent.nbEch) * self.parent.dt + shiftT\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        ax.plot(t,sig)\r\n        ax.plot(t,sigbin_perc)\r\n        ax.set_ylabel(r'% pyramid firing')\r\n        ax.set_xlabel(r'Time (s)')\r\n        ax.set_title(titre)\r\n        self.figure.set_tight_layout(True)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_AutoCorrelation(self,sig,autocorr, shiftT=0.,titre=''):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n\r\n        t = np.arange(self.parent.nbEch) * self.parent.dt + shiftT\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(211)\r\n        ax.plot(t, sig)\r\n        ax.set_ylabel(r'% pyramid firing ')\r\n        ax.set_xlabel(r'Time (s)')\r\n        ax.set_title(titre)\r\n        ax2 = self.figure.add_subplot(212)\r\n        ax2.plot(np.arange(len(autocorr))*(t[1]-t[0]) - len(sig)*(t[1]-t[0]), autocorr)\r\n        ax2.set_ylabel(r'autocorrelation ')\r\n        ax2.set_xlabel(r'Time (s)')\r\n        self.figure.set_tight_layout(True)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n\r\n    def update_synchro_NearestDelay_scatter(self,Aps_centers, shiftT=0.,titre=''):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        for i in range(len(Aps_centers)):\r\n            ax.scatter(Aps_centers[i],i* np.ones(len(Aps_centers[i])),c='b')\r\n\r\n        ax.set_ylabel(r'Nb pyramid cell')\r\n        ax.set_xlabel(r'Time (s)')\r\n        ax.set_title(titre)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_NearestDelay_boxplot(self,Aps_delays, shiftT=0.,titre=''):\r\n\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        Aps_delays_flatten=[]\r\n        for i in range(len(Aps_delays)):\r\n            if not Aps_delays[i] == []:\r\n                Aps_delays_flatten.append(np.concatenate(Aps_delays[i]).ravel())\r\n            else:\r\n                Aps_delays_flatten.append([])\r\n        ax.boxplot(Aps_delays_flatten)\r\n        ax.set_ylabel(r'delays (ms)')\r\n        ax.set_xlabel(r'Nb pyramid cell')\r\n        ax.set_title(titre)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_NearestDelay(self, Aps_centers,Aps_delays, shiftT=0.,titre=''):\r\n\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax1 = self.figure.add_subplot(121)\r\n        for i in range(len(Aps_centers)):\r\n            ax1.scatter(Aps_centers[i], i * np.ones(len(Aps_centers[i])), c='b')\r\n\r\n        ax1.set_ylabel(r'Nb pyramid cell')\r\n        ax1.set_xlabel(r'Time (s)')\r\n        ax1.set_title(titre)\r\n\r\n        ax2 = self.figure.add_subplot(122)\r\n        Aps_delays_flatten = []\r\n        for i in range(len(Aps_delays)):\r\n            if not Aps_delays[i] == []:\r\n                Aps_delays_flatten.append(np.concatenate(Aps_delays[i]).ravel())\r\n            else:\r\n                Aps_delays_flatten.append([])\r\n        ax2.boxplot(Aps_delays_flatten)\r\n        ax2.set_ylabel(r'delays (ms)')\r\n        ax2.set_xlabel(r'Nb pyramid cell')\r\n        ax2.set_title(titre)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_NearestDelay2(self, Aps_centers,Aps_delays, Aps_gauss_fit, shiftT=0.,titre=''):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax1 = self.figure.add_subplot(131)\r\n        for i in range(len(Aps_centers)):\r\n            ax1.scatter(Aps_centers[i], i * np.ones(len(Aps_centers[i])), c='b')\r\n\r\n        ax1.set_ylabel(r'Nb pyramid cell')\r\n        ax1.set_xlabel(r'Time (s)')\r\n\r\n        ax2 = self.figure.add_subplot(132)\r\n        Aps_delays_flatten = []\r\n        for i in range(len(Aps_delays)):\r\n            if not Aps_delays[i] == []:\r\n                Aps_delays_flatten.append(np.concatenate(Aps_delays[i]).ravel())\r\n            else:\r\n                Aps_delays_flatten.append([])\r\n        ax2.boxplot(Aps_delays_flatten)\r\n        ax2.set_ylabel(r'delays (ms)')\r\n        ax2.set_xlabel(r'Nb pyramid cell')\r\n        ax2.set_title(titre)\r\n\r\n        ax3 = self.figure.add_subplot(133)\r\n        # ax3.boxplot(Aps_gauss_fit)\r\n        ax3.scatter(range(len(Aps_gauss_fit)),Aps_gauss_fit,c='k')\r\n        ax3.set_ylabel(r'gauss fit sigma')\r\n        ax3.set_xlabel(r'Nb pyramid cell')\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_ISI_distance(self,IntegralI,titre=''):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        current_cmap = matplotlib.cm.get_cmap('viridis')\r\n        current_cmap.set_bad(color='black')\r\n        im = ax.imshow(IntegralI,cmap=current_cmap )\r\n        self.figure.colorbar(im )\r\n        ax.set_ylabel(r'Nb pyramid cell')\r\n        ax.set_xlabel(r'Nb pyramid cell')\r\n        ax.set_title(titre)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_vanRossum_distance(self,vr_dist, titre='vanRossum_distance'):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        current_cmap = matplotlib.cm.get_cmap('viridis')\r\n        current_cmap.set_bad(color='black')\r\n        im = ax.imshow(vr_dist, cmap=current_cmap)\r\n        self.figure.colorbar(im)\r\n        ax.set_ylabel(r'Nb pyramid cell')\r\n        ax.set_xlabel(r'Nb pyramid cell')\r\n        ax.set_title(titre)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    def update_synchro_VictorPurpura_distance(self, vp_dist, titre='VictorPurpura_distance'):\r\n        self.figure.clear()\r\n        self.figure.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95, wspace=0.3, hspace=0.1)\r\n        # plt.figure()\r\n        ax = self.figure.add_subplot(111)\r\n        current_cmap = matplotlib.cm.get_cmap('viridis')\r\n        current_cmap.set_bad(color='black')\r\n        im = ax.imshow(vp_dist, cmap=current_cmap)\r\n        self.figure.colorbar(im)\r\n        ax.set_ylabel(r'Nb pyramid cell')\r\n        ax.set_xlabel(r'Nb pyramid cell')\r\n        ax.set_title(titre)\r\n\r\n        self.canvas.draw_idle()\r\n        self.canvas.show()\r\n\r\n    # def closeEvent(self, event):\r\n    #     plt.close(self.figure)\r\n\r\nclass Rescalesize(QDialog):\r\n    def __init__(self, parent=None, x=None, y=None, z=None):\r\n        super(Rescalesize, self).__init__(parent)\r\n        self.parent=parent\r\n        self.x=x\r\n        self.y=y\r\n        self.z=z\r\n        self.Param_box = QWidget()\r\n        self.Param_box.setFixedWidth(400)\r\n        self.layout_Param_box = QVBoxLayout()\r\n\r\n\r\n        self.Layout_param = QHBoxLayout()\r\n        self.scale_GB = QGroupBox(\"rescale\")\r\n\r\n        # tissue size\r\n        self.tissue_scale_GB = QGroupBox(r'scale value')\r\n        labelX, self.xs_e = Layout_grid_Label_Edit(label=['x'], edit=['1'])\r\n        labelY, self.ys_e = Layout_grid_Label_Edit(label=['y'], edit=['1'])\r\n        labelZ, self.zs_e = Layout_grid_Label_Edit(label=['z'], edit=['1'])\r\n        self.xs_e = self.xs_e[0]\r\n        self.ys_e = self.ys_e[0]\r\n        self.zs_e = self.zs_e[0]\r\n        grid = QGridLayout()\r\n        self.tissue_scale_GB.setLayout(grid)\r\n        # grid.setContentsMargins(0,0,0,0)\r\n        grid.setSpacing(0)\r\n        grid.addWidget(labelX, 0, 0)\r\n        grid.addWidget(labelY, 1, 0)\r\n        grid.addWidget(labelZ, 2, 0)\r\n        self.xs_e.textChanged.connect(lambda state, s='x': self.rescale_axe(s))\r\n        self.ys_e.textChanged.connect(lambda state, s='y': self.rescale_axe(s))\r\n        self.zs_e.textChanged.connect(lambda state, s='z': self.rescale_axe(s))\r\n        self.Layout_param.addWidget(self.tissue_scale_GB)\r\n\r\n        self.tissue_size_GB = QGroupBox(r'tissue size')\r\n        labelX, self.x_e = Layout_grid_Label_Edit(label=['x'], edit=[x])\r\n        labelY, self.y_e = Layout_grid_Label_Edit(label=['y'], edit=[y])\r\n        labelZ, self.z_e = Layout_grid_Label_Edit(label=['z'], edit=[z])\r\n        self.x_e = self.x_e[0]\r\n        self.y_e = self.y_e[0]\r\n        self.z_e = self.z_e[0]\r\n        grid = QGridLayout()\r\n        self.tissue_size_GB.setLayout(grid)\r\n        # grid.setContentsMargins(0,0,0,0)\r\n        grid.setSpacing(0)\r\n        grid.addWidget(labelX, 0, 0)\r\n        grid.addWidget(labelY, 1, 0)\r\n        grid.addWidget(labelZ, 2, 0)\r\n        self.x_e.textChanged.connect(lambda state, s='x': self.resize_axe(s))\r\n        self.y_e.textChanged.connect(lambda state, s='y': self.resize_axe(s))\r\n        self.z_e.textChanged.connect(lambda state, s='z': self.resize_axe(s))\r\n        self.Layout_param.addWidget(self.tissue_size_GB)\r\n\r\n        self.horizontalGroupBox_Actions = QGroupBox(\"Actions\")\r\n        self.horizontalGroupBox_Actions.setFixedSize(285,80)\r\n        self.layout_Actions = QHBoxLayout()\r\n        self.Button_Ok=QPushButton('Ok')\r\n        self.Button_Cancel=QPushButton('Cancel')\r\n        self.Button_Ok.setFixedSize(66,30)\r\n        self.Button_Cancel.setFixedSize(66,30)\r\n        self.layout_Actions.addWidget(self.Button_Ok)\r\n        self.layout_Actions.addWidget(self.Button_Cancel)\r\n        self.horizontalGroupBox_Actions.setLayout(self.layout_Actions)\r\n\r\n        self.layout_Param_box.addLayout(self.Layout_param)\r\n        self.layout_Param_box.addWidget(self.horizontalGroupBox_Actions)\r\n        self.Param_box.setLayout(self.layout_Param_box)\r\n        self.setLayout(self.layout_Param_box)\r\n\r\n        self.Button_Ok.clicked.connect(self.myaccept)\r\n        self.Button_Cancel.clicked.connect(self.reject)\r\n\r\n    def myaccept(self):\r\n        self.accept()\r\n\r\n    def resize_axe(self,s):\r\n        try:\r\n            if s == 'x':\r\n                self.xs_e.blockSignals(True)\r\n                self.xs_e.setText(str(float(self.x_e.text()) / float(self.x)))\r\n                self.xs_e.blockSignals(False)\r\n            elif s =='y':\r\n                self.ys_e.blockSignals(True)\r\n                self.ys_e.setText(str(float(self.y_e.text()) / float(self.y)))\r\n                self.ys_e.blockSignals(False)\r\n            elif s == 'z':\r\n                self.zs_e.blockSignals(True)\r\n                self.zs_e.setText(str(float(self.z_e.text()) / float(self.z)))\r\n                self.zs_e.blockSignals(False)\r\n        except:\r\n            pass\r\n\r\n    def rescale_axe(self,s):\r\n        try:\r\n            if s == 'x':\r\n                self.x_e.blockSignals(True)\r\n                self.x_e.setText(str(float(self.xs_e.text()) * float(self.x)))\r\n                self.x_e.blockSignals(False)\r\n            elif s =='y':\r\n                self.y_e.blockSignals(True)\r\n                self.y_e.setText(str(float(self.ys_e.text()) * float(self.y)))\r\n                self.y_e.blockSignals(False)\r\n            elif s == 'z':\r\n                self.z_e.blockSignals(True)\r\n                self.z_e.setText(str(float(self.zs_e.text()) * float(self.z)))\r\n                self.z_e.blockSignals(False)\r\n        except:\r\n            pass\r\n\r\nclass Afferences_Managment(QDialog):\r\n    def __init__(self,parent):\r\n        super(Afferences_Managment, self).__init__()\r\n\r\n        self.parent = parent\r\n\r\n        self.layoutparam = QVBoxLayout()\r\n        self.List_Var_GB = QWidget()\r\n        label_source = QLabel('Target')\r\n        label_Target = QLabel('S\\no\\nu\\nr\\nc\\ne')\r\n        label_PYR1 = QLabel('PYR')\r\n        label_PYR2 = QLabel('PYR')\r\n        label_BAS1 = QLabel('BAS')\r\n        label_BAS2 = QLabel('BAS')\r\n        label_OLM1 = QLabel('OLM')\r\n        label_OLM2 = QLabel('OLM')\r\n        label_BIS1 = QLabel('BIS')\r\n        label_BIS2 = QLabel('BIS')\r\n        grid = QGridLayout()\r\n        grid.setAlignment(Qt.AlignTop)\r\n        grid.setContentsMargins(5, 5, 5, 5, )\r\n        grid.addWidget(label_source, 0, 1, 1, 5, Qt.AlignHCenter)\r\n        grid.addWidget(label_Target, 1, 0, 5, 1, Qt.AlignVCenter)\r\n\r\n        # grid.addWidget(label_PYR1, 2, 1)\r\n        # grid.addWidget(label_BAS1, 3, 1)\r\n        # grid.addWidget(label_OLM1, 4, 1)\r\n        # grid.addWidget(label_BIS1, 5, 1)\r\n        # grid.addWidget(label_PYR2, 1, 2)\r\n        # grid.addWidget(label_BAS2, 1, 3)\r\n        # grid.addWidget(label_OLM2, 1, 4)\r\n        # grid.addWidget(label_BIS2, 1, 5)\r\n\r\n\r\n        # self.List_Var = self.List_Var / 15\r\n        self.List_Var_e = []\r\n        for l in range(self.parent.CC.Afferences.shape[0]):\r\n            for c in range(self.parent.CC.Afferences.shape[1]):\r\n                edit = LineEdit_Int(str(self.parent.CC.Afferences[l, c]))\r\n                self.List_Var_e.append(edit)\r\n                grid.addWidget(edit, l + 2, c + 2)\r\n        self.List_Var_GB.setLayout(grid)\r\n\r\n        self.buttons = QDialogButtonBox(\r\n            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,\r\n            Qt.Horizontal, self)\r\n        self.buttons.accepted.connect(self.myaccept)\r\n        self.buttons.rejected.connect(self.reject)\r\n\r\n        self.layoutparam.addWidget(self.List_Var_GB)\r\n        self.layoutparam.addWidget(self.buttons)\r\n        self.setLayout(self.layoutparam)\r\n\r\n\r\n\r\n    def myaccept(self):\r\n        matrice = np.zeros(self.parent.CC.Afferences.shape)\r\n        ind = 0\r\n        for l in range(self.parent.CC.Afferences.shape[0]):\r\n            for c in range(self.parent.CC.Afferences.shape[1]):\r\n                matrice[l,c] =  float(self.List_Var_e[ind].text())\r\n        self.parent.CC.Afferences = matrice *0.5\r\n        self.accept()\r\n\r\nclass Afferences_ManagmentTable(QDialog):\r\n    def __init__(self,parent):\r\n        super(Afferences_ManagmentTable, self).__init__()\r\n        self.setWindowFlag(Qt.WindowMinimizeButtonHint, True)\r\n        self.setWindowFlag(Qt.WindowMaximizeButtonHint, True)\r\n        self.parent = parent\r\n\r\n        self.layoutparam = QVBoxLayout()\r\n        self.tableWidget = QTableWidget()\r\n\r\n        fnt = QFont()\r\n        fnt.setPointSize(8)\r\n        self.tableWidget.setFont(fnt)\r\n\r\n        Afferences = self.parent.CC.Afferences\r\n        line, column = Afferences.shape\r\n\r\n        self.tableWidget.horizontalHeader().setDefaultSectionSize(42)\r\n        self.tableWidget.verticalHeader().setDefaultSectionSize(30)\r\n\r\n        self.tableWidget.setRowCount(line+4)\r\n        self.tableWidget.setColumnCount(column+2)\r\n\r\n        self.tableWidget.setItemDelegate(Delegate())\r\n\r\n        item_Layer = [\"I\",\"II/III\",\"IV\",\"V\",\"VI\"]\r\n        item_type = [\"PC\",\"PV\",\"SST\",\"VIP\",\"RLN\"]#d0a9ce\r\n        item_color = [\"#d0a9ce\",\"#c5e0b4\",\"#dae0f3\",\"#f8cbad\",\"#ffe699\"]\r\n\r\n\r\n        for j in range(len(item_Layer)):\r\n            item = QTableWidgetItem(item_Layer[j])\r\n            self.tableWidget.setSpan(2+j*5, 0, 5, 1)\r\n            self.tableWidget.setItem(2+j*5, 0, item)\r\n            item2 = QTableWidgetItem(item_Layer[j])\r\n            self.tableWidget.setSpan(0, 2+j*5, 1, 5)\r\n            self.tableWidget.setItem(0, 2+j*5, item2)\r\n\r\n        item = QTableWidgetItem(\"Thalamus\")\r\n        self.tableWidget.setSpan(2 + 24 + 1, 0, 1, 2)\r\n        self.tableWidget.setItem(2 + 24 + 1, 0, item)\r\n        item = QTableWidgetItem(\"Distant Cortex\")\r\n        self.tableWidget.setSpan(2 + 24 + 2, 0, 1, 2)\r\n        self.tableWidget.setItem(2 + 24 + 2, 0, item)\r\n        item = QTableWidgetItem(\"Sources\")\r\n        self.tableWidget.setItem(1, 0, item)\r\n        item = QTableWidgetItem(\"Targets\")\r\n        self.tableWidget.setItem(0, 1, item)\r\n\r\n        ind = 2\r\n        self.List_possible_connexion = np.array(\r\n            [[1, 1, 1, 1, 0],  # PC -> PC,PV,SST,VIP ,RLN  affinits de connexion entre cellules\r\n             [1, 1, 0, 0, 0],  # PV -> PC,PV,SST,VIP ,RLN\r\n             [1, 1, 0, 1, 1],  # SST -> PC,PV,SST,VIP ,RLN\r\n             [0, 0, 1, 0, 0],  # VIP --> PC,PV,SST,VIP ,RLN\r\n             [1, 1, 1, 1, 1]  # RLN --> PC,PV,SST,VIP ,RLN\r\n             ])\r\n        for i in range(5):\r\n            for j in range(len(item_type)):\r\n                item = QTableWidgetItem(item_type[j])\r\n                item2 = QTableWidgetItem(item_type[j])\r\n                item.setBackground(QColor(item_color[j]))\r\n                item2.setBackground(QColor(item_color[j]))\r\n\r\n                self.tableWidget.setItem(ind, 1, item)\r\n                self.tableWidget.setItem(1, ind, item2)\r\n                ind += 1\r\n\r\n        for c in range(Afferences.shape[0]):\r\n            type1 = int(np.mod(c,5))\r\n            for l in range(Afferences.shape[1]):\r\n                type2 = int(np.mod(l, 5))\r\n                item = QTableWidgetItem(str(Afferences[c, l]))\r\n                # if self.List_possible_connexion[type2,type1]:\r\n                #     item.setFlags(item.flags() & ~Qt.ItemIsEditable)\r\n                self.tableWidget.setItem(c+2, l+2, item)\r\n\r\n        # label_source = QLabel('Target')\r\n        # label_Target = QLabel('S\\no\\nu\\nr\\nc\\ne')\r\n        # label_PYR1 = QLabel('PYR')\r\n        # label_PYR2 = QLabel('PYR')\r\n        # label_BAS1 = QLabel('BAS')\r\n        # label_BAS2 = QLabel('BAS')\r\n        # label_OLM1 = QLabel('OLM')\r\n        # label_OLM2 = QLabel('OLM')\r\n        # label_BIS1 = QLabel('BIS')\r\n        # label_BIS2 = QLabel('BIS')\r\n        # grid = QGridLayout()\r\n        # grid.setAlignment(Qt.AlignTop)\r\n        # grid.setContentsMargins(5, 5, 5, 5, )\r\n        # grid.addWidget(label_source, 0, 1, 1, 5, Qt.AlignHCenter)\r\n        # grid.addWidget(label_Target, 1, 0, 5, 1, Qt.AlignVCenter)\r\n        #\r\n        # # grid.addWidget(label_PYR1, 2, 1)\r\n        # # grid.addWidget(label_BAS1, 3, 1)\r\n        # # grid.addWidget(label_OLM1, 4, 1)\r\n        # # grid.addWidget(label_BIS1, 5, 1)\r\n        # # grid.addWidget(label_PYR2, 1, 2)\r\n        # # grid.addWidget(label_BAS2, 1, 3)\r\n        # # grid.addWidget(label_OLM2, 1, 4)\r\n        # # grid.addWidget(label_BIS2, 1, 5)\r\n        #\r\n        #\r\n        # # self.List_Var = self.List_Var / 15\r\n        # self.List_Var_e = []\r\n        # for l in range(self.parent.CC.Afferences.shape[0]):\r\n        #     for c in range(self.parent.CC.Afferences.shape[1]):\r\n        #         edit = LineEdit_Int(str(self.parent.CC.Afferences[l, c]))\r\n        #         self.List_Var_e.append(edit)\r\n        #         grid.addWidget(edit, l + 2, c + 2)\r\n        # self.List_Var_GB.setLayout(grid)\r\n\r\n        self.math_param = QHBoxLayout()\r\n        self.value_LE = LineEdit('0')\r\n        self.add_PB = QPushButton('+')\r\n        self.sub_PB = QPushButton('-')\r\n        self.time_PB = QPushButton('x')\r\n        self.divide_PB = QPushButton('/')\r\n        self.roundup_PB = QPushButton('')\r\n        self.Save_PB = QPushButton('Save')\r\n        self.Load_PB = QPushButton('Load')\r\n        self.math_param.addWidget(QLabel('Value'))\r\n        self.math_param.addWidget(self.value_LE)\r\n        self.math_param.addWidget(self.add_PB)\r\n        self.math_param.addWidget(self.sub_PB)\r\n        self.math_param.addWidget(self.time_PB)\r\n        self.math_param.addWidget(self.divide_PB)\r\n        self.math_param.addWidget(self.roundup_PB)\r\n        self.math_param.addWidget(self.Save_PB)\r\n        self.math_param.addWidget(self.Load_PB)\r\n        self.add_PB.clicked.connect(lambda state, x='+': self.math_fun(x))\r\n        self.sub_PB.clicked.connect(lambda state, x='-': self.math_fun(x))\r\n        self.time_PB.clicked.connect(lambda state, x='x': self.math_fun(x))\r\n        self.divide_PB.clicked.connect(lambda state, x='/': self.math_fun(x))\r\n        self.roundup_PB.clicked.connect(lambda state, x='': self.math_fun(x))\r\n        self.Save_PB.clicked.connect( self.Save_fun)\r\n        self.Load_PB.clicked.connect( self.Load_fun)\r\n\r\n        self.buttons = QDialogButtonBox(\r\n            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,\r\n            Qt.Horizontal, self)\r\n        self.buttons.accepted.connect(self.myaccept)\r\n        self.buttons.rejected.connect(self.reject)\r\n\r\n        self.layoutparam.addWidget(self.tableWidget)\r\n        self.layoutparam.addLayout(self.math_param)\r\n        self.layoutparam.addWidget(self.buttons)\r\n        self.setLayout(self.layoutparam)\r\n\r\n    def Save_fun(self):\r\n        # try:\r\n        matrice = np.zeros(self.parent.CC.Afferences.shape)\r\n        for l in range(self.parent.CC.Afferences.shape[0]):\r\n            for c in range(self.parent.CC.Afferences.shape[1]):\r\n                item = self.tableWidget.item(l+2,c+2)\r\n                matrice[l,c] =  float(item.text())\r\n        # except:\r\n        #     msg_cri(s='The values in the table are not compatible.\\nPlease check them.')\r\n\r\n        extension = \"csv\"\r\n        fileName = QFileDialog.getSaveFileName(caption='Save Matrix', filter=extension + \" (*.\" + extension + \")\")\r\n        if  (fileName[0] == '') :\r\n            return\r\n        if os.path.splitext(fileName[0])[1] == '':\r\n            fileName= (fileName[0] + '.' + extension , fileName[1])\r\n        # try:\r\n        if fileName[1] == extension +\" (*.\" + extension +\")\" :\r\n            np.savetxt(fileName[0], matrice, delimiter=\";\",fmt='%0.4f')\r\n        # except:\r\n        #     msg_cri(s='Impossible to save the file.\\n')\r\n\r\n    def Load_fun(self):\r\n        fileName = QFileDialog.getOpenFileName(self, \"Load Matrix\", \"\", \"csv (*.csv)\")\r\n        if fileName[0] == '':\r\n            return\r\n        if fileName[1] == \"csv (*.csv)\":\r\n            matrice = np.loadtxt(fileName[0],delimiter=\";\")\r\n            for l in range(matrice.shape[0]):\r\n                for c in range(matrice.shape[1]):\r\n                    item = self.tableWidget.item(l+2,c+2)\r\n                    item.setText(str(matrice[l,c]))\r\n\r\n    def math_fun(self,s=''):\r\n        Items = self.tableWidget.selectedItems()\r\n        for item in Items:\r\n            if item.column()>1 and item.row()>1:\r\n                # type1 = int(np.mod(item.column(), 5))\r\n                # type2 = int(np.mod(item.row(), 5))\r\n                # if self.List_possible_connexion[type2, type1]:\r\n                value = float(self.value_LE.text())\r\n                cell_val = float(item.text())\r\n                if s == '+':\r\n                    item.setText(str(cell_val + value))\r\n                elif s == '-':\r\n                    item.setText(str(cell_val - value))\r\n                elif s == 'x':\r\n                    item.setText(str(cell_val * value))\r\n                elif s == '/':\r\n                    if not value == 0:\r\n                        item.setText(str(cell_val / value))\r\n                elif s == '':\r\n                    item.setText(str(np.ceil(cell_val)))\r\n\r\n    def myaccept(self):\r\n        try:\r\n            matrice = np.zeros(self.parent.CC.Afferences.shape)\r\n            for l in range(self.parent.CC.Afferences.shape[0]):\r\n                for c in range(self.parent.CC.Afferences.shape[1]):\r\n                    item = self.tableWidget.item(l+2,c+2)\r\n                    matrice[l,c] =  float(item.text())\r\n        except:\r\n            msg_cri(s='The values in the table are not compatible.\\nPlease check them.')\r\n        self.parent.CC.Afferences = matrice\r\n        self.accept()\r\n\r\n\r\nclass Connection_ManagmentTable(QDialog):\r\n    def __init__(self,parent):\r\n        super(Connection_ManagmentTable, self).__init__()\r\n        self.setWindowFlag(Qt.WindowMinimizeButtonHint, True)\r\n        self.setWindowFlag(Qt.WindowMaximizeButtonHint, True)\r\n        self.parent = parent\r\n\r\n        self.layoutparam = QVBoxLayout()\r\n        self.tableWidget = QTableWidget()\r\n\r\n        fnt = QFont()\r\n        fnt.setPointSize(8)\r\n        self.tableWidget.setFont(fnt)\r\n\r\n        Afferences = self.parent.CC.inputpercent\r\n        line, column = Afferences.shape\r\n\r\n        self.tableWidget.horizontalHeader().setDefaultSectionSize(42)\r\n        self.tableWidget.verticalHeader().setDefaultSectionSize(30)\r\n\r\n        self.tableWidget.setRowCount(line+4)\r\n        self.tableWidget.setColumnCount(column+2)\r\n\r\n        self.tableWidget.setItemDelegate(Delegate())\r\n\r\n        item_Layer = [\"I\",\"II/III\",\"IV\",\"V\",\"VI\"]\r\n        item_type = [\"PC\",\"PV\",\"SST\",\"VIP\",\"RLN\"]#d0a9ce\r\n        item_color = [\"#d0a9ce\",\"#c5e0b4\",\"#dae0f3\",\"#f8cbad\",\"#ffe699\"]\r\n\r\n        for j in range(len(item_Layer)):\r\n            item = QTableWidgetItem(item_Layer[j])\r\n            self.tableWidget.setSpan(2+j*5, 0, 5, 1)\r\n            self.tableWidget.setItem(2+j*5, 0, item)\r\n            item2 = QTableWidgetItem(item_Layer[j])\r\n            self.tableWidget.setSpan(0, 2+j*5, 1, 5)\r\n            self.tableWidget.setItem(0, 2+j*5, item2)\r\n\r\n        item = QTableWidgetItem(\"Thalamus\")\r\n        self.tableWidget.setSpan(2 + 24 + 1, 0, 1, 2)\r\n        self.tableWidget.setItem(2 + 24 + 1, 0, item)\r\n        item = QTableWidgetItem(\"Distant Cortex\")\r\n        self.tableWidget.setSpan(2 + 24 + 2, 0, 1, 2)\r\n        self.tableWidget.setItem(2 + 24 + 2, 0, item)\r\n        item = QTableWidgetItem(\"Sources\")\r\n        self.tableWidget.setItem(1, 0, item)\r\n        item = QTableWidgetItem(\"Targets\")\r\n        self.tableWidget.setItem(0, 1, item)\r\n\r\n        ind = 2\r\n        for i in range(5):\r\n            for j in range(len(item_type)):\r\n                item = QTableWidgetItem(item_type[j])\r\n                item2 = QTableWidgetItem(item_type[j])\r\n                item.setBackground(QColor(item_color[j]))\r\n                item2.setBackground(QColor(item_color[j]))\r\n\r\n                self.tableWidget.setItem(ind, 1, item)\r\n                self.tableWidget.setItem(1, ind, item2)\r\n                ind += 1\r\n\r\n        for c in range(Afferences.shape[0]):\r\n            for l in range(Afferences.shape[1]):\r\n                item = QTableWidgetItem(str(Afferences[c, l]))\r\n                self.tableWidget.setItem(c+2, l+2, item)\r\n\r\n        self.buttons = QDialogButtonBox(\r\n            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,\r\n            Qt.Horizontal, self)\r\n        self.buttons.accepted.connect(self.accept)\r\n        self.buttons.rejected.connect(self.reject)\r\n\r\n        self.layoutparam.addWidget(self.tableWidget)\r\n        self.layoutparam.addWidget(self.buttons)\r\n        self.setLayout(self.layoutparam)\r\n\r\n\r\nclass Delegate(QStyledItemDelegate):\r\n    def initStyleOption(self, option, index):\r\n        super(Delegate, self).initStyleOption(option, index)\r\n        option.displayAlignment = Qt.AlignCenter\r\n    # def sizeHint(self, option, index):\r\n    #     s = QStyledItemDelegate.sizeHint(self, option, index)\r\n    #     return max(s.width(), s.height()) * QSize(1, 1)\r\n    # def createEditor(self, parent, option, index):\r\n    #     editor = LineEdit(parent)\r\n    #     return editor\r\n\r\ndef msg_wait(s):\r\n    msg = QMessageBox()\r\n    msg.setIconPixmap(QPixmap(os.path.join('icons','wait.gif')).scaledToWidth(100))\r\n    icon_label = msg.findChild(QLabel, \"qt_msgboxex_icon_label\")\r\n    movie = QMovie(os.path.join('icons','wait.gif'))\r\n    setattr(msg, 'icon_label', movie)\r\n    icon_label.setMovie(movie)\r\n    movie.start()\r\n\r\n    msg.setText(s)\r\n    msg.setWindowTitle(\" \")\r\n    msg.setModal(False)\r\n    # msg.setStandardButtons(QMessageBox.Ok)\r\n    msg.show()\r\n    return msg\r\n\r\n\r\ndef msg_cri(s):\r\n    msg = QMessageBox()\r\n    msg.setIcon(QMessageBox.Critical)\r\n    msg.setText(s)\r\n    msg.setWindowTitle(\" \")\r\n    msg.setStandardButtons(QMessageBox.Ok)\r\n    msg.exec_()\r\n\r\n\r\ndef questionsure(s):\r\n    msg = QMessageBox()\r\n    msg.setIcon(QMessageBox.Warning)\r\n    strname = s\r\n    msg.setText(strname)\r\n    msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)\r\n    ok = msg.exec_()\r\n    if ok == QMessageBox.Ok:\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\ndef main():\r\n    app = QApplication(sys.argv)\r\n\r\n    if platform.system() in ['Darwin', 'Linux']:\r\n        app.setStyle('Windows')\r\n\r\n    import logging\r\n    logging.basicConfig(filename='logdata.log', filemode='w', level=logging.ERROR)\r\n\r\n    def my_excepthook(type, value, tback):\r\n        # log the exception here\r\n        co = tback.tb_frame.f_code\r\n        func_name = co.co_name\r\n        line_no = tback.tb_frame.f_lineno\r\n        filename = co.co_filename\r\n        logging.error(\"main crashed. Error: %s\\n%s\\n%s\", type, value, tback)\r\n        logging.error('Tracing exception: %s \"%s\" \\non line %s of file %s function %s' % (\r\n        type.__name__, value, line_no, filename, func_name))\r\n        import traceback\r\n        string = traceback.format_stack(tback.tb_frame)\r\n        for s in string:\r\n            logging.error('%s\\n' % (s))\r\n        # then call the default handler\r\n        sys.__excepthook__(type, value, tback)\r\n        sys.exit(app.exec())\r\n\r\n    sys.excepthook = my_excepthook\r\n\r\n    ex = ModelMicro_GUI(app)\r\n    ex.setWindowTitle('Model micro GUI')\r\n    # ex.showMaximized()\r\n    ex.show()\r\n    sys.exit(app.exec())\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/GUI.py b/GUI.py
--- a/GUI.py	(revision 9976d0c8b81ff1c904dc67e5aecc659b1ab1d2e0)
+++ b/GUI.py	(date 1653057236084)
@@ -3005,58 +3005,136 @@
             self.mascene_LFPViewer.update(shiftT=self.CC.tps_start - self.T)
         elif meth == 1:
             electrode_pos = np.array(self.electrode_pos)
-
-            # for i, ind in enumerate(self.CC.PreSynaptic_Cell_AMPA):
-            #     pos_neuron = self.CellPosition[self.flatindex[i][0]][self.flatindex[i][1]]
-            #     pos_pre = []
-            #     for k in ind:
-            #         pos_pre.append(self.CellPosition[self.flatindex[k][0]][self.flatindex[k][1]])
-
-            CellPosition_d = []
-            CellPosition_s = []
             CellPosition_a = []
+            CellPosition_d = []
+            CellPosition_d1 = []
+            CellPosition_d23 = []
+            CellPosition_d4 = []
+            CellPosition_d5 = []
+            CellPosition_d6 = []
+            updown=[]
+            CellPosition_s_up =[]
+            CellPosition_s_down = []
             target = Cell_morphology.Neuron(0, 1)
             for layer in range(len(self.CC.Cellpos)):
                 for n in range(self.CC.Cellpos[layer].shape[0]):
                     if self.CC.List_celltypes[layer][n] == 0:
-                        CellPosition_s.append(self.CC.Cellpos[layer][n])
+                        pos=self.CC.Cellpos[layer][n]
                         # subtype == 0  # TPC  subtype = 1  # UPC subtype = 2  # IPC subtype = 3  # BPC subtype = 4  # SSC
                         subtype = self.CC.List_cellsubtypes[layer][n]
                         target.update_type(0, layer=layer, subtype=subtype)
-                        diff_d = np.array([0., 0., target.mid_dend])
-                        diff_a = np.array([0., 0., -target.hsoma])
-                        if subtype in [0, 1, 2, 4]:
-                            CellPosition_d.append(self.CC.Cellpos[layer][n] + diff_d)
-                            CellPosition_a.append(self.CC.Cellpos[layer][n] - diff_a)
+                        d1 = np.array([pos[0],pos[1], self.CC.Layertop_pos[4]])
+                        d23 = np.array([pos[0], pos[1], self.CC.Layertop_pos[3]])
+                        d4 = np.array([pos[0], pos[1], self.CC.Layertop_pos[2]])
+                        d5 = np.array([pos[0], pos[1], self.CC.Layertop_pos[1]])
+                        d6 = np.array([pos[0], pos[1], self.CC.Layertop_pos[0]])
+                        s_down = np.array([pos[0], pos[1], pos[2]-target.hsoma/2])
+                        s_up = np.array([pos[0], pos[1], pos[2]+target.hsoma/2])
+
+                        CellPosition_d1.append(d1)
+                        CellPosition_d23.append(d23)
+                        CellPosition_d4.append(d4)
+                        CellPosition_d5.append(d5)
+                        CellPosition_d6.append(d6)
+
+
+                        if subtype in [0,1,3,4]:
+                            CellPosition_s_up.append(s_up)
+                            CellPosition_s_down.append(s_down)
+                            CellPosition_d.append(np.array([pos[0],pos[1], pos[2]+target.Adend_l]))
+                            CellPosition_a.append(np.array([pos[0], pos[1], pos[2] + target.axon_length]))
+
+
+
                         else:
-                            CellPosition_d.append(self.CC.Cellpos[layer][n] - diff_d)
-                            CellPosition_a.append(self.CC.Cellpos[layer][n] + diff_a)
+                            CellPosition_s_up.append(s_down)
+                            CellPosition_s_down.append(s_up)
+                            CellPosition_d.append(np.array([pos[0],pos[1], pos[2]-target.Adend_l]))
+                            CellPosition_a.append(np.array([pos[0], pos[1], pos[2] -target.axon_length / 2]))
+
 
-            CellPosition_d = np.array(CellPosition_d)
-            CellPosition_s = np.array(CellPosition_s)
+
+
+
+
             CellPosition_a = np.array(CellPosition_a)
+            CellPosition_d = np.array(CellPosition_d)
+            CellPosition_d1 = np.array(CellPosition_d1)
+            CellPosition_d23 = np.array(CellPosition_d23)
+            CellPosition_d4 = np.array(CellPosition_d4)
+            CellPosition_d5 = np.array(CellPosition_d5)
+            CellPosition_d6 = np.array(CellPosition_d6)
+            CellPosition_s_up = np.array(CellPosition_s_up)
+            CellPosition_s_down = np.array(CellPosition_s_down)
+
 
             Distance_from_electrode_d = distance.cdist([electrode_pos, electrode_pos], CellPosition_d, 'euclidean')[0,
                                         :]
-            Distance_from_electrode_s = distance.cdist([electrode_pos, electrode_pos], CellPosition_s, 'euclidean')[0,
+
+            Distance_from_electrode_d1 = distance.cdist([electrode_pos, electrode_pos], CellPosition_d1, 'euclidean')[0,
+                                        :]
+            Distance_from_electrode_d23 = distance.cdist([electrode_pos, electrode_pos], CellPosition_d23, 'euclidean')[0,
+                                        :]
+            Distance_from_electrode_d4 = distance.cdist([electrode_pos, electrode_pos], CellPosition_d4, 'euclidean')[0,
+                                        :]
+            Distance_from_electrode_d5 = distance.cdist([electrode_pos, electrode_pos], CellPosition_d5, 'euclidean')[0,
+                                        :]
+            Distance_from_electrode_d6 = distance.cdist([electrode_pos, electrode_pos], CellPosition_d6, 'euclidean')[0,
                                         :]
+            Distance_from_electrode_s_up = distance.cdist([electrode_pos, electrode_pos], CellPosition_s_up, 'euclidean')[0,
+                                        :]
+            Distance_from_electrode_s_down = distance.cdist([electrode_pos, electrode_pos], CellPosition_s_down, 'euclidean')[0,
+                                        :]
+
             Distance_from_electrode_a = distance.cdist([electrode_pos, electrode_pos], CellPosition_a, 'euclidean')[0,
                                         :]
 
             Res = np.zeros(self.pyrPPSE_d.shape[1])
             sigma = 33e-5
-            for k in range(CellPosition_a.shape[0]):
-                Res = Res + ((self.pyrPPSE_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d[k]))
-                Res = Res - ((self.pyrPPSE_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))
+            for k in range(CellPosition_s_up.shape[0]):
+
+                ### PPSE dendrite
+                Res = Res + ((self.pyrPPSE_d1[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d1[k]))
+                Res = Res - ((self.pyrPPSE_d1[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res + ((self.pyrPPSE_d23[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d23[k]))
+                Res = Res - ((self.pyrPPSE_d23[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res + ((self.pyrPPSE_d4[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d4[k]))
+                Res = Res - ((self.pyrPPSE_d4[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res + ((self.pyrPPSE_d5[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d5[k]))
+                Res = Res - ((self.pyrPPSE_d5[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
 
-                Res = Res - ((self.pyrPPSI_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d[k]))
-                Res = Res + ((self.pyrPPSI_d[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))
+                Res = Res + ((self.pyrPPSE_d6[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d6[k]))
+                Res = Res - ((self.pyrPPSE_d6[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
 
-                Res = Res - ((self.pyrPPSI_s[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))
+                ### PPSI dendrite
+
+                Res = Res - ((self.pyrPPSI_d1_d1[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d1[k]))
+                Res = Res + ((self.pyrPPSI_d1[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res - ((self.pyrPPSI_d23[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d23[k]))
+                Res = Res + ((self.pyrPPSI_d23[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res - ((self.pyrPPSI_d4[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d4[k]))
+                Res = Res + ((self.pyrPPSI_d4[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res - ((self.pyrPPSI_d5[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d5[k]))
+                Res = Res + ((self.pyrPPSI_d5[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                Res = Res - ((self.pyrPPSI_d6[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d6[k]))
+                Res = Res + ((self.pyrPPSI_d6[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
+
+                ### PPSI soma
+
+                Res = Res - ((self.pyrPPSI_s[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_up[k]))
                 Res = Res + ((self.pyrPPSI_s[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_d[k]))
 
+                ### PPSE Axon
+
                 Res = Res - ((self.pyrPPSI_a[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_a[k]))
-                Res = Res + ((self.pyrPPSI_a[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s[k]))
+                Res = Res + ((self.pyrPPSI_a[k, :]) / ((4 * np.pi * sigma) * Distance_from_electrode_s_down[k]))
 
             self.LFP = Res
             self.mascene_LFPViewer.update(shiftT=self.CC.tps_start - self.T)
